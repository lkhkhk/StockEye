## 봇 관리자 명령어(`update_master`) 인증/인가 오류 해결 (2025-08-12)

*   **목표:** 텔레그램 봇의 관리자 명령어가 API 서버로부터 404, 403 등 다양한 오류를 반환하며 실패하는 문제를 근본적으로 해결하고, 안정적인 서비스 간 인증/인가 체계를 구축합니다.

*   **문제 해결 과정:**
    1.  **초기 문제 (404 Not Found):**
        *   **원인:** Bot이 호출하는 API 엔드포인트(`POST /admin/update_master`)가 `src/api/routers/admin.py`에 구현되어 있지 않았습니다.
        *   **해결:** 해당 라우터 파일에 누락된 엔드포인트 로직을 추가했습니다.

    2.  **2차 문제 (404 Not Found):**
        *   **원인:** API의 모든 라우터에는 `/api/v1` 전역 접두사가 적용되지만, Bot이 API를 호출할 때 이 접두사를 누락하여 잘못된 URL로 요청하고 있었습니다.
        *   **해결:** `src/bot/handlers/admin.py`의 API 호출 URL에 `/api/v1`을 포함하도록 수정했습니다.

    3.  **3차 문제 (403 Forbidden):**
        *   **원인:** URL 문제는 해결되었으나, Bot이 API의 보호된 관리자 엔드포인트를 호출할 때 아무런 인증 정보(JWT 토큰)를 보내지 않아 API가 접근을 거부했습니다.
        *   **분석:** Bot은 `telegram_id`로 관리자를 식별하지만, API는 `JWT 토큰`으로 인가(Authorization)를 처리하는 근본적인 불일치가 있었습니다.

    4.  **아키텍처 보완 및 최종 해결:**
        *   **사용자 자동 등록 및 관리자 역할 부여:**
            *   사용자가 봇과 처음 상호작용할 때, DB에 해당 사용자가 없으면 자동으로 등록하는 `@ensure_user_registered` 데코레이터를 `src/bot/decorators.py`에 구현했습니다.
            *   `src/api/services/user_service.py`를 수정하여, 새로 등록되는 사용자의 `telegram_id`가 환경변수 `TELEGRAM_ADMIN_ID`와 일치하면 `role`을 `admin`으로 자동 설정하도록 변경했습니다.
        *   **Bot 전용 토큰 발급 엔드포인트 신설:**
            *   Bot이 `telegram_id`를 이용해 해당 사용자의 JWT 토큰을 발급받을 수 있는 `POST /api/v1/auth/bot/token` 엔드포인트를 `src/api/routers/auth.py`에 신설했습니다.
            *   이 엔드포인트는 Bot과 API만 아는 비밀 키(`BOT_SECRET_KEY`)를 `X-Bot-Secret-Key` 헤더로 받아야만 호출할 수 있도록 보호됩니다.
        *   **Bot 핸들러 수정:**
            *   `src/bot/handlers/admin.py`의 모든 관리자 명령어 핸들러를 수정했습니다.
            *   핸들러는 API 호출 전, 먼저 `/auth/bot/token`을 호출하여 현재 명령을 내린 사용자의 JWT 토큰을 발급받습니다.
            *   그 후, 발급받은 토큰을 `Authorization: Bearer <token>` 헤더에 담아 원래 목적지(예: `/admin/update_master`)에 요청을 보냅니다.

    5.  **순환 참조 및 기타 오류 해결:**
        *   위 아키텍처를 구현하는 과정에서 다수의 순환 참조(`Circular Import`) 오류와 `await` 키워드 오용 오류가 발생했습니다.
        *   `jwt_handler.py`, `auth.py`, `admin.py` 등의 파일을 여러 차례 수정하여 모든 오류를 해결하고, `docker compose up`이 정상적으로 실행되도록 조치했습니다.

*   **결과:** 복잡하게 얽혀있던 서비스 간 인증/인가 문제를 최종적으로 해결했습니다. 이제 관리자 사용자는 봇을 통해 관리자 명령어를 정상적으로 실행할 수 있습니다.

---

## 🐞 `trigger_job` 명령어 버그 수정 및 기능 개선 (2025-08-12)

*   **목표:** `trigger_job` 명령어가 실제 잡을 실행하지 못하는 버그를 수정하고, 사용자 경험 개선을 위해 잡 실행 요청과 완료를 분리하여 알림을 제공하도록 기능을 개선합니다.

*   **문제 해결 및 기능 개선 과정:**
    1.  **버그 분석 (잡 미실행):**
        *   **원인:** `src/worker/routers/scheduler.py`의 `trigger_scheduler_job` 함수가 `job.modify()` 대신 `scheduler.add_job()`을 사용하여, 기존 잡을 즉시 실행하는 대신 새로운 일회성 잡을 만드는 잘못된 로직을 사용하고 있었습니다.
        *   **해결:** `job.modify(next_run_time=datetime.now(job.next_run_time.tzinfo))`를 사용하도록 수정하여, 지정된 잡이 즉시 실행되도록 올바르게 변경했습니다.

    2.  **기능 개선 (2단계 알림):**
        *   **요구사항:** 사용자가 잡 실행을 요청했을 때 '요청 접수' 알림을 즉시 받고, 해당 잡이 실제로 완료되었을 때 '완료 알림'을 추가로 받도록 개선합니다.
        *   **구현:**
            *   **`src/worker/main.py`:** 모든 잡 함수(`update_stock_master_job` 등)가 선택적으로 `chat_id`를 인자로 받도록 수정했습니다. 잡이 완료되면, `chat_id`가 있을 경우 Redis Pub/Sub를 통해 해당 사용자에게 완료 알림 메시지를 발행하도록 로직을 추가했습니다.
            *   **`src/worker/routers/scheduler.py`:** `trigger_scheduler_job` 엔드포인트가 요청 본문으로 `chat_id`를 받아, 잡을 즉시 실행하도록 수정할 때 `kwargs`를 통해 이 `chat_id`를 잡 함수로 전달하도록 변경했습니다.
            *   **`src/api/routers/admin.py`:** Bot으로부터 `chat_id`를 받아 Worker로 전달하는 프록시 역할을 하도록 `trigger_schedule_job` 엔드포인트를 수정했습니다.
            *   **`src/bot/handlers/admin.py`:**
                *   `admin_trigger_job` 핸들러가 API 호출 시 `chat_id`를 함께 보내도록 수정했습니다.
                *   사용자에게 보내는 초기 메시지를 "✅ 잡 실행 요청이 접수되었습니다..."로 변경하여, 요청과 완료가 분리되었음을 명확히 했습니다.

    3.  **버그 분석 (완료 알림 미수신):**
        *   **원인:** 2단계 알림 기능 구현 후 테스트 과정에서 완료 알림이 오지 않는 문제가 발생했습니다. `stockeye-worker` 로그 분석 결과, `TELEGRAM_BOT_TOKEN` 환경 변수가 설정되지 않아 Redis에서 메시지를 수신했음에도 텔레그램으로 발송하지 못하는 것을 확인했습니다.
        *   **해결:** `docker-compose.yml` 파일에서 `stockeye-worker` 서비스의 `environment` 섹션에 정의된 `TELEGRAM_BOT_TOKEN` 관련 라인을 제거하여, `.env` 파일로부터 토큰을 올바르게 상속받도록 수정했습니다.

*   **결과:** `trigger_job` 명령어의 버그를 해결하고, 2단계 알림 시스템을 도입하여 사용자 경험을 향상시켰습니다. 모든 서비스가 정상적으로 재기동되어 기능이 올바르게 동작함을 확인했습니다.

---

## ✨ `show_schedules` 기능 개선 및 Healthcheck 설정 조정 (2025-08-12)

*   **목표:** `/show_schedules` 명령어의 사용성을 개선하고, 개발 환경에서 과도하게 발생하는 `healthcheck` 로그 문제를 해결합니다.

*   **주요 개선 및 수정 내용:**
    1.  **`/show_schedules` 기능 개선:**
        *   **요구사항:** 스케줄러 잡 목록을 보여줄 때, 단순 텍스트가 아닌 각 잡을 즉시 실행할 수 있는 버튼을 함께 제공하고, 잡 ID 대신 알기 쉬운 명칭을 표시합니다.
        *   **구현:**
            *   **`src/worker/main.py`:** `scheduler.add_job` 호출 시, `id`와 별개로 사용자 친화적인 `name`(예: '종목 마스터 갱신')을 추가했습니다.
            *   **`src/bot/handlers/admin.py`:**
                *   `admin_show_schedules` 핸들러가 잡 목록을 조회한 후, 각 잡의 `name`으로 `InlineKeyboardButton`을 생성하도록 수정했습니다.
                *   버튼의 `callback_data`에 `trigger_job_{job_id}` 형식으로 잡 ID를 담아, 어떤 잡을 실행할지 식별할 수 있도록 했습니다.
                *   버튼 클릭 시 호출될 `trigger_job_callback` 핸들러를 신설하여, 잡 실행 요청 및 결과 알림을 처리하도록 구현했습니다.
            *   **`src/bot/main.py`:** 신규 `trigger_job_callback` 핸들러를 봇 애플리케이션에 등록했습니다.

    2.  **Healthcheck 설정 조정:**
        *   **문제:** 개발 환경에서 `docker-compose`의 `healthcheck`가 5초마다 실행되어, 너무 많은 로그가 쌓여 다른 로그를 분석하기 어려운 문제가 있었습니다.
        *   **논의:** 사용자와의 논의를 통해, `healthcheck`의 목적(서비스 시작 순서 보장 및 상태 감시)과 개발 편의성(로그 감소) 사이의 타협점을 찾았습니다.
        *   **해결:** `docker-compose.yml` 파일에서 `stockeye-api`, `stockeye-db`, `stockeye-redis` 서비스의 `healthcheck` `interval`을 **15초**로, `timeout`을 **10초**로, `retries`를 **3회**로 조정하여, 서비스 시작 시간 지연을 최소화하면서 로그 발생 빈도를 크게 줄였습니다.

*   **결과:** `/show_schedules` 명령어의 편의성이 향상되었고, 개발 환경의 로그가 간소화되어 분석이 용이해졌습니다.
