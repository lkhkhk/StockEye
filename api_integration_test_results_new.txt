\n--- Running test_stock_service_integration.py ---
============================= test session starts ==============================
platform linux -- Python 3.10.18, pytest-8.4.1, pluggy-1.6.0
rootdir: /app/src/api
plugins: cov-6.2.1, timeout-2.4.0, anyio-4.10.0, asyncio-1.1.0
asyncio: mode=strict, asyncio_default_fixture_loop_scope=None, asyncio_default_test_loop_scope=function
collected 31 items

tests/integration/test_stock_service_integration.py 
\n--- Running test_stock_service_integration.py (30s timeout) ---
============================= test session starts ==============================
platform linux -- Python 3.10.18, pytest-8.4.1, pluggy-1.6.0
rootdir: /app/src/api
plugins: cov-6.2.1, timeout-2.4.0, anyio-4.10.0, asyncio-1.1.0
asyncio: mode=strict, asyncio_default_fixture_loop_scope=None, asyncio_default_test_loop_scope=function
collected 31 items

tests/integration/test_stock_service_integration.py 
\n--- Running test_stock_service_integration.py (60s timeout) ---
============================= test session starts ==============================
platform linux -- Python 3.10.18, pytest-8.4.1, pluggy-1.6.0
rootdir: /app/src/api
plugins: cov-6.2.1, timeout-2.4.0, anyio-4.10.0, asyncio-1.1.0
asyncio: mode=strict, asyncio_default_fixture_loop_scope=None, asyncio_default_test_loop_scope=function
collected 31 items

tests/integration/test_stock_service_integration.py 
\n--- Running test_price_alert_service_integration.py ---
============================= test session starts ==============================
platform linux -- Python 3.10.18, pytest-8.4.1, pluggy-1.6.0
rootdir: /app/src/api
plugins: cov-6.2.1, timeout-2.4.0, anyio-4.10.0, asyncio-1.1.0
asyncio: mode=strict, asyncio_default_fixture_loop_scope=None, asyncio_default_test_loop_scope=function
collected 1 item

tests/integration/test_price_alert_service_integration.py F              [100%]

=================================== FAILURES ===================================
____________ test_check_price_alerts_publishes_to_redis_on_trigger _____________

price_alert_service = <src.common.services.price_alert_service.PriceAlertService object at 0x7ffb954ad150>
real_db = <sqlalchemy.orm.session.Session object at 0x7ffb954a5ab0>

    @pytest.mark.asyncio
    async def test_check_price_alerts_publishes_to_redis_on_trigger(price_alert_service, real_db):
        """알림 조건 충족 시 check_price_alerts가 Redis에 메시지를 발행하는지 통합 테스트"""
        # 1. Redis 구독 클라이언트 설정
        redis_client = redis.Redis(host=REDIS_HOST, port=REDIS_PORT, decode_responses=True)
        pubsub = redis_client.pubsub()
        await pubsub.subscribe("notifications")
        await asyncio.sleep(0.1)
    
        # 2. Given: 테스트 데이터 설정
        # 사용자 생성
>       test_user = User(id=1, username="testuser", email="test@example.com", telegram_id="12345", password_hash="hashed_password")

tests/integration/test_price_alert_service_integration.py:42: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
<string>:4: in __init__
    ???
/usr/local/lib/python3.10/site-packages/sqlalchemy/orm/state.py:571: in _initialize_instance
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/orm/state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.common.models.user.User object at 0x7ffb954b1c60>
kwargs = {'email': 'test@example.com', 'id': 1, 'password_hash': 'hashed_password', 'telegram_id': '12345', ...}
cls_ = <class 'src.common.models.user.User'>, k = 'password_hash'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'password_hash' is an invalid keyword argument for User

/usr/local/lib/python3.10/site-packages/sqlalchemy/orm/decl_base.py:2179: TypeError
---------------------------- Captured stdout setup -----------------------------
2025-08-31 17:45:09,796 - src.common.services.price_alert_service - DEBUG - PriceAlertService 초기화.
2025-08-31 17:45:09,944 - asyncio - DEBUG - Using selector: EpollSelector
2025-08-31 17:45:09,945 - asyncio - DEBUG - Using selector: EpollSelector
------------------------------ Captured log setup ------------------------------
DEBUG    src.common.services.price_alert_service:price_alert_service.py:21 PriceAlertService 초기화.
DEBUG    asyncio:selector_events.py:54 Using selector: EpollSelector
DEBUG    asyncio:selector_events.py:54 Using selector: EpollSelector
=============================== warnings summary ===============================
../../../usr/local/lib/python3.10/site-packages/pydantic/_internal/_config.py:323
../../../usr/local/lib/python3.10/site-packages/pydantic/_internal/_config.py:323
../../../usr/local/lib/python3.10/site-packages/pydantic/_internal/_config.py:323
  /usr/local/lib/python3.10/site-packages/pydantic/_internal/_config.py:323: PydanticDeprecatedSince20: Support for class-based `config` is deprecated, use ConfigDict instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.11/migration/
    warnings.warn(DEPRECATION_MESSAGE, DeprecationWarning)

../../../usr/local/lib/python3.10/site-packages/pydantic/_internal/_config.py:373
  /usr/local/lib/python3.10/site-packages/pydantic/_internal/_config.py:373: UserWarning: Valid config keys have changed in V2:
  * 'orm_mode' has been renamed to 'from_attributes'
    warnings.warn(message, UserWarning)

main.py:112
  /app/src/api/main.py:112: DeprecationWarning: 
          on_event is deprecated, use lifespan event handlers instead.
  
          Read more about it in the
          [FastAPI docs for Lifespan Events](https://fastapi.tiangolo.com/advanced/events/).
          
    @app.on_event("startup")

../../../usr/local/lib/python3.10/site-packages/fastapi/applications.py:4495
  /usr/local/lib/python3.10/site-packages/fastapi/applications.py:4495: DeprecationWarning: 
          on_event is deprecated, use lifespan event handlers instead.
  
          Read more about it in the
          [FastAPI docs for Lifespan Events](https://fastapi.tiangolo.com/advanced/events/).
          
    return self.router.on_event(event_type)

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
=========================== short test summary info ============================
FAILED tests/integration/test_price_alert_service_integration.py::test_check_price_alerts_publishes_to_redis_on_trigger
======================== 1 failed, 6 warnings in 1.18s =========================
\n--- Running test_api_admin_integration.py ---
============================= test session starts ==============================
platform linux -- Python 3.10.18, pytest-8.4.1, pluggy-1.6.0
rootdir: /app/src/api
plugins: cov-6.2.1, timeout-2.4.0, anyio-4.10.0, asyncio-1.1.0
asyncio: mode=strict, asyncio_default_fixture_loop_scope=None, asyncio_default_test_loop_scope=function
collected 24 items

tests/integration/test_api_admin_integration.py EEFEEEFE
\n--- Running test_api_admin_integration.py (30s timeout) ---
============================= test session starts ==============================
platform linux -- Python 3.10.18, pytest-8.4.1, pluggy-1.6.0
rootdir: /app/src/api
plugins: cov-6.2.1, timeout-2.4.0, anyio-4.10.0, asyncio-1.1.0
asyncio: mode=strict, asyncio_default_fixture_loop_scope=None, asyncio_default_test_loop_scope=function
collected 24 items

tests/integration/test_api_admin_integration.py EEFEEEFEEEFEEEEFEFEFEEEF
\n--- Running test_api_admin_integration.py (60s timeout) ---
============================= test session starts ==============================
platform linux -- Python 3.10.18, pytest-8.4.1, pluggy-1.6.0
rootdir: /app/src/api
plugins: cov-6.2.1, timeout-2.4.0, anyio-4.10.0, asyncio-1.1.0
asyncio: mode=strict, asyncio_default_fixture_loop_scope=None, asyncio_default_test_loop_scope=function
collected 24 items

tests/integration/test_api_admin_integration.py EEFEEEFEEEFEEEEFEFEFEEEF [100%]

==================================== ERRORS ====================================
_________ ERROR at setup of TestAdminRouter.test_admin_stats_as_admin __________

real_db = <sqlalchemy.orm.session.Session object at 0x7facddd6db10>

    @pytest.fixture
    def admin_user_and_headers(real_db: Session):
        """
        테스트용 관리자 사용자와 인증 헤더를 생성하는 Fixture.
    
        - **목적**: 관리자 권한이 필요한 API를 테스트하기 위해 사전에 관리자 계정과 JWT 토큰을 생성합니다.
        - **반환**: 생성된 User 모델 객체와 HTTP 요청에 사용될 인증 헤더(딕셔너리)를 튜플로 반환합니다.
        """
>       admin_user = create_test_user(real_db, role="admin")

tests/integration/test_api_admin_integration.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/helpers.py:14: in create_test_user
    user = User(
<string>:4: in __init__
    ???
/usr/local/lib/python3.10/site-packages/sqlalchemy/orm/state.py:571: in _initialize_instance
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/orm/state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.common.models.user.User object at 0x7facdde77730>
kwargs = {'email': 'test_5010b60b1e064d95b043fa8a0e622f8c@example.com', 'is_active': True, 'password_hash': '$2b$12$QyqnPNSybRmflnHw/S9n/ODxtrUgOkhmrGPE.NAWd7rrr7lbX3Xbu', 'role': 'admin', ...}
cls_ = <class 'src.common.models.user.User'>, k = 'password_hash'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'password_hash' is an invalid keyword argument for User

/usr/local/lib/python3.10/site-packages/sqlalchemy/orm/decl_base.py:2179: TypeError
---------------------------- Captured stdout setup -----------------------------
2025-08-31 17:47:23,627 - asyncio - DEBUG - Using selector: EpollSelector
2025-08-31 17:47:23,671 - src.api.main - INFO - 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
2025-08-31 17:47:23,900 - src.api.main - INFO - 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 17:47:23,948 - src.api.main - INFO - 테스트 StockMaster 데이터 시딩 완료.
2025-08-31 17:47:23,949 - src.api.main - INFO - 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 17:47:24,113 - src.api.main - INFO - 테스트 DailyPrice 데이터 시딩 완료.
2025-08-31 17:47:24,115 - passlib.handlers.bcrypt - WARNING - (trapped) error reading bcrypt version
Traceback (most recent call last):
  File "/usr/local/lib/python3.10/site-packages/passlib/handlers/bcrypt.py", line 620, in _load_backend_mixin
    version = _bcrypt.__about__.__version__
AttributeError: module 'bcrypt' has no attribute '__about__'
2025-08-31 17:47:24,117 - passlib.handlers.bcrypt - DEBUG - detected 'bcrypt' backend, version '<unknown>'
2025-08-31 17:47:24,117 - passlib.handlers.bcrypt - DEBUG - 'bcrypt' backend lacks $2$ support, enabling workaround
------------------------------ Captured log setup ------------------------------
DEBUG    asyncio:selector_events.py:54 Using selector: EpollSelector
INFO     src.api.main:main.py:58 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
INFO     src.api.main:main.py:62 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:77 테스트 StockMaster 데이터 시딩 완료.
INFO     src.api.main:main.py:80 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:106 테스트 DailyPrice 데이터 시딩 완료.
WARNING  passlib.handlers.bcrypt:bcrypt.py:622 (trapped) error reading bcrypt version
Traceback (most recent call last):
  File "/usr/local/lib/python3.10/site-packages/passlib/handlers/bcrypt.py", line 620, in _load_backend_mixin
    version = _bcrypt.__about__.__version__
AttributeError: module 'bcrypt' has no attribute '__about__'
DEBUG    passlib.handlers.bcrypt:bcrypt.py:625 detected 'bcrypt' backend, version '<unknown>'
DEBUG    passlib.handlers.bcrypt:bcrypt.py:406 'bcrypt' backend lacks $2$ support, enabling workaround
______ ERROR at setup of TestAdminRouter.test_admin_stats_as_normal_user _______

real_db = <sqlalchemy.orm.session.Session object at 0x7facfc3af4f0>

    @pytest.fixture
    def normal_user_and_headers(real_db: Session):
        """
        테스트용 일반 사용자와 인증 헤더를 생성하는 Fixture.
    
        - **목적**: 일반 사용자 권한으로 API 접근 시의 동작을 테스트하기 위해 사용자 계정과 토큰을 생성합니다.
        - **반환**: 생성된 User 모델 객체와 HTTP 요청에 사용될 인증 헤더(딕셔너리)를 튜플로 반환합니다.
        """
>       normal_user = create_test_user(real_db, role="user")

tests/integration/test_api_admin_integration.py:52: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/helpers.py:14: in create_test_user
    user = User(
<string>:4: in __init__
    ???
/usr/local/lib/python3.10/site-packages/sqlalchemy/orm/state.py:571: in _initialize_instance
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/orm/state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.common.models.user.User object at 0x7facdde3c610>
kwargs = {'email': 'test_fca1a90d2412486da3325818c15edd2e@example.com', 'is_active': True, 'password_hash': '$2b$12$lsXCT34xU7FMkjXRNIEOGe8gx5nJ.sMnT7cdIijYNHK6ZBtX1j4lm', 'role': 'user', ...}
cls_ = <class 'src.common.models.user.User'>, k = 'password_hash'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'password_hash' is an invalid keyword argument for User

/usr/local/lib/python3.10/site-packages/sqlalchemy/orm/decl_base.py:2179: TypeError
---------------------------- Captured stdout setup -----------------------------
2025-08-31 17:47:24,918 - asyncio - DEBUG - Using selector: EpollSelector
2025-08-31 17:47:24,930 - src.api.main - INFO - 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
2025-08-31 17:47:25,118 - src.api.main - INFO - 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 17:47:25,125 - src.api.main - INFO - 테스트 StockMaster 데이터 시딩 완료.
2025-08-31 17:47:25,126 - src.api.main - INFO - 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 17:47:25,138 - src.api.main - INFO - 테스트 DailyPrice 데이터 시딩 완료.
------------------------------ Captured log setup ------------------------------
DEBUG    asyncio:selector_events.py:54 Using selector: EpollSelector
INFO     src.api.main:main.py:58 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
INFO     src.api.main:main.py:62 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:77 테스트 StockMaster 데이터 시딩 완료.
INFO     src.api.main:main.py:80 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:106 테스트 DailyPrice 데이터 시딩 완료.
____ ERROR at setup of TestAdminRouter.test_update_master_success_as_admin _____

real_db = <sqlalchemy.orm.session.Session object at 0x7facdd390430>

    @pytest.fixture
    def admin_user_and_headers(real_db: Session):
        """
        테스트용 관리자 사용자와 인증 헤더를 생성하는 Fixture.
    
        - **목적**: 관리자 권한이 필요한 API를 테스트하기 위해 사전에 관리자 계정과 JWT 토큰을 생성합니다.
        - **반환**: 생성된 User 모델 객체와 HTTP 요청에 사용될 인증 헤더(딕셔너리)를 튜플로 반환합니다.
        """
>       admin_user = create_test_user(real_db, role="admin")

tests/integration/test_api_admin_integration.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/helpers.py:14: in create_test_user
    user = User(
<string>:4: in __init__
    ???
/usr/local/lib/python3.10/site-packages/sqlalchemy/orm/state.py:571: in _initialize_instance
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/orm/state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.common.models.user.User object at 0x7facdd393f40>
kwargs = {'email': 'test_212750fa0b0e473883413ed8cd9b4db5@example.com', 'is_active': True, 'password_hash': '$2b$12$D7BQuP16b9pQ1..mc9EH8O.jZL7PVJMu9P8FSvv/2QCoul99Oisn.', 'role': 'admin', ...}
cls_ = <class 'src.common.models.user.User'>, k = 'password_hash'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'password_hash' is an invalid keyword argument for User

/usr/local/lib/python3.10/site-packages/sqlalchemy/orm/decl_base.py:2179: TypeError
---------------------------- Captured stdout setup -----------------------------
2025-08-31 17:47:26,159 - asyncio - DEBUG - Using selector: EpollSelector
2025-08-31 17:47:26,173 - src.api.main - INFO - 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
2025-08-31 17:47:26,362 - src.api.main - INFO - 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 17:47:26,370 - src.api.main - INFO - 테스트 StockMaster 데이터 시딩 완료.
2025-08-31 17:47:26,370 - src.api.main - INFO - 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 17:47:26,386 - src.api.main - INFO - 테스트 DailyPrice 데이터 시딩 완료.
------------------------------ Captured log setup ------------------------------
DEBUG    asyncio:selector_events.py:54 Using selector: EpollSelector
INFO     src.api.main:main.py:58 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
INFO     src.api.main:main.py:62 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:77 테스트 StockMaster 데이터 시딩 완료.
INFO     src.api.main:main.py:80 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:106 테스트 DailyPrice 데이터 시딩 완료.
____ ERROR at setup of TestAdminRouter.test_update_master_failure_as_admin _____

real_db = <sqlalchemy.orm.session.Session object at 0x7facdd3926e0>

    @pytest.fixture
    def admin_user_and_headers(real_db: Session):
        """
        테스트용 관리자 사용자와 인증 헤더를 생성하는 Fixture.
    
        - **목적**: 관리자 권한이 필요한 API를 테스트하기 위해 사전에 관리자 계정과 JWT 토큰을 생성합니다.
        - **반환**: 생성된 User 모델 객체와 HTTP 요청에 사용될 인증 헤더(딕셔너리)를 튜플로 반환합니다.
        """
>       admin_user = create_test_user(real_db, role="admin")

tests/integration/test_api_admin_integration.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/helpers.py:14: in create_test_user
    user = User(
<string>:4: in __init__
    ???
/usr/local/lib/python3.10/site-packages/sqlalchemy/orm/state.py:571: in _initialize_instance
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/orm/state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.common.models.user.User object at 0x7facdd392e30>
kwargs = {'email': 'test_1bbbd2d86d8945fc884989df2d626713@example.com', 'is_active': True, 'password_hash': '$2b$12$QVWFgqD/Lb1s.JTGKKZ9M.KjsNT39xfB3nRqZ.cFH3vQrdTGKsev.', 'role': 'admin', ...}
cls_ = <class 'src.common.models.user.User'>, k = 'password_hash'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'password_hash' is an invalid keyword argument for User

/usr/local/lib/python3.10/site-packages/sqlalchemy/orm/decl_base.py:2179: TypeError
---------------------------- Captured stdout setup -----------------------------
2025-08-31 17:47:27,166 - asyncio - DEBUG - Using selector: EpollSelector
2025-08-31 17:47:27,176 - src.api.main - INFO - 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
2025-08-31 17:47:27,348 - src.api.main - INFO - 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 17:47:27,358 - src.api.main - INFO - 테스트 StockMaster 데이터 시딩 완료.
2025-08-31 17:47:27,359 - src.api.main - INFO - 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 17:47:27,373 - src.api.main - INFO - 테스트 DailyPrice 데이터 시딩 완료.
------------------------------ Captured log setup ------------------------------
DEBUG    asyncio:selector_events.py:54 Using selector: EpollSelector
INFO     src.api.main:main.py:58 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
INFO     src.api.main:main.py:62 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:77 테스트 StockMaster 데이터 시딩 완료.
INFO     src.api.main:main.py:80 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:106 테스트 DailyPrice 데이터 시딩 완료.
_____ ERROR at setup of TestAdminRouter.test_update_master_as_normal_user ______

real_db = <sqlalchemy.orm.session.Session object at 0x7facddd6db10>

    @pytest.fixture
    def normal_user_and_headers(real_db: Session):
        """
        테스트용 일반 사용자와 인증 헤더를 생성하는 Fixture.
    
        - **목적**: 일반 사용자 권한으로 API 접근 시의 동작을 테스트하기 위해 사용자 계정과 토큰을 생성합니다.
        - **반환**: 생성된 User 모델 객체와 HTTP 요청에 사용될 인증 헤더(딕셔너리)를 튜플로 반환합니다.
        """
>       normal_user = create_test_user(real_db, role="user")

tests/integration/test_api_admin_integration.py:52: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/helpers.py:14: in create_test_user
    user = User(
<string>:4: in __init__
    ???
/usr/local/lib/python3.10/site-packages/sqlalchemy/orm/state.py:571: in _initialize_instance
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/orm/state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.common.models.user.User object at 0x7facddd6feb0>
kwargs = {'email': 'test_fe693e7c3a7844a89e444fe77d1a88aa@example.com', 'is_active': True, 'password_hash': '$2b$12$xsO22lu.Nm6r5WbPZr5E3uhLq8avYRO4E4kb8uAuIx40X5ezBkcau', 'role': 'user', ...}
cls_ = <class 'src.common.models.user.User'>, k = 'password_hash'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'password_hash' is an invalid keyword argument for User

/usr/local/lib/python3.10/site-packages/sqlalchemy/orm/decl_base.py:2179: TypeError
---------------------------- Captured stdout setup -----------------------------
2025-08-31 17:47:28,000 - asyncio - DEBUG - Using selector: EpollSelector
2025-08-31 17:47:28,012 - src.api.main - INFO - 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
2025-08-31 17:47:28,193 - src.api.main - INFO - 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 17:47:28,201 - src.api.main - INFO - 테스트 StockMaster 데이터 시딩 완료.
2025-08-31 17:47:28,201 - src.api.main - INFO - 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 17:47:28,214 - src.api.main - INFO - 테스트 DailyPrice 데이터 시딩 완료.
------------------------------ Captured log setup ------------------------------
DEBUG    asyncio:selector_events.py:54 Using selector: EpollSelector
INFO     src.api.main:main.py:58 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
INFO     src.api.main:main.py:62 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:77 테스트 StockMaster 데이터 시딩 완료.
INFO     src.api.main:main.py:80 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:106 테스트 DailyPrice 데이터 시딩 완료.
_____ ERROR at setup of TestAdminRouter.test_update_price_success_as_admin _____

real_db = <sqlalchemy.orm.session.Session object at 0x7facdde3ccd0>

    @pytest.fixture
    def admin_user_and_headers(real_db: Session):
        """
        테스트용 관리자 사용자와 인증 헤더를 생성하는 Fixture.
    
        - **목적**: 관리자 권한이 필요한 API를 테스트하기 위해 사전에 관리자 계정과 JWT 토큰을 생성합니다.
        - **반환**: 생성된 User 모델 객체와 HTTP 요청에 사용될 인증 헤더(딕셔너리)를 튜플로 반환합니다.
        """
>       admin_user = create_test_user(real_db, role="admin")

tests/integration/test_api_admin_integration.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/helpers.py:14: in create_test_user
    user = User(
<string>:4: in __init__
    ???
/usr/local/lib/python3.10/site-packages/sqlalchemy/orm/state.py:571: in _initialize_instance
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/orm/state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.common.models.user.User object at 0x7facdde3cb80>
kwargs = {'email': 'test_37ed23cbc22c4d16aedca39aa86200d3@example.com', 'is_active': True, 'password_hash': '$2b$12$KY1wA.8o8NGXxUTGdxzRE.Kcf3DEno.qTHz7zrNwNj/dIW3v3AwsS', 'role': 'admin', ...}
cls_ = <class 'src.common.models.user.User'>, k = 'password_hash'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'password_hash' is an invalid keyword argument for User

/usr/local/lib/python3.10/site-packages/sqlalchemy/orm/decl_base.py:2179: TypeError
---------------------------- Captured stdout setup -----------------------------
2025-08-31 17:47:29,428 - asyncio - DEBUG - Using selector: EpollSelector
2025-08-31 17:47:29,437 - src.api.main - INFO - 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
2025-08-31 17:47:29,613 - src.api.main - INFO - 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 17:47:29,620 - src.api.main - INFO - 테스트 StockMaster 데이터 시딩 완료.
2025-08-31 17:47:29,621 - src.api.main - INFO - 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 17:47:29,637 - src.api.main - INFO - 테스트 DailyPrice 데이터 시딩 완료.
------------------------------ Captured log setup ------------------------------
DEBUG    asyncio:selector_events.py:54 Using selector: EpollSelector
INFO     src.api.main:main.py:58 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
INFO     src.api.main:main.py:62 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:77 테스트 StockMaster 데이터 시딩 완료.
INFO     src.api.main:main.py:80 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:106 테스트 DailyPrice 데이터 시딩 완료.
_____ ERROR at setup of TestAdminRouter.test_update_price_failure_as_admin _____

real_db = <sqlalchemy.orm.session.Session object at 0x7facdd3a5690>

    @pytest.fixture
    def admin_user_and_headers(real_db: Session):
        """
        테스트용 관리자 사용자와 인증 헤더를 생성하는 Fixture.
    
        - **목적**: 관리자 권한이 필요한 API를 테스트하기 위해 사전에 관리자 계정과 JWT 토큰을 생성합니다.
        - **반환**: 생성된 User 모델 객체와 HTTP 요청에 사용될 인증 헤더(딕셔너리)를 튜플로 반환합니다.
        """
>       admin_user = create_test_user(real_db, role="admin")

tests/integration/test_api_admin_integration.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/helpers.py:14: in create_test_user
    user = User(
<string>:4: in __init__
    ???
/usr/local/lib/python3.10/site-packages/sqlalchemy/orm/state.py:571: in _initialize_instance
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/orm/state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.common.models.user.User object at 0x7facdd3a5b40>
kwargs = {'email': 'test_acacd4cd11234dd89b3289adc4a7e953@example.com', 'is_active': True, 'password_hash': '$2b$12$sDNQ9wE53RlBadrCRSIHwuI2OOuIFibZCp/Kclxnj3NeDCen7lpJ2', 'role': 'admin', ...}
cls_ = <class 'src.common.models.user.User'>, k = 'password_hash'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'password_hash' is an invalid keyword argument for User

/usr/local/lib/python3.10/site-packages/sqlalchemy/orm/decl_base.py:2179: TypeError
---------------------------- Captured stdout setup -----------------------------
2025-08-31 17:47:30,287 - asyncio - DEBUG - Using selector: EpollSelector
2025-08-31 17:47:30,299 - src.api.main - INFO - 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
2025-08-31 17:47:30,476 - src.api.main - INFO - 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 17:47:30,483 - src.api.main - INFO - 테스트 StockMaster 데이터 시딩 완료.
2025-08-31 17:47:30,483 - src.api.main - INFO - 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 17:47:30,496 - src.api.main - INFO - 테스트 DailyPrice 데이터 시딩 완료.
------------------------------ Captured log setup ------------------------------
DEBUG    asyncio:selector_events.py:54 Using selector: EpollSelector
INFO     src.api.main:main.py:58 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
INFO     src.api.main:main.py:62 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:77 테스트 StockMaster 데이터 시딩 완료.
INFO     src.api.main:main.py:80 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:106 테스트 DailyPrice 데이터 시딩 완료.
______ ERROR at setup of TestAdminRouter.test_update_price_as_normal_user ______

real_db = <sqlalchemy.orm.session.Session object at 0x7facdd4cd300>

    @pytest.fixture
    def normal_user_and_headers(real_db: Session):
        """
        테스트용 일반 사용자와 인증 헤더를 생성하는 Fixture.
    
        - **목적**: 일반 사용자 권한으로 API 접근 시의 동작을 테스트하기 위해 사용자 계정과 토큰을 생성합니다.
        - **반환**: 생성된 User 모델 객체와 HTTP 요청에 사용될 인증 헤더(딕셔너리)를 튜플로 반환합니다.
        """
>       normal_user = create_test_user(real_db, role="user")

tests/integration/test_api_admin_integration.py:52: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/helpers.py:14: in create_test_user
    user = User(
<string>:4: in __init__
    ???
/usr/local/lib/python3.10/site-packages/sqlalchemy/orm/state.py:571: in _initialize_instance
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/orm/state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.common.models.user.User object at 0x7facdddb3850>
kwargs = {'email': 'test_e5cc5a94a37f491abae8bcf195dbdb48@example.com', 'is_active': True, 'password_hash': '$2b$12$jtpmXpYay/jdp8hpDTke6.lCC7BDLRbMZ3slLcUsAYKKjHVVMszS6', 'role': 'user', ...}
cls_ = <class 'src.common.models.user.User'>, k = 'password_hash'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'password_hash' is an invalid keyword argument for User

/usr/local/lib/python3.10/site-packages/sqlalchemy/orm/decl_base.py:2179: TypeError
---------------------------- Captured stdout setup -----------------------------
2025-08-31 17:47:31,201 - asyncio - DEBUG - Using selector: EpollSelector
2025-08-31 17:47:31,214 - src.api.main - INFO - 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
2025-08-31 17:47:31,486 - src.api.main - INFO - 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 17:47:31,728 - src.api.main - INFO - 테스트 StockMaster 데이터 시딩 완료.
2025-08-31 17:47:31,729 - src.api.main - INFO - 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 17:47:31,755 - src.api.main - INFO - 테스트 DailyPrice 데이터 시딩 완료.
------------------------------ Captured log setup ------------------------------
DEBUG    asyncio:selector_events.py:54 Using selector: EpollSelector
INFO     src.api.main:main.py:58 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
INFO     src.api.main:main.py:62 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:77 테스트 StockMaster 데이터 시딩 완료.
INFO     src.api.main:main.py:80 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:106 테스트 DailyPrice 데이터 시딩 완료.
_ ERROR at setup of TestAdminRouter.test_update_disclosure_all_success_as_admin _

real_db = <sqlalchemy.orm.session.Session object at 0x7facdd3a3d00>

    @pytest.fixture
    def admin_user_and_headers(real_db: Session):
        """
        테스트용 관리자 사용자와 인증 헤더를 생성하는 Fixture.
    
        - **목적**: 관리자 권한이 필요한 API를 테스트하기 위해 사전에 관리자 계정과 JWT 토큰을 생성합니다.
        - **반환**: 생성된 User 모델 객체와 HTTP 요청에 사용될 인증 헤더(딕셔너리)를 튜플로 반환합니다.
        """
>       admin_user = create_test_user(real_db, role="admin")

tests/integration/test_api_admin_integration.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/helpers.py:14: in create_test_user
    user = User(
<string>:4: in __init__
    ???
/usr/local/lib/python3.10/site-packages/sqlalchemy/orm/state.py:571: in _initialize_instance
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/orm/state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.common.models.user.User object at 0x7facdd3a1ea0>
kwargs = {'email': 'test_a98016dc6f61445b982a9e71048c3135@example.com', 'is_active': True, 'password_hash': '$2b$12$RyhQT1u8McP1nxHJKV3xsOdvxLWb8gliF68HsRrn.Uml3DznOdPsm', 'role': 'admin', ...}
cls_ = <class 'src.common.models.user.User'>, k = 'password_hash'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'password_hash' is an invalid keyword argument for User

/usr/local/lib/python3.10/site-packages/sqlalchemy/orm/decl_base.py:2179: TypeError
---------------------------- Captured stdout setup -----------------------------
2025-08-31 17:47:32,946 - asyncio - DEBUG - Using selector: EpollSelector
2025-08-31 17:47:32,959 - src.api.main - INFO - 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
2025-08-31 17:47:33,193 - src.api.main - INFO - 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 17:47:33,200 - src.api.main - INFO - 테스트 StockMaster 데이터 시딩 완료.
2025-08-31 17:47:33,200 - src.api.main - INFO - 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 17:47:33,214 - src.api.main - INFO - 테스트 DailyPrice 데이터 시딩 완료.
------------------------------ Captured log setup ------------------------------
DEBUG    asyncio:selector_events.py:54 Using selector: EpollSelector
INFO     src.api.main:main.py:58 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
INFO     src.api.main:main.py:62 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:77 테스트 StockMaster 데이터 시딩 완료.
INFO     src.api.main:main.py:80 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:106 테스트 DailyPrice 데이터 시딩 완료.
_ ERROR at setup of TestAdminRouter.test_update_disclosure_single_by_symbol_success_as_admin _

real_db = <sqlalchemy.orm.session.Session object at 0x7facdd390d00>

    @pytest.fixture
    def admin_user_and_headers(real_db: Session):
        """
        테스트용 관리자 사용자와 인증 헤더를 생성하는 Fixture.
    
        - **목적**: 관리자 권한이 필요한 API를 테스트하기 위해 사전에 관리자 계정과 JWT 토큰을 생성합니다.
        - **반환**: 생성된 User 모델 객체와 HTTP 요청에 사용될 인증 헤더(딕셔너리)를 튜플로 반환합니다.
        """
>       admin_user = create_test_user(real_db, role="admin")

tests/integration/test_api_admin_integration.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/helpers.py:14: in create_test_user
    user = User(
<string>:4: in __init__
    ???
/usr/local/lib/python3.10/site-packages/sqlalchemy/orm/state.py:571: in _initialize_instance
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/orm/state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.common.models.user.User object at 0x7facdd393610>
kwargs = {'email': 'test_a8ea50206b5246109b28a2297a157445@example.com', 'is_active': True, 'password_hash': '$2b$12$FTNDMu/K9EfbNHlxaEGmLeLp2Av8IRAZHwFJb5NBC0.MgcdyDSIy.', 'role': 'admin', ...}
cls_ = <class 'src.common.models.user.User'>, k = 'password_hash'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'password_hash' is an invalid keyword argument for User

/usr/local/lib/python3.10/site-packages/sqlalchemy/orm/decl_base.py:2179: TypeError
---------------------------- Captured stdout setup -----------------------------
2025-08-31 17:47:33,979 - asyncio - DEBUG - Using selector: EpollSelector
2025-08-31 17:47:34,002 - src.api.main - INFO - 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
2025-08-31 17:47:34,256 - src.api.main - INFO - 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 17:47:34,277 - src.api.main - INFO - 테스트 StockMaster 데이터 시딩 완료.
2025-08-31 17:47:34,278 - src.api.main - INFO - 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 17:47:34,306 - src.api.main - INFO - 테스트 DailyPrice 데이터 시딩 완료.
------------------------------ Captured log setup ------------------------------
DEBUG    asyncio:selector_events.py:54 Using selector: EpollSelector
INFO     src.api.main:main.py:58 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
INFO     src.api.main:main.py:62 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:77 테스트 StockMaster 데이터 시딩 완료.
INFO     src.api.main:main.py:80 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:106 테스트 DailyPrice 데이터 시딩 완료.
_ ERROR at setup of TestAdminRouter.test_update_disclosure_not_found_as_admin __

real_db = <sqlalchemy.orm.session.Session object at 0x7facdd393940>

    @pytest.fixture
    def admin_user_and_headers(real_db: Session):
        """
        테스트용 관리자 사용자와 인증 헤더를 생성하는 Fixture.
    
        - **목적**: 관리자 권한이 필요한 API를 테스트하기 위해 사전에 관리자 계정과 JWT 토큰을 생성합니다.
        - **반환**: 생성된 User 모델 객체와 HTTP 요청에 사용될 인증 헤더(딕셔너리)를 튜플로 반환합니다.
        """
>       admin_user = create_test_user(real_db, role="admin")

tests/integration/test_api_admin_integration.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/helpers.py:14: in create_test_user
    user = User(
<string>:4: in __init__
    ???
/usr/local/lib/python3.10/site-packages/sqlalchemy/orm/state.py:571: in _initialize_instance
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/orm/state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.common.models.user.User object at 0x7facdd391cc0>
kwargs = {'email': 'test_08d8241222a8423caaf87f34dafb4717@example.com', 'is_active': True, 'password_hash': '$2b$12$oj4a.pOM9GWIEw7oDenOM.e8aVtiV9lGv5MTsoUtcNyszVwphAgDi', 'role': 'admin', ...}
cls_ = <class 'src.common.models.user.User'>, k = 'password_hash'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'password_hash' is an invalid keyword argument for User

/usr/local/lib/python3.10/site-packages/sqlalchemy/orm/decl_base.py:2179: TypeError
---------------------------- Captured stdout setup -----------------------------
2025-08-31 17:47:35,474 - asyncio - DEBUG - Using selector: EpollSelector
2025-08-31 17:47:35,488 - src.api.main - INFO - 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
2025-08-31 17:47:35,708 - src.api.main - INFO - 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 17:47:35,717 - src.api.main - INFO - 테스트 StockMaster 데이터 시딩 완료.
2025-08-31 17:47:35,717 - src.api.main - INFO - 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 17:47:35,731 - src.api.main - INFO - 테스트 DailyPrice 데이터 시딩 완료.
------------------------------ Captured log setup ------------------------------
DEBUG    asyncio:selector_events.py:54 Using selector: EpollSelector
INFO     src.api.main:main.py:58 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
INFO     src.api.main:main.py:62 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:77 테스트 StockMaster 데이터 시딩 완료.
INFO     src.api.main:main.py:80 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:106 테스트 DailyPrice 데이터 시딩 완료.
___ ERROR at setup of TestAdminRouter.test_update_disclosure_as_normal_user ____

real_db = <sqlalchemy.orm.session.Session object at 0x7facdddf88b0>

    @pytest.fixture
    def normal_user_and_headers(real_db: Session):
        """
        테스트용 일반 사용자와 인증 헤더를 생성하는 Fixture.
    
        - **목적**: 일반 사용자 권한으로 API 접근 시의 동작을 테스트하기 위해 사용자 계정과 토큰을 생성합니다.
        - **반환**: 생성된 User 모델 객체와 HTTP 요청에 사용될 인증 헤더(딕셔너리)를 튜플로 반환합니다.
        """
>       normal_user = create_test_user(real_db, role="user")

tests/integration/test_api_admin_integration.py:52: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/helpers.py:14: in create_test_user
    user = User(
<string>:4: in __init__
    ???
/usr/local/lib/python3.10/site-packages/sqlalchemy/orm/state.py:571: in _initialize_instance
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/orm/state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.common.models.user.User object at 0x7facdd393dc0>
kwargs = {'email': 'test_2602ed2de0864929bebd25fb631be3bb@example.com', 'is_active': True, 'password_hash': '$2b$12$ThDdR.lWtIsuJC2WOAawAOS4.z3JLoPNZDdKqgFcadf6j9L99VwUS', 'role': 'user', ...}
cls_ = <class 'src.common.models.user.User'>, k = 'password_hash'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'password_hash' is an invalid keyword argument for User

/usr/local/lib/python3.10/site-packages/sqlalchemy/orm/decl_base.py:2179: TypeError
---------------------------- Captured stdout setup -----------------------------
2025-08-31 17:47:36,581 - asyncio - DEBUG - Using selector: EpollSelector
2025-08-31 17:47:36,593 - src.api.main - INFO - 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
2025-08-31 17:47:36,887 - src.api.main - INFO - 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 17:47:36,895 - src.api.main - INFO - 테스트 StockMaster 데이터 시딩 완료.
2025-08-31 17:47:36,896 - src.api.main - INFO - 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 17:47:36,909 - src.api.main - INFO - 테스트 DailyPrice 데이터 시딩 완료.
------------------------------ Captured log setup ------------------------------
DEBUG    asyncio:selector_events.py:54 Using selector: EpollSelector
INFO     src.api.main:main.py:58 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
INFO     src.api.main:main.py:62 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:77 테스트 StockMaster 데이터 시딩 완료.
INFO     src.api.main:main.py:80 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:106 테스트 DailyPrice 데이터 시딩 완료.
__ ERROR at setup of TestAdminRouter.test_get_schedule_status_as_normal_user ___

real_db = <sqlalchemy.orm.session.Session object at 0x7facdd391540>

    @pytest.fixture
    def normal_user_and_headers(real_db: Session):
        """
        테스트용 일반 사용자와 인증 헤더를 생성하는 Fixture.
    
        - **목적**: 일반 사용자 권한으로 API 접근 시의 동작을 테스트하기 위해 사용자 계정과 토큰을 생성합니다.
        - **반환**: 생성된 User 모델 객체와 HTTP 요청에 사용될 인증 헤더(딕셔너리)를 튜플로 반환합니다.
        """
>       normal_user = create_test_user(real_db, role="user")

tests/integration/test_api_admin_integration.py:52: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/helpers.py:14: in create_test_user
    user = User(
<string>:4: in __init__
    ???
/usr/local/lib/python3.10/site-packages/sqlalchemy/orm/state.py:571: in _initialize_instance
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/orm/state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.common.models.user.User object at 0x7facdd393bb0>
kwargs = {'email': 'test_2c5ef565e61e4b1da8a1b46293a6b756@example.com', 'is_active': True, 'password_hash': '$2b$12$CpWBt/adLN2GYwH0OrrphuSMAW04iHDGpEJRbpEqMtzOvjRac0N8y', 'role': 'user', ...}
cls_ = <class 'src.common.models.user.User'>, k = 'password_hash'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'password_hash' is an invalid keyword argument for User

/usr/local/lib/python3.10/site-packages/sqlalchemy/orm/decl_base.py:2179: TypeError
---------------------------- Captured stdout setup -----------------------------
2025-08-31 17:47:38,326 - asyncio - DEBUG - Using selector: EpollSelector
2025-08-31 17:47:38,337 - src.api.main - INFO - 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
2025-08-31 17:47:38,547 - src.api.main - INFO - 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 17:47:38,556 - src.api.main - INFO - 테스트 StockMaster 데이터 시딩 완료.
2025-08-31 17:47:38,556 - src.api.main - INFO - 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 17:47:38,569 - src.api.main - INFO - 테스트 DailyPrice 데이터 시딩 완료.
------------------------------ Captured log setup ------------------------------
DEBUG    asyncio:selector_events.py:54 Using selector: EpollSelector
INFO     src.api.main:main.py:58 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
INFO     src.api.main:main.py:62 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:77 테스트 StockMaster 데이터 시딩 완료.
INFO     src.api.main:main.py:80 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:106 테스트 DailyPrice 데이터 시딩 완료.
______ ERROR at setup of TestAdminRouter.test_trigger_job_as_normal_user _______

real_db = <sqlalchemy.orm.session.Session object at 0x7facdd424b80>

    @pytest.fixture
    def normal_user_and_headers(real_db: Session):
        """
        테스트용 일반 사용자와 인증 헤더를 생성하는 Fixture.
    
        - **목적**: 일반 사용자 권한으로 API 접근 시의 동작을 테스트하기 위해 사용자 계정과 토큰을 생성합니다.
        - **반환**: 생성된 User 모델 객체와 HTTP 요청에 사용될 인증 헤더(딕셔너리)를 튜플로 반환합니다.
        """
>       normal_user = create_test_user(real_db, role="user")

tests/integration/test_api_admin_integration.py:52: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/helpers.py:14: in create_test_user
    user = User(
<string>:4: in __init__
    ???
/usr/local/lib/python3.10/site-packages/sqlalchemy/orm/state.py:571: in _initialize_instance
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/orm/state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.common.models.user.User object at 0x7facdd425270>
kwargs = {'email': 'test_58d9cd3ee3454212a0628b8a01cf0848@example.com', 'is_active': True, 'password_hash': '$2b$12$Qxmlf/jO9Y67YjYBHpFUIurPDU7ZcxvkXJSRBVbPe3hdSWgH6ENiC', 'role': 'user', ...}
cls_ = <class 'src.common.models.user.User'>, k = 'password_hash'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'password_hash' is an invalid keyword argument for User

/usr/local/lib/python3.10/site-packages/sqlalchemy/orm/decl_base.py:2179: TypeError
---------------------------- Captured stdout setup -----------------------------
2025-08-31 17:47:39,929 - asyncio - DEBUG - Using selector: EpollSelector
2025-08-31 17:47:39,952 - src.api.main - INFO - 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
2025-08-31 17:47:40,207 - src.api.main - INFO - 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 17:47:40,215 - src.api.main - INFO - 테스트 StockMaster 데이터 시딩 완료.
2025-08-31 17:47:40,215 - src.api.main - INFO - 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 17:47:40,230 - src.api.main - INFO - 테스트 DailyPrice 데이터 시딩 완료.
------------------------------ Captured log setup ------------------------------
DEBUG    asyncio:selector_events.py:54 Using selector: EpollSelector
INFO     src.api.main:main.py:58 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
INFO     src.api.main:main.py:62 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:77 테스트 StockMaster 데이터 시딩 완료.
INFO     src.api.main:main.py:80 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:106 테스트 DailyPrice 데이터 시딩 완료.
_ ERROR at setup of TestAdminRouter.test_trigger_check_disclosures_success_as_admin _

real_db = <sqlalchemy.orm.session.Session object at 0x7facdd39b850>

    @pytest.fixture
    def admin_user_and_headers(real_db: Session):
        """
        테스트용 관리자 사용자와 인증 헤더를 생성하는 Fixture.
    
        - **목적**: 관리자 권한이 필요한 API를 테스트하기 위해 사전에 관리자 계정과 JWT 토큰을 생성합니다.
        - **반환**: 생성된 User 모델 객체와 HTTP 요청에 사용될 인증 헤더(딕셔너리)를 튜플로 반환합니다.
        """
>       admin_user = create_test_user(real_db, role="admin")

tests/integration/test_api_admin_integration.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/helpers.py:14: in create_test_user
    user = User(
<string>:4: in __init__
    ???
/usr/local/lib/python3.10/site-packages/sqlalchemy/orm/state.py:571: in _initialize_instance
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/orm/state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.common.models.user.User object at 0x7facdd39a9b0>
kwargs = {'email': 'test_8024e07a969f4d46bf1a8deffa80c462@example.com', 'is_active': True, 'password_hash': '$2b$12$Op6h64wuHBBpCKdoPCcFbeYZlMX/Yq9TLT/gJoWyhZiAHFN9.uPYe', 'role': 'admin', ...}
cls_ = <class 'src.common.models.user.User'>, k = 'password_hash'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'password_hash' is an invalid keyword argument for User

/usr/local/lib/python3.10/site-packages/sqlalchemy/orm/decl_base.py:2179: TypeError
---------------------------- Captured stdout setup -----------------------------
2025-08-31 17:47:41,550 - asyncio - DEBUG - Using selector: EpollSelector
2025-08-31 17:47:41,570 - src.api.main - INFO - 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
2025-08-31 17:47:41,760 - src.api.main - INFO - 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 17:47:41,767 - src.api.main - INFO - 테스트 StockMaster 데이터 시딩 완료.
2025-08-31 17:47:41,768 - src.api.main - INFO - 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 17:47:41,779 - src.api.main - INFO - 테스트 DailyPrice 데이터 시딩 완료.
------------------------------ Captured log setup ------------------------------
DEBUG    asyncio:selector_events.py:54 Using selector: EpollSelector
INFO     src.api.main:main.py:58 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
INFO     src.api.main:main.py:62 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:77 테스트 StockMaster 데이터 시딩 완료.
INFO     src.api.main:main.py:80 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:106 테스트 DailyPrice 데이터 시딩 완료.
_ ERROR at setup of TestAdminRouter.test_trigger_check_disclosures_failure_as_admin _

real_db = <sqlalchemy.orm.session.Session object at 0x7facdde3c250>

    @pytest.fixture
    def admin_user_and_headers(real_db: Session):
        """
        테스트용 관리자 사용자와 인증 헤더를 생성하는 Fixture.
    
        - **목적**: 관리자 권한이 필요한 API를 테스트하기 위해 사전에 관리자 계정과 JWT 토큰을 생성합니다.
        - **반환**: 생성된 User 모델 객체와 HTTP 요청에 사용될 인증 헤더(딕셔너리)를 튜플로 반환합니다.
        """
>       admin_user = create_test_user(real_db, role="admin")

tests/integration/test_api_admin_integration.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/helpers.py:14: in create_test_user
    user = User(
<string>:4: in __init__
    ???
/usr/local/lib/python3.10/site-packages/sqlalchemy/orm/state.py:571: in _initialize_instance
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/orm/state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.common.models.user.User object at 0x7facdde3cbe0>
kwargs = {'email': 'test_1afdc2752a614586a9f944ccd4d10362@example.com', 'is_active': True, 'password_hash': '$2b$12$zogfUgOef/eVwhZqZ/vGCONOXAtPP3RyoCVklHPJjp.yiBR2UZmk6', 'role': 'admin', ...}
cls_ = <class 'src.common.models.user.User'>, k = 'password_hash'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'password_hash' is an invalid keyword argument for User

/usr/local/lib/python3.10/site-packages/sqlalchemy/orm/decl_base.py:2179: TypeError
---------------------------- Captured stdout setup -----------------------------
2025-08-31 17:47:42,802 - asyncio - DEBUG - Using selector: EpollSelector
2025-08-31 17:47:42,834 - src.api.main - INFO - 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
2025-08-31 17:47:43,065 - src.api.main - INFO - 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 17:47:43,074 - src.api.main - INFO - 테스트 StockMaster 데이터 시딩 완료.
2025-08-31 17:47:43,074 - src.api.main - INFO - 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 17:47:43,085 - src.api.main - INFO - 테스트 DailyPrice 데이터 시딩 완료.
------------------------------ Captured log setup ------------------------------
DEBUG    asyncio:selector_events.py:54 Using selector: EpollSelector
INFO     src.api.main:main.py:58 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
INFO     src.api.main:main.py:62 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:77 테스트 StockMaster 데이터 시딩 완료.
INFO     src.api.main:main.py:80 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:106 테스트 DailyPrice 데이터 시딩 완료.
_ ERROR at setup of TestAdminRouter.test_trigger_check_disclosures_as_normal_user _

real_db = <sqlalchemy.orm.session.Session object at 0x7facdd426290>

    @pytest.fixture
    def normal_user_and_headers(real_db: Session):
        """
        테스트용 일반 사용자와 인증 헤더를 생성하는 Fixture.
    
        - **목적**: 일반 사용자 권한으로 API 접근 시의 동작을 테스트하기 위해 사용자 계정과 토큰을 생성합니다.
        - **반환**: 생성된 User 모델 객체와 HTTP 요청에 사용될 인증 헤더(딕셔너리)를 튜플로 반환합니다.
        """
>       normal_user = create_test_user(real_db, role="user")

tests/integration/test_api_admin_integration.py:52: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/helpers.py:14: in create_test_user
    user = User(
<string>:4: in __init__
    ???
/usr/local/lib/python3.10/site-packages/sqlalchemy/orm/state.py:571: in _initialize_instance
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/orm/state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.common.models.user.User object at 0x7facdd4269e0>
kwargs = {'email': 'test_52146e7d2bc84d34b9c8dcae728d4717@example.com', 'is_active': True, 'password_hash': '$2b$12$OK89PWI3s4wgL1j7Oa4Ef.jIbHkk8l2O7pYCHDnETIobQ47UWgBiG', 'role': 'user', ...}
cls_ = <class 'src.common.models.user.User'>, k = 'password_hash'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'password_hash' is an invalid keyword argument for User

/usr/local/lib/python3.10/site-packages/sqlalchemy/orm/decl_base.py:2179: TypeError
---------------------------- Captured stdout setup -----------------------------
2025-08-31 17:47:43,815 - asyncio - DEBUG - Using selector: EpollSelector
2025-08-31 17:47:43,829 - src.api.main - INFO - 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
2025-08-31 17:47:44,040 - src.api.main - INFO - 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 17:47:44,049 - src.api.main - INFO - 테스트 StockMaster 데이터 시딩 완료.
2025-08-31 17:47:44,050 - src.api.main - INFO - 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 17:47:44,065 - src.api.main - INFO - 테스트 DailyPrice 데이터 시딩 완료.
------------------------------ Captured log setup ------------------------------
DEBUG    asyncio:selector_events.py:54 Using selector: EpollSelector
INFO     src.api.main:main.py:58 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
INFO     src.api.main:main.py:62 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:77 테스트 StockMaster 데이터 시딩 완료.
INFO     src.api.main:main.py:80 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:106 테스트 DailyPrice 데이터 시딩 완료.
=================================== FAILURES ===================================
_______________ TestAdminRouter.test_admin_stats_unauthenticated _______________

self = <test_api_admin_integration.TestAdminRouter object at 0x7facddd6c430>
client = <starlette.testclient.TestClient object at 0x7facdd444c70>

    def test_admin_stats_unauthenticated(self, client: TestClient):
        """
        - **테스트 대상**: `GET /admin/admin_stats`
        - **목적**: 인증되지 않은 사용자가 관리자 API 접근 시 401 에러를 받는지 확인합니다.
        - **시나리오**:
            - 인증 헤더 없이 통계 API를 호출합니다.
        - **Mock 대상**: 없음 (실제 인증 처리 로직 검증)
        """
        response = client.get("/admin/admin_stats")
>       assert response.status_code == 401
E       assert 404 == 401
E        +  where 404 = <Response [404 Not Found]>.status_code

tests/integration/test_api_admin_integration.py:106: AssertionError
---------------------------- Captured stdout setup -----------------------------
2025-08-31 17:47:25,755 - asyncio - DEBUG - Using selector: EpollSelector
2025-08-31 17:47:25,766 - src.api.main - INFO - 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
2025-08-31 17:47:25,938 - src.api.main - INFO - 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 17:47:25,944 - src.api.main - INFO - 테스트 StockMaster 데이터 시딩 완료.
2025-08-31 17:47:25,945 - src.api.main - INFO - 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 17:47:25,955 - src.api.main - INFO - 테스트 DailyPrice 데이터 시딩 완료.
------------------------------ Captured log setup ------------------------------
DEBUG    asyncio:selector_events.py:54 Using selector: EpollSelector
INFO     src.api.main:main.py:58 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
INFO     src.api.main:main.py:62 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:77 테스트 StockMaster 데이터 시딩 완료.
INFO     src.api.main:main.py:80 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:106 테스트 DailyPrice 데이터 시딩 완료.
----------------------------- Captured stdout call -----------------------------
2025-08-31 17:47:25,961 - httpx - INFO - HTTP Request: GET http://testserver/admin/admin_stats "HTTP/1.1 404 Not Found"
------------------------------ Captured log call -------------------------------
INFO     httpx:_client.py:1025 HTTP Request: GET http://testserver/admin/admin_stats "HTTP/1.1 404 Not Found"
______________ TestAdminRouter.test_update_master_unauthenticated ______________

self = <test_api_admin_integration.TestAdminRouter object at 0x7facddd6c520>
client = <starlette.testclient.TestClient object at 0x7facdddb26e0>

    def test_update_master_unauthenticated(self, client: TestClient):
        """
        - **테스트 대상**: `POST /admin/update_master`
        - **목적**: 미인증 사용자가 종목 마스터 갱신 시도 시 401 에러를 받는지 확인합니다.
        - **시나리오**:
            - 인증 헤더 없이 API를 호출합니다.
        - **Mock 대상**: 없음
        """
        response = client.post("/admin/update_master")
>       assert response.status_code == 401
E       assert 404 == 401
E        +  where 404 = <Response [404 Not Found]>.status_code

tests/integration/test_api_admin_integration.py:181: AssertionError
---------------------------- Captured stdout setup -----------------------------
2025-08-31 17:47:29,003 - asyncio - DEBUG - Using selector: EpollSelector
2025-08-31 17:47:29,013 - src.api.main - INFO - 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
2025-08-31 17:47:29,186 - src.api.main - INFO - 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 17:47:29,195 - src.api.main - INFO - 테스트 StockMaster 데이터 시딩 완료.
2025-08-31 17:47:29,195 - src.api.main - INFO - 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 17:47:29,207 - src.api.main - INFO - 테스트 DailyPrice 데이터 시딩 완료.
------------------------------ Captured log setup ------------------------------
DEBUG    asyncio:selector_events.py:54 Using selector: EpollSelector
INFO     src.api.main:main.py:58 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
INFO     src.api.main:main.py:62 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:77 테스트 StockMaster 데이터 시딩 완료.
INFO     src.api.main:main.py:80 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:106 테스트 DailyPrice 데이터 시딩 완료.
----------------------------- Captured stdout call -----------------------------
2025-08-31 17:47:29,212 - httpx - INFO - HTTP Request: POST http://testserver/admin/update_master "HTTP/1.1 404 Not Found"
------------------------------ Captured log call -------------------------------
INFO     httpx:_client.py:1025 HTTP Request: POST http://testserver/admin/update_master "HTTP/1.1 404 Not Found"
______________ TestAdminRouter.test_update_price_unauthenticated _______________

self = <test_api_admin_integration.TestAdminRouter object at 0x7facddd6d300>
client = <starlette.testclient.TestClient object at 0x7facdde3c220>

    def test_update_price_unauthenticated(self, client: TestClient):
        """
        - **테스트 대상**: `POST /admin/update_price`
        - **목적**: 미인증 사용자가 일별 시세 갱신 시도 시 401 에러를 받는지 확인합니다.
        - **시나리오**:
            - 인증 헤더 없이 API를 호출합니다.
        - **Mock 대상**: 없음
        """
        response = client.post("/admin/update_price")
>       assert response.status_code == 401
E       assert 404 == 401
E        +  where 404 = <Response [404 Not Found]>.status_code

tests/integration/test_api_admin_integration.py:254: AssertionError
---------------------------- Captured stdout setup -----------------------------
2025-08-31 17:47:32,474 - asyncio - DEBUG - Using selector: EpollSelector
2025-08-31 17:47:32,487 - src.api.main - INFO - 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
2025-08-31 17:47:32,687 - src.api.main - INFO - 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 17:47:32,702 - src.api.main - INFO - 테스트 StockMaster 데이터 시딩 완료.
2025-08-31 17:47:32,702 - src.api.main - INFO - 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 17:47:32,715 - src.api.main - INFO - 테스트 DailyPrice 데이터 시딩 완료.
------------------------------ Captured log setup ------------------------------
DEBUG    asyncio:selector_events.py:54 Using selector: EpollSelector
INFO     src.api.main:main.py:58 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
INFO     src.api.main:main.py:62 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:77 테스트 StockMaster 데이터 시딩 완료.
INFO     src.api.main:main.py:80 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:106 테스트 DailyPrice 데이터 시딩 완료.
----------------------------- Captured stdout call -----------------------------
2025-08-31 17:47:32,720 - httpx - INFO - HTTP Request: POST http://testserver/admin/update_price "HTTP/1.1 404 Not Found"
------------------------------ Captured log call -------------------------------
INFO     httpx:_client.py:1025 HTTP Request: POST http://testserver/admin/update_price "HTTP/1.1 404 Not Found"
____________ TestAdminRouter.test_update_disclosure_unauthenticated ____________

self = <test_api_admin_integration.TestAdminRouter object at 0x7facddd6de10>
client = <starlette.testclient.TestClient object at 0x7facdd390700>

    def test_update_disclosure_unauthenticated(self, client: TestClient):
        """
        - **테스트 대상**: `POST /admin/update_disclosure`
        - **목적**: 미인증 사용자가 공시 갱신 시도 시 401 에러를 받는지 확인합니다.
        - **시나리오**:
            - 인증 헤더 없이 API를 호출합니다.
        - **Mock 대상**: 없음
        """
        response = client.post("/admin/update_disclosure")
>       assert response.status_code == 401
E       assert 404 == 401
E        +  where 404 = <Response [404 Not Found]>.status_code

tests/integration/test_api_admin_integration.py:363: AssertionError
---------------------------- Captured stdout setup -----------------------------
2025-08-31 17:47:37,862 - asyncio - DEBUG - Using selector: EpollSelector
2025-08-31 17:47:37,876 - src.api.main - INFO - 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
2025-08-31 17:47:38,069 - src.api.main - INFO - 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 17:47:38,076 - src.api.main - INFO - 테스트 StockMaster 데이터 시딩 완료.
2025-08-31 17:47:38,077 - src.api.main - INFO - 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 17:47:38,087 - src.api.main - INFO - 테스트 DailyPrice 데이터 시딩 완료.
------------------------------ Captured log setup ------------------------------
DEBUG    asyncio:selector_events.py:54 Using selector: EpollSelector
INFO     src.api.main:main.py:58 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
INFO     src.api.main:main.py:62 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:77 테스트 StockMaster 데이터 시딩 완료.
INFO     src.api.main:main.py:80 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:106 테스트 DailyPrice 데이터 시딩 완료.
----------------------------- Captured stdout call -----------------------------
2025-08-31 17:47:38,091 - httpx - INFO - HTTP Request: POST http://testserver/admin/update_disclosure "HTTP/1.1 404 Not Found"
------------------------------ Captured log call -------------------------------
INFO     httpx:_client.py:1025 HTTP Request: POST http://testserver/admin/update_disclosure "HTTP/1.1 404 Not Found"
___________ TestAdminRouter.test_get_schedule_status_unauthenticated ___________

self = <test_api_admin_integration.TestAdminRouter object at 0x7facddd6e260>
client = <starlette.testclient.TestClient object at 0x7facdd390790>

    def test_get_schedule_status_unauthenticated(self, client: TestClient):
        """
        - **테스트 대상**: `GET /admin/schedule/status`
        - **목적**: 미인증 사용자가 스케줄러 상태 조회 시 401 에러를 받는지 확인합니다.
        - **시나리오**:
            - 인증 헤더 없이 API를 호출합니다.
        - **Mock 대상**: 없음
        """
        response = client.get("/admin/schedule/status")
>       assert response.status_code == 401
E       assert 404 == 401
E        +  where 404 = <Response [404 Not Found]>.status_code

tests/integration/test_api_admin_integration.py:390: AssertionError
---------------------------- Captured stdout setup -----------------------------
2025-08-31 17:47:39,392 - asyncio - DEBUG - Using selector: EpollSelector
2025-08-31 17:47:39,403 - src.api.main - INFO - 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
2025-08-31 17:47:39,615 - src.api.main - INFO - 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 17:47:39,625 - src.api.main - INFO - 테스트 StockMaster 데이터 시딩 완료.
2025-08-31 17:47:39,626 - src.api.main - INFO - 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 17:47:39,639 - src.api.main - INFO - 테스트 DailyPrice 데이터 시딩 완료.
------------------------------ Captured log setup ------------------------------
DEBUG    asyncio:selector_events.py:54 Using selector: EpollSelector
INFO     src.api.main:main.py:58 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
INFO     src.api.main:main.py:62 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:77 테스트 StockMaster 데이터 시딩 완료.
INFO     src.api.main:main.py:80 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:106 테스트 DailyPrice 데이터 시딩 완료.
----------------------------- Captured stdout call -----------------------------
2025-08-31 17:47:39,644 - httpx - INFO - HTTP Request: GET http://testserver/admin/schedule/status "HTTP/1.1 404 Not Found"
------------------------------ Captured log call -------------------------------
INFO     httpx:_client.py:1025 HTTP Request: GET http://testserver/admin/schedule/status "HTTP/1.1 404 Not Found"
_______________ TestAdminRouter.test_trigger_job_unauthenticated _______________

self = <test_api_admin_integration.TestAdminRouter object at 0x7facddd6e6b0>
client = <starlette.testclient.TestClient object at 0x7facdddf9360>

    def test_trigger_job_unauthenticated(self, client: TestClient):
        """
        - **테스트 대상**: `POST /admin/schedule/trigger/{job_id}`
        - **목적**: 미인증 사용자가 스케줄러 잡 실행 시 401 에러를 받는지 확인합니다.
        - **시나리오**:
            - 인증 헤더 없이 API를 호출합니다.
        - **Mock 대상**: 없음
        """
        response = client.post("/admin/schedule/trigger/test_job")
>       assert response.status_code == 401
E       assert 404 == 401
E        +  where 404 = <Response [404 Not Found]>.status_code

tests/integration/test_api_admin_integration.py:413: AssertionError
---------------------------- Captured stdout setup -----------------------------
2025-08-31 17:47:41,067 - asyncio - DEBUG - Using selector: EpollSelector
2025-08-31 17:47:41,079 - src.api.main - INFO - 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
2025-08-31 17:47:41,254 - src.api.main - INFO - 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 17:47:41,262 - src.api.main - INFO - 테스트 StockMaster 데이터 시딩 완료.
2025-08-31 17:47:41,262 - src.api.main - INFO - 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 17:47:41,273 - src.api.main - INFO - 테스트 DailyPrice 데이터 시딩 완료.
------------------------------ Captured log setup ------------------------------
DEBUG    asyncio:selector_events.py:54 Using selector: EpollSelector
INFO     src.api.main:main.py:58 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
INFO     src.api.main:main.py:62 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:77 테스트 StockMaster 데이터 시딩 완료.
INFO     src.api.main:main.py:80 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:106 테스트 DailyPrice 데이터 시딩 완료.
----------------------------- Captured stdout call -----------------------------
2025-08-31 17:47:41,278 - httpx - INFO - HTTP Request: POST http://testserver/admin/schedule/trigger/test_job "HTTP/1.1 404 Not Found"
------------------------------ Captured log call -------------------------------
INFO     httpx:_client.py:1025 HTTP Request: POST http://testserver/admin/schedule/trigger/test_job "HTTP/1.1 404 Not Found"
________ TestAdminRouter.test_trigger_check_disclosures_unauthenticated ________

self = <test_api_admin_integration.TestAdminRouter object at 0x7facddd6e9e0>
client = <starlette.testclient.TestClient object at 0x7facdde3c1f0>

    def test_trigger_check_disclosures_unauthenticated(self, client: TestClient):
        """
        - **테스트 대상**: `POST /admin/trigger/check_disclosures`
        - **목적**: 미인증 사용자가 공시 확인 잡 실행 시 401 에러를 받는지 확인합니다.
        - **시나리오**:
            - 인증 헤더 없이 API를 호출합니다.
        - **Mock 대상**: 없음
        """
        response = client.post("/admin/trigger/check_disclosures")
>       assert response.status_code == 401
E       assert 404 == 401
E        +  where 404 = <Response [404 Not Found]>.status_code

tests/integration/test_api_admin_integration.py:485: AssertionError
---------------------------- Captured stdout setup -----------------------------
2025-08-31 17:47:44,907 - asyncio - DEBUG - Using selector: EpollSelector
2025-08-31 17:47:44,917 - src.api.main - INFO - 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
2025-08-31 17:47:45,199 - src.api.main - INFO - 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 17:47:45,209 - src.api.main - INFO - 테스트 StockMaster 데이터 시딩 완료.
2025-08-31 17:47:45,209 - src.api.main - INFO - 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 17:47:45,225 - src.api.main - INFO - 테스트 DailyPrice 데이터 시딩 완료.
------------------------------ Captured log setup ------------------------------
DEBUG    asyncio:selector_events.py:54 Using selector: EpollSelector
INFO     src.api.main:main.py:58 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
INFO     src.api.main:main.py:62 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:77 테스트 StockMaster 데이터 시딩 완료.
INFO     src.api.main:main.py:80 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:106 테스트 DailyPrice 데이터 시딩 완료.
----------------------------- Captured stdout call -----------------------------
2025-08-31 17:47:45,233 - httpx - INFO - HTTP Request: POST http://testserver/admin/trigger/check_disclosures "HTTP/1.1 404 Not Found"
------------------------------ Captured log call -------------------------------
INFO     httpx:_client.py:1025 HTTP Request: POST http://testserver/admin/trigger/check_disclosures "HTTP/1.1 404 Not Found"
=============================== warnings summary ===============================
../../../usr/local/lib/python3.10/site-packages/pydantic/_internal/_config.py:323
../../../usr/local/lib/python3.10/site-packages/pydantic/_internal/_config.py:323
../../../usr/local/lib/python3.10/site-packages/pydantic/_internal/_config.py:323
  /usr/local/lib/python3.10/site-packages/pydantic/_internal/_config.py:323: PydanticDeprecatedSince20: Support for class-based `config` is deprecated, use ConfigDict instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.11/migration/
    warnings.warn(DEPRECATION_MESSAGE, DeprecationWarning)

../../../usr/local/lib/python3.10/site-packages/pydantic/_internal/_config.py:373
  /usr/local/lib/python3.10/site-packages/pydantic/_internal/_config.py:373: UserWarning: Valid config keys have changed in V2:
  * 'orm_mode' has been renamed to 'from_attributes'
    warnings.warn(message, UserWarning)

main.py:112
  /app/src/api/main.py:112: DeprecationWarning: 
          on_event is deprecated, use lifespan event handlers instead.
  
          Read more about it in the
          [FastAPI docs for Lifespan Events](https://fastapi.tiangolo.com/advanced/events/).
          
    @app.on_event("startup")

../../../usr/local/lib/python3.10/site-packages/fastapi/applications.py:4495
  /usr/local/lib/python3.10/site-packages/fastapi/applications.py:4495: DeprecationWarning: 
          on_event is deprecated, use lifespan event handlers instead.
  
          Read more about it in the
          [FastAPI docs for Lifespan Events](https://fastapi.tiangolo.com/advanced/events/).
          
    return self.router.on_event(event_type)

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
=========================== short test summary info ============================
FAILED tests/integration/test_api_admin_integration.py::TestAdminRouter::test_admin_stats_unauthenticated
FAILED tests/integration/test_api_admin_integration.py::TestAdminRouter::test_update_master_unauthenticated
FAILED tests/integration/test_api_admin_integration.py::TestAdminRouter::test_update_price_unauthenticated
FAILED tests/integration/test_api_admin_integration.py::TestAdminRouter::test_update_disclosure_unauthenticated
FAILED tests/integration/test_api_admin_integration.py::TestAdminRouter::test_get_schedule_status_unauthenticated
FAILED tests/integration/test_api_admin_integration.py::TestAdminRouter::test_trigger_job_unauthenticated
FAILED tests/integration/test_api_admin_integration.py::TestAdminRouter::test_trigger_check_disclosures_unauthenticated
ERROR tests/integration/test_api_admin_integration.py::TestAdminRouter::test_admin_stats_as_admin
ERROR tests/integration/test_api_admin_integration.py::TestAdminRouter::test_admin_stats_as_normal_user
ERROR tests/integration/test_api_admin_integration.py::TestAdminRouter::test_update_master_success_as_admin
ERROR tests/integration/test_api_admin_integration.py::TestAdminRouter::test_update_master_failure_as_admin
ERROR tests/integration/test_api_admin_integration.py::TestAdminRouter::test_update_master_as_normal_user
ERROR tests/integration/test_api_admin_integration.py::TestAdminRouter::test_update_price_success_as_admin
ERROR tests/integration/test_api_admin_integration.py::TestAdminRouter::test_update_price_failure_as_admin
ERROR tests/integration/test_api_admin_integration.py::TestAdminRouter::test_update_price_as_normal_user
ERROR tests/integration/test_api_admin_integration.py::TestAdminRouter::test_update_disclosure_all_success_as_admin
ERROR tests/integration/test_api_admin_integration.py::TestAdminRouter::test_update_disclosure_single_by_symbol_success_as_admin
ERROR tests/integration/test_api_admin_integration.py::TestAdminRouter::test_update_disclosure_not_found_as_admin
ERROR tests/integration/test_api_admin_integration.py::TestAdminRouter::test_update_disclosure_as_normal_user
ERROR tests/integration/test_api_admin_integration.py::TestAdminRouter::test_get_schedule_status_as_normal_user
ERROR tests/integration/test_api_admin_integration.py::TestAdminRouter::test_trigger_job_as_normal_user
ERROR tests/integration/test_api_admin_integration.py::TestAdminRouter::test_trigger_check_disclosures_success_as_admin
ERROR tests/integration/test_api_admin_integration.py::TestAdminRouter::test_trigger_check_disclosures_failure_as_admin
ERROR tests/integration/test_api_admin_integration.py::TestAdminRouter::test_trigger_check_disclosures_as_normal_user
================== 7 failed, 6 warnings, 17 errors in 24.63s ===================
\n--- Running test_seed_data_integration.py ---
============================= test session starts ==============================
platform linux -- Python 3.10.18, pytest-8.4.1, pluggy-1.6.0
rootdir: /app/src/api
plugins: cov-6.2.1, timeout-2.4.0, anyio-4.10.0, asyncio-1.1.0
asyncio: mode=strict, asyncio_default_fixture_loop_scope=None, asyncio_default_test_loop_scope=function
collected 1 item

tests/integration/test_seed_data_integration.py F                        [100%]

=================================== FAILURES ===================================
________________________________ test_seed_data ________________________________

    def test_seed_data():
        """
        - **테스트 대상**: 테스트 데이터베이스
        - **목적**: 테스트에 필요한 기본 데이터를 DB에 생성합니다.
        - **시나리오**:
            1. 테스트 사용자 1명을 생성합니다.
            2. 삼성전자 종목 정보 1건을 생성합니다.
            3. 위 종목에 대한 40일 치의 가상 일별 가격 데이터를 생성합니다.
        - **Mock 대상**: 없음
        """
        print("Seeding database with test data...")
        db = SessionLocal()
        try:
            # 1. 사용자 생성
>           user = User(
                username="testuser_12345",
                password_hash="testpassword",  # 실제 앱에서는 해시된 비밀번호 사용
                email="testuser_12345@example.com",
                telegram_id=12345
            )

tests/integration/test_seed_data_integration.py:79: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
<string>:4: in __init__
    ???
/usr/local/lib/python3.10/site-packages/sqlalchemy/orm/state.py:571: in _initialize_instance
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/orm/state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.common.models.user.User object at 0x7f115f61f190>
kwargs = {'email': 'testuser_12345@example.com', 'password_hash': 'testpassword', 'telegram_id': 12345, 'username': 'testuser_12345'}
cls_ = <class 'src.common.models.user.User'>, k = 'password_hash'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'password_hash' is an invalid keyword argument for User

/usr/local/lib/python3.10/site-packages/sqlalchemy/orm/decl_base.py:2179: TypeError
---------------------------- Captured stdout setup -----------------------------

Cleaning up database for seeding...
Database cleaned up.
----------------------------- Captured stdout call -----------------------------
Seeding database with test data...
=============================== warnings summary ===============================
../../../usr/local/lib/python3.10/site-packages/pydantic/_internal/_config.py:323
../../../usr/local/lib/python3.10/site-packages/pydantic/_internal/_config.py:323
../../../usr/local/lib/python3.10/site-packages/pydantic/_internal/_config.py:323
  /usr/local/lib/python3.10/site-packages/pydantic/_internal/_config.py:323: PydanticDeprecatedSince20: Support for class-based `config` is deprecated, use ConfigDict instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.11/migration/
    warnings.warn(DEPRECATION_MESSAGE, DeprecationWarning)

../../../usr/local/lib/python3.10/site-packages/pydantic/_internal/_config.py:373
  /usr/local/lib/python3.10/site-packages/pydantic/_internal/_config.py:373: UserWarning: Valid config keys have changed in V2:
  * 'orm_mode' has been renamed to 'from_attributes'
    warnings.warn(message, UserWarning)

main.py:112
  /app/src/api/main.py:112: DeprecationWarning: 
          on_event is deprecated, use lifespan event handlers instead.
  
          Read more about it in the
          [FastAPI docs for Lifespan Events](https://fastapi.tiangolo.com/advanced/events/).
          
    @app.on_event("startup")

../../../usr/local/lib/python3.10/site-packages/fastapi/applications.py:4495
  /usr/local/lib/python3.10/site-packages/fastapi/applications.py:4495: DeprecationWarning: 
          on_event is deprecated, use lifespan event handlers instead.
  
          Read more about it in the
          [FastAPI docs for Lifespan Events](https://fastapi.tiangolo.com/advanced/events/).
          
    return self.router.on_event(event_type)

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
=========================== short test summary info ============================
FAILED tests/integration/test_seed_data_integration.py::test_seed_data - Type...
======================== 1 failed, 6 warnings in 0.71s =========================
\n--- Running test_notification_publish_integration.py ---
============================= test session starts ==============================
platform linux -- Python 3.10.18, pytest-8.4.1, pluggy-1.6.0
rootdir: /app/src/api
plugins: cov-6.2.1, timeout-2.4.0, anyio-4.10.0, asyncio-1.1.0
asyncio: mode=strict, asyncio_default_fixture_loop_scope=None, asyncio_default_test_loop_scope=function
collected 1 item

tests/integration/test_notification_publish_integration.py F             [100%]

=================================== FAILURES ===================================
_____________________ test_create_price_alert_successfully _____________________

client = <starlette.testclient.TestClient object at 0x7fb4cd5f9ab0>
real_db = <sqlalchemy.orm.session.Session object at 0x7fb4eba66a70>

    @pytest.mark.asyncio
    async def test_create_price_alert_successfully(client: TestClient, real_db):
        """
        - **테스트 대상**: `POST /api/v1/alerts` (JWT 토큰 인증)
        - **목적**: 가입-로그인-알림 생성으로 이어지는 일반 사용자의 핵심 흐름이 정상적으로 동작하는지 확인합니다.
        - **시나리오**:
            1. `TestClient`를 사용하여 테스트용 사용자를 가입시킵니다.
            2. 동일 사용자로 로그인하여 `access_token`을 발급받습니다.
            3. 발급받은 토큰을 인증 헤더에 담아 가격 알림 생성을 요청합니다.
            4. 200 OK 응답과 함께, 생성된 알림 정보가 올바르게 반환되는지 확인합니다.
        - **Mock 대상**: 없음
        """
        # --- 1. 사용자 가입 및 로그인 --- #
        # Given: 테스트용 사용자 정보
        register_data = {"username": "testuser_alert_create", "password": "testpassword", "email": "testuser_alert_create@example.com"}
    
        # When: 가입 요청
        register_response = client.post("/api/v1/users/register", json=register_data)
        assert register_response.status_code == 200, f"사용자 등록 실패: {register_response.text}"
    
        # When: 로그인 요청
        login_data = {"username": "testuser_alert_create", "password": "testpassword"}
        login_response = client.post("/api/v1/users/login", data=login_data) # login은 form data를 사용
>       assert login_response.status_code == 200, f"로그인 실패: {login_response.text}"
E       AssertionError: 로그인 실패: {"detail":[{"type":"model_attributes_type","loc":["body"],"msg":"Input should be a valid dictionary or object to extract fields from","input":"username=testuser_alert_create&password=testpassword"}]}
E       assert 422 == 200
E        +  where 422 = <Response [422 Unprocessable Entity]>.status_code

tests/integration/test_notification_publish_integration.py:42: AssertionError
---------------------------- Captured stdout setup -----------------------------
2025-08-31 17:48:40,731 - asyncio - DEBUG - Using selector: EpollSelector
2025-08-31 17:48:40,767 - src.api.main - INFO - 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
2025-08-31 17:48:40,969 - src.api.main - INFO - 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 17:48:41,005 - src.api.main - INFO - 테스트 StockMaster 데이터 시딩 완료.
2025-08-31 17:48:41,006 - src.api.main - INFO - 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 17:48:41,026 - src.api.main - INFO - 테스트 DailyPrice 데이터 시딩 완료.
2025-08-31 17:48:41,028 - asyncio - DEBUG - Using selector: EpollSelector
2025-08-31 17:48:41,029 - asyncio - DEBUG - Using selector: EpollSelector
------------------------------ Captured log setup ------------------------------
DEBUG    asyncio:selector_events.py:54 Using selector: EpollSelector
INFO     src.api.main:main.py:58 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
INFO     src.api.main:main.py:62 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:77 테스트 StockMaster 데이터 시딩 완료.
INFO     src.api.main:main.py:80 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:106 테스트 DailyPrice 데이터 시딩 완료.
DEBUG    asyncio:selector_events.py:54 Using selector: EpollSelector
DEBUG    asyncio:selector_events.py:54 Using selector: EpollSelector
----------------------------- Captured stdout call -----------------------------
2025-08-31 17:48:41,231 - passlib.handlers.bcrypt - WARNING - (trapped) error reading bcrypt version
Traceback (most recent call last):
  File "/usr/local/lib/python3.10/site-packages/passlib/handlers/bcrypt.py", line 620, in _load_backend_mixin
    version = _bcrypt.__about__.__version__
AttributeError: module 'bcrypt' has no attribute '__about__'
2025-08-31 17:48:41,235 - passlib.handlers.bcrypt - DEBUG - detected 'bcrypt' backend, version '<unknown>'
2025-08-31 17:48:41,235 - passlib.handlers.bcrypt - DEBUG - 'bcrypt' backend lacks $2$ support, enabling workaround
2025-08-31 17:48:41,545 - src.api.services.auth_service - DEBUG - [AuthService] Hashed password for testuser_alert_create: $2b$12$scuv8gjQ6ANfkJsy5fheKey58fJXfWFFz17YJf/OqwzEB9/cPyZnK
2025-08-31 17:48:41,565 - httpx - INFO - HTTP Request: POST http://testserver/api/v1/users/register "HTTP/1.1 200 OK"
2025-08-31 17:48:41,573 - httpx - INFO - HTTP Request: POST http://testserver/api/v1/users/login "HTTP/1.1 422 Unprocessable Entity"
------------------------------ Captured log call -------------------------------
WARNING  passlib.handlers.bcrypt:bcrypt.py:622 (trapped) error reading bcrypt version
Traceback (most recent call last):
  File "/usr/local/lib/python3.10/site-packages/passlib/handlers/bcrypt.py", line 620, in _load_backend_mixin
    version = _bcrypt.__about__.__version__
AttributeError: module 'bcrypt' has no attribute '__about__'
DEBUG    passlib.handlers.bcrypt:bcrypt.py:625 detected 'bcrypt' backend, version '<unknown>'
DEBUG    passlib.handlers.bcrypt:bcrypt.py:406 'bcrypt' backend lacks $2$ support, enabling workaround
DEBUG    src.api.services.auth_service:auth_service.py:40 [AuthService] Hashed password for testuser_alert_create: $2b$12$scuv8gjQ6ANfkJsy5fheKey58fJXfWFFz17YJf/OqwzEB9/cPyZnK
INFO     httpx:_client.py:1025 HTTP Request: POST http://testserver/api/v1/users/register "HTTP/1.1 200 OK"
INFO     httpx:_client.py:1025 HTTP Request: POST http://testserver/api/v1/users/login "HTTP/1.1 422 Unprocessable Entity"
=============================== warnings summary ===============================
../../../usr/local/lib/python3.10/site-packages/pydantic/_internal/_config.py:323
../../../usr/local/lib/python3.10/site-packages/pydantic/_internal/_config.py:323
../../../usr/local/lib/python3.10/site-packages/pydantic/_internal/_config.py:323
  /usr/local/lib/python3.10/site-packages/pydantic/_internal/_config.py:323: PydanticDeprecatedSince20: Support for class-based `config` is deprecated, use ConfigDict instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.11/migration/
    warnings.warn(DEPRECATION_MESSAGE, DeprecationWarning)

../../../usr/local/lib/python3.10/site-packages/pydantic/_internal/_config.py:373
  /usr/local/lib/python3.10/site-packages/pydantic/_internal/_config.py:373: UserWarning: Valid config keys have changed in V2:
  * 'orm_mode' has been renamed to 'from_attributes'
    warnings.warn(message, UserWarning)

main.py:112
  /app/src/api/main.py:112: DeprecationWarning: 
          on_event is deprecated, use lifespan event handlers instead.
  
          Read more about it in the
          [FastAPI docs for Lifespan Events](https://fastapi.tiangolo.com/advanced/events/).
          
    @app.on_event("startup")

../../../usr/local/lib/python3.10/site-packages/fastapi/applications.py:4495
  /usr/local/lib/python3.10/site-packages/fastapi/applications.py:4495: DeprecationWarning: 
          on_event is deprecated, use lifespan event handlers instead.
  
          Read more about it in the
          [FastAPI docs for Lifespan Events](https://fastapi.tiangolo.com/advanced/events/).
          
    return self.router.on_event(event_type)

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
=========================== short test summary info ============================
FAILED tests/integration/test_notification_publish_integration.py::test_create_price_alert_successfully
======================== 1 failed, 6 warnings in 2.41s =========================
\n--- Running test_db_schema_integration.py ---
============================= test session starts ==============================
platform linux -- Python 3.10.18, pytest-8.4.1, pluggy-1.6.0
rootdir: /app/src/api
plugins: cov-6.2.1, timeout-2.4.0, anyio-4.10.0, asyncio-1.1.0
asyncio: mode=strict, asyncio_default_fixture_loop_scope=None, asyncio_default_test_loop_scope=function
collected 10 items

tests/integration/test_db_schema_integration.py .FFFFFFFFF               [100%]

=================================== FAILURES ===================================
__________________ test_model_and_db_schema_match[PriceAlert] __________________

real_db = <sqlalchemy.orm.session.Session object at 0x7ff1864d7250>
db_inspector = <sqlalchemy.dialects.postgresql.base.PGInspector object at 0x7ff1864d43a0>
model_class = <class 'src.common.models.price_alert.PriceAlert'>

    @pytest.mark.parametrize("model_class", [mapper.class_ for mapper in Base.registry.mappers])
    def test_model_and_db_schema_match(real_db: Session, db_inspector, model_class):
        """
        - **테스트 대상**: 모든 SQLAlchemy 모델 클래스와 실제 DB 테이블 스키마
        - **목적**: 모델과 DB 스키마 간의 불일치가 없는지 검증합니다.
        - **시나리오**:
            1. `Base`에 등록된 모든 모델 클래스를 순회합니다.
            2. 각 모델에 대해, DB에 해당 테이블이 존재하는지 확인합니다.
            3. 모델의 모든 칼럼이 DB 테이블에 존재하는지, 타입과 Null 여부가 일치하는지 확인합니다.
            4. DB 테이블의 모든 칼럼이 모델에 정의되어 있는지 확인하여, 모델에 없는 불필요한 칼럼이 DB에 추가되었는지 검사합니다.
        - **Mock 대상**: 없음
        """
        if not hasattr(model_class, "__tablename__"):
            pytest.skip(f"Skipping {model_class.__name__}: Not a SQLAlchemy model with a __tablename__.")
    
        table_name = model_class.__tablename__
    
        # 1. 테이블 존재 여부 검증
        assert db_inspector.has_table(table_name), f"Table '{table_name}' does not exist in the database for model '{model_class.__name__}'."
    
        # 2. 모델과 DB의 칼럼 정보 가져오기
        model_columns = {col.name: col for col in model_class.__table__.columns}
        db_columns = {col['name']: col for col in db_inspector.get_columns(table_name)}
    
        # 3. 모델의 칼럼이 DB에 모두 존재하는지, 속성이 일치하는지 검증
        for col_name, model_col in model_columns.items():
            assert col_name in db_columns, f"Column '{col_name}' from model '{model_class.__name__}' not found in DB table '{table_name}'."
            db_col = db_columns[col_name]
    
            # 타입 검증 (DB 엔진별 타입 이름 차이를 고려한 단순 비교)
            model_type_str = str(model_col.type).split('(')[0]
            db_type_str = str(db_col['type']).split('(')[0]
            # 예: `String(100)` -> `String`, `VARCHAR(100)` -> `VARCHAR`
            # PostgreSQL의 `DOUBLE PRECISION`은 SQLAlchemy의 `FLOAT`에 해당
>           assert model_type_str == db_type_str or (model_type_str == "FLOAT" and db_type_str == "DOUBLE PRECISION"), \
                f"Type mismatch for column '{col_name}' in table '{table_name}': Model='{model_type_str}', DB='{db_type_str}'"
E           AssertionError: Type mismatch for column 'created_at' in table 'price_alerts': Model='DATETIME', DB='TIMESTAMP'
E           assert ('DATETIME' == 'TIMESTAMP'
E             
E             - TIMESTAMP
E             + DATETIME or ('DATETIME' == 'FLOAT'
E             
E             - FLOAT
E             + DATETIME))

tests/integration/test_db_schema_integration.py:101: AssertionError
_________________ test_model_and_db_schema_match[SystemConfig] _________________

real_db = <sqlalchemy.orm.session.Session object at 0x7ff18640fd60>
db_inspector = <sqlalchemy.dialects.postgresql.base.PGInspector object at 0x7ff18640ef50>
model_class = <class 'src.common.models.system_config.SystemConfig'>

    @pytest.mark.parametrize("model_class", [mapper.class_ for mapper in Base.registry.mappers])
    def test_model_and_db_schema_match(real_db: Session, db_inspector, model_class):
        """
        - **테스트 대상**: 모든 SQLAlchemy 모델 클래스와 실제 DB 테이블 스키마
        - **목적**: 모델과 DB 스키마 간의 불일치가 없는지 검증합니다.
        - **시나리오**:
            1. `Base`에 등록된 모든 모델 클래스를 순회합니다.
            2. 각 모델에 대해, DB에 해당 테이블이 존재하는지 확인합니다.
            3. 모델의 모든 칼럼이 DB 테이블에 존재하는지, 타입과 Null 여부가 일치하는지 확인합니다.
            4. DB 테이블의 모든 칼럼이 모델에 정의되어 있는지 확인하여, 모델에 없는 불필요한 칼럼이 DB에 추가되었는지 검사합니다.
        - **Mock 대상**: 없음
        """
        if not hasattr(model_class, "__tablename__"):
            pytest.skip(f"Skipping {model_class.__name__}: Not a SQLAlchemy model with a __tablename__.")
    
        table_name = model_class.__tablename__
    
        # 1. 테이블 존재 여부 검증
        assert db_inspector.has_table(table_name), f"Table '{table_name}' does not exist in the database for model '{model_class.__name__}'."
    
        # 2. 모델과 DB의 칼럼 정보 가져오기
        model_columns = {col.name: col for col in model_class.__table__.columns}
        db_columns = {col['name']: col for col in db_inspector.get_columns(table_name)}
    
        # 3. 모델의 칼럼이 DB에 모두 존재하는지, 속성이 일치하는지 검증
        for col_name, model_col in model_columns.items():
            assert col_name in db_columns, f"Column '{col_name}' from model '{model_class.__name__}' not found in DB table '{table_name}'."
            db_col = db_columns[col_name]
    
            # 타입 검증 (DB 엔진별 타입 이름 차이를 고려한 단순 비교)
            model_type_str = str(model_col.type).split('(')[0]
            db_type_str = str(db_col['type']).split('(')[0]
            # 예: `String(100)` -> `String`, `VARCHAR(100)` -> `VARCHAR`
            # PostgreSQL의 `DOUBLE PRECISION`은 SQLAlchemy의 `FLOAT`에 해당
>           assert model_type_str == db_type_str or (model_type_str == "FLOAT" and db_type_str == "DOUBLE PRECISION"), \
                f"Type mismatch for column '{col_name}' in table '{table_name}': Model='{model_type_str}', DB='{db_type_str}'"
E           AssertionError: Type mismatch for column 'created_at' in table 'system_config': Model='DATETIME', DB='TIMESTAMP'
E           assert ('DATETIME' == 'TIMESTAMP'
E             
E             - TIMESTAMP
E             + DATETIME or ('DATETIME' == 'FLOAT'
E             
E             - FLOAT
E             + DATETIME))

tests/integration/test_db_schema_integration.py:101: AssertionError
______________ test_model_and_db_schema_match[PredictionHistory] _______________

real_db = <sqlalchemy.orm.session.Session object at 0x7ff18640cc10>
db_inspector = <sqlalchemy.dialects.postgresql.base.PGInspector object at 0x7ff18640ff40>
model_class = <class 'src.common.models.prediction_history.PredictionHistory'>

    @pytest.mark.parametrize("model_class", [mapper.class_ for mapper in Base.registry.mappers])
    def test_model_and_db_schema_match(real_db: Session, db_inspector, model_class):
        """
        - **테스트 대상**: 모든 SQLAlchemy 모델 클래스와 실제 DB 테이블 스키마
        - **목적**: 모델과 DB 스키마 간의 불일치가 없는지 검증합니다.
        - **시나리오**:
            1. `Base`에 등록된 모든 모델 클래스를 순회합니다.
            2. 각 모델에 대해, DB에 해당 테이블이 존재하는지 확인합니다.
            3. 모델의 모든 칼럼이 DB 테이블에 존재하는지, 타입과 Null 여부가 일치하는지 확인합니다.
            4. DB 테이블의 모든 칼럼이 모델에 정의되어 있는지 확인하여, 모델에 없는 불필요한 칼럼이 DB에 추가되었는지 검사합니다.
        - **Mock 대상**: 없음
        """
        if not hasattr(model_class, "__tablename__"):
            pytest.skip(f"Skipping {model_class.__name__}: Not a SQLAlchemy model with a __tablename__.")
    
        table_name = model_class.__tablename__
    
        # 1. 테이블 존재 여부 검증
        assert db_inspector.has_table(table_name), f"Table '{table_name}' does not exist in the database for model '{model_class.__name__}'."
    
        # 2. 모델과 DB의 칼럼 정보 가져오기
        model_columns = {col.name: col for col in model_class.__table__.columns}
        db_columns = {col['name']: col for col in db_inspector.get_columns(table_name)}
    
        # 3. 모델의 칼럼이 DB에 모두 존재하는지, 속성이 일치하는지 검증
        for col_name, model_col in model_columns.items():
            assert col_name in db_columns, f"Column '{col_name}' from model '{model_class.__name__}' not found in DB table '{table_name}'."
            db_col = db_columns[col_name]
    
            # 타입 검증 (DB 엔진별 타입 이름 차이를 고려한 단순 비교)
            model_type_str = str(model_col.type).split('(')[0]
            db_type_str = str(db_col['type']).split('(')[0]
            # 예: `String(100)` -> `String`, `VARCHAR(100)` -> `VARCHAR`
            # PostgreSQL의 `DOUBLE PRECISION`은 SQLAlchemy의 `FLOAT`에 해당
>           assert model_type_str == db_type_str or (model_type_str == "FLOAT" and db_type_str == "DOUBLE PRECISION"), \
                f"Type mismatch for column '{col_name}' in table '{table_name}': Model='{model_type_str}', DB='{db_type_str}'"
E           AssertionError: Type mismatch for column 'created_at' in table 'prediction_history': Model='DATETIME', DB='TIMESTAMP'
E           assert ('DATETIME' == 'TIMESTAMP'
E             
E             - TIMESTAMP
E             + DATETIME or ('DATETIME' == 'FLOAT'
E             
E             - FLOAT
E             + DATETIME))

tests/integration/test_db_schema_integration.py:101: AssertionError
_____________________ test_model_and_db_schema_match[User] _____________________

real_db = <sqlalchemy.orm.session.Session object at 0x7ff18640e980>
db_inspector = <sqlalchemy.dialects.postgresql.base.PGInspector object at 0x7ff1862703a0>
model_class = <class 'src.common.models.user.User'>

    @pytest.mark.parametrize("model_class", [mapper.class_ for mapper in Base.registry.mappers])
    def test_model_and_db_schema_match(real_db: Session, db_inspector, model_class):
        """
        - **테스트 대상**: 모든 SQLAlchemy 모델 클래스와 실제 DB 테이블 스키마
        - **목적**: 모델과 DB 스키마 간의 불일치가 없는지 검증합니다.
        - **시나리오**:
            1. `Base`에 등록된 모든 모델 클래스를 순회합니다.
            2. 각 모델에 대해, DB에 해당 테이블이 존재하는지 확인합니다.
            3. 모델의 모든 칼럼이 DB 테이블에 존재하는지, 타입과 Null 여부가 일치하는지 확인합니다.
            4. DB 테이블의 모든 칼럼이 모델에 정의되어 있는지 확인하여, 모델에 없는 불필요한 칼럼이 DB에 추가되었는지 검사합니다.
        - **Mock 대상**: 없음
        """
        if not hasattr(model_class, "__tablename__"):
            pytest.skip(f"Skipping {model_class.__name__}: Not a SQLAlchemy model with a __tablename__.")
    
        table_name = model_class.__tablename__
    
        # 1. 테이블 존재 여부 검증
        assert db_inspector.has_table(table_name), f"Table '{table_name}' does not exist in the database for model '{model_class.__name__}'."
    
        # 2. 모델과 DB의 칼럼 정보 가져오기
        model_columns = {col.name: col for col in model_class.__table__.columns}
        db_columns = {col['name']: col for col in db_inspector.get_columns(table_name)}
    
        # 3. 모델의 칼럼이 DB에 모두 존재하는지, 속성이 일치하는지 검증
        for col_name, model_col in model_columns.items():
            assert col_name in db_columns, f"Column '{col_name}' from model '{model_class.__name__}' not found in DB table '{table_name}'."
            db_col = db_columns[col_name]
    
            # 타입 검증 (DB 엔진별 타입 이름 차이를 고려한 단순 비교)
            model_type_str = str(model_col.type).split('(')[0]
            db_type_str = str(db_col['type']).split('(')[0]
            # 예: `String(100)` -> `String`, `VARCHAR(100)` -> `VARCHAR`
            # PostgreSQL의 `DOUBLE PRECISION`은 SQLAlchemy의 `FLOAT`에 해당
>           assert model_type_str == db_type_str or (model_type_str == "FLOAT" and db_type_str == "DOUBLE PRECISION"), \
                f"Type mismatch for column '{col_name}' in table '{table_name}': Model='{model_type_str}', DB='{db_type_str}'"
E           AssertionError: Type mismatch for column 'created_at' in table 'app_users': Model='DATETIME', DB='TIMESTAMP'
E           assert ('DATETIME' == 'TIMESTAMP'
E             
E             - TIMESTAMP
E             + DATETIME or ('DATETIME' == 'FLOAT'
E             
E             - FLOAT
E             + DATETIME))

tests/integration/test_db_schema_integration.py:101: AssertionError
_________________ test_model_and_db_schema_match[StockMaster] __________________

real_db = <sqlalchemy.orm.session.Session object at 0x7ff186271a50>
db_inspector = <sqlalchemy.dialects.postgresql.base.PGInspector object at 0x7ff186272860>
model_class = <class 'src.common.models.stock_master.StockMaster'>

    @pytest.mark.parametrize("model_class", [mapper.class_ for mapper in Base.registry.mappers])
    def test_model_and_db_schema_match(real_db: Session, db_inspector, model_class):
        """
        - **테스트 대상**: 모든 SQLAlchemy 모델 클래스와 실제 DB 테이블 스키마
        - **목적**: 모델과 DB 스키마 간의 불일치가 없는지 검증합니다.
        - **시나리오**:
            1. `Base`에 등록된 모든 모델 클래스를 순회합니다.
            2. 각 모델에 대해, DB에 해당 테이블이 존재하는지 확인합니다.
            3. 모델의 모든 칼럼이 DB 테이블에 존재하는지, 타입과 Null 여부가 일치하는지 확인합니다.
            4. DB 테이블의 모든 칼럼이 모델에 정의되어 있는지 확인하여, 모델에 없는 불필요한 칼럼이 DB에 추가되었는지 검사합니다.
        - **Mock 대상**: 없음
        """
        if not hasattr(model_class, "__tablename__"):
            pytest.skip(f"Skipping {model_class.__name__}: Not a SQLAlchemy model with a __tablename__.")
    
        table_name = model_class.__tablename__
    
        # 1. 테이블 존재 여부 검증
        assert db_inspector.has_table(table_name), f"Table '{table_name}' does not exist in the database for model '{model_class.__name__}'."
    
        # 2. 모델과 DB의 칼럼 정보 가져오기
        model_columns = {col.name: col for col in model_class.__table__.columns}
        db_columns = {col['name']: col for col in db_inspector.get_columns(table_name)}
    
        # 3. 모델의 칼럼이 DB에 모두 존재하는지, 속성이 일치하는지 검증
        for col_name, model_col in model_columns.items():
            assert col_name in db_columns, f"Column '{col_name}' from model '{model_class.__name__}' not found in DB table '{table_name}'."
            db_col = db_columns[col_name]
    
            # 타입 검증 (DB 엔진별 타입 이름 차이를 고려한 단순 비교)
            model_type_str = str(model_col.type).split('(')[0]
            db_type_str = str(db_col['type']).split('(')[0]
            # 예: `String(100)` -> `String`, `VARCHAR(100)` -> `VARCHAR`
            # PostgreSQL의 `DOUBLE PRECISION`은 SQLAlchemy의 `FLOAT`에 해당
>           assert model_type_str == db_type_str or (model_type_str == "FLOAT" and db_type_str == "DOUBLE PRECISION"), \
                f"Type mismatch for column '{col_name}' in table '{table_name}': Model='{model_type_str}', DB='{db_type_str}'"
E           AssertionError: Type mismatch for column 'created_at' in table 'stock_master': Model='DATETIME', DB='TIMESTAMP'
E           assert ('DATETIME' == 'TIMESTAMP'
E             
E             - TIMESTAMP
E             + DATETIME or ('DATETIME' == 'FLOAT'
E             
E             - FLOAT
E             + DATETIME))

tests/integration/test_db_schema_integration.py:101: AssertionError
__________________ test_model_and_db_schema_match[DailyPrice] __________________

real_db = <sqlalchemy.orm.session.Session object at 0x7ff1862a5930>
db_inspector = <sqlalchemy.dialects.postgresql.base.PGInspector object at 0x7ff1862a5fc0>
model_class = <class 'src.common.models.daily_price.DailyPrice'>

    @pytest.mark.parametrize("model_class", [mapper.class_ for mapper in Base.registry.mappers])
    def test_model_and_db_schema_match(real_db: Session, db_inspector, model_class):
        """
        - **테스트 대상**: 모든 SQLAlchemy 모델 클래스와 실제 DB 테이블 스키마
        - **목적**: 모델과 DB 스키마 간의 불일치가 없는지 검증합니다.
        - **시나리오**:
            1. `Base`에 등록된 모든 모델 클래스를 순회합니다.
            2. 각 모델에 대해, DB에 해당 테이블이 존재하는지 확인합니다.
            3. 모델의 모든 칼럼이 DB 테이블에 존재하는지, 타입과 Null 여부가 일치하는지 확인합니다.
            4. DB 테이블의 모든 칼럼이 모델에 정의되어 있는지 확인하여, 모델에 없는 불필요한 칼럼이 DB에 추가되었는지 검사합니다.
        - **Mock 대상**: 없음
        """
        if not hasattr(model_class, "__tablename__"):
            pytest.skip(f"Skipping {model_class.__name__}: Not a SQLAlchemy model with a __tablename__.")
    
        table_name = model_class.__tablename__
    
        # 1. 테이블 존재 여부 검증
        assert db_inspector.has_table(table_name), f"Table '{table_name}' does not exist in the database for model '{model_class.__name__}'."
    
        # 2. 모델과 DB의 칼럼 정보 가져오기
        model_columns = {col.name: col for col in model_class.__table__.columns}
        db_columns = {col['name']: col for col in db_inspector.get_columns(table_name)}
    
        # 3. 모델의 칼럼이 DB에 모두 존재하는지, 속성이 일치하는지 검증
        for col_name, model_col in model_columns.items():
            assert col_name in db_columns, f"Column '{col_name}' from model '{model_class.__name__}' not found in DB table '{table_name}'."
            db_col = db_columns[col_name]
    
            # 타입 검증 (DB 엔진별 타입 이름 차이를 고려한 단순 비교)
            model_type_str = str(model_col.type).split('(')[0]
            db_type_str = str(db_col['type']).split('(')[0]
            # 예: `String(100)` -> `String`, `VARCHAR(100)` -> `VARCHAR`
            # PostgreSQL의 `DOUBLE PRECISION`은 SQLAlchemy의 `FLOAT`에 해당
>           assert model_type_str == db_type_str or (model_type_str == "FLOAT" and db_type_str == "DOUBLE PRECISION"), \
                f"Type mismatch for column '{col_name}' in table '{table_name}': Model='{model_type_str}', DB='{db_type_str}'"
E           AssertionError: Type mismatch for column 'created_at' in table 'daily_prices': Model='DATETIME', DB='TIMESTAMP'
E           assert ('DATETIME' == 'TIMESTAMP'
E             
E             - TIMESTAMP
E             + DATETIME or ('DATETIME' == 'FLOAT'
E             
E             - FLOAT
E             + DATETIME))

tests/integration/test_db_schema_integration.py:101: AssertionError
__________________ test_model_and_db_schema_match[Disclosure] __________________

real_db = <sqlalchemy.orm.session.Session object at 0x7ff1862b7610>
db_inspector = <sqlalchemy.dialects.postgresql.base.PGInspector object at 0x7ff1862b7340>
model_class = <class 'src.common.models.disclosure.Disclosure'>

    @pytest.mark.parametrize("model_class", [mapper.class_ for mapper in Base.registry.mappers])
    def test_model_and_db_schema_match(real_db: Session, db_inspector, model_class):
        """
        - **테스트 대상**: 모든 SQLAlchemy 모델 클래스와 실제 DB 테이블 스키마
        - **목적**: 모델과 DB 스키마 간의 불일치가 없는지 검증합니다.
        - **시나리오**:
            1. `Base`에 등록된 모든 모델 클래스를 순회합니다.
            2. 각 모델에 대해, DB에 해당 테이블이 존재하는지 확인합니다.
            3. 모델의 모든 칼럼이 DB 테이블에 존재하는지, 타입과 Null 여부가 일치하는지 확인합니다.
            4. DB 테이블의 모든 칼럼이 모델에 정의되어 있는지 확인하여, 모델에 없는 불필요한 칼럼이 DB에 추가되었는지 검사합니다.
        - **Mock 대상**: 없음
        """
        if not hasattr(model_class, "__tablename__"):
            pytest.skip(f"Skipping {model_class.__name__}: Not a SQLAlchemy model with a __tablename__.")
    
        table_name = model_class.__tablename__
    
        # 1. 테이블 존재 여부 검증
        assert db_inspector.has_table(table_name), f"Table '{table_name}' does not exist in the database for model '{model_class.__name__}'."
    
        # 2. 모델과 DB의 칼럼 정보 가져오기
        model_columns = {col.name: col for col in model_class.__table__.columns}
        db_columns = {col['name']: col for col in db_inspector.get_columns(table_name)}
    
        # 3. 모델의 칼럼이 DB에 모두 존재하는지, 속성이 일치하는지 검증
        for col_name, model_col in model_columns.items():
            assert col_name in db_columns, f"Column '{col_name}' from model '{model_class.__name__}' not found in DB table '{table_name}'."
            db_col = db_columns[col_name]
    
            # 타입 검증 (DB 엔진별 타입 이름 차이를 고려한 단순 비교)
            model_type_str = str(model_col.type).split('(')[0]
            db_type_str = str(db_col['type']).split('(')[0]
            # 예: `String(100)` -> `String`, `VARCHAR(100)` -> `VARCHAR`
            # PostgreSQL의 `DOUBLE PRECISION`은 SQLAlchemy의 `FLOAT`에 해당
>           assert model_type_str == db_type_str or (model_type_str == "FLOAT" and db_type_str == "DOUBLE PRECISION"), \
                f"Type mismatch for column '{col_name}' in table '{table_name}': Model='{model_type_str}', DB='{db_type_str}'"
E           AssertionError: Type mismatch for column 'disclosed_at' in table 'disclosures': Model='DATETIME', DB='TIMESTAMP'
E           assert ('DATETIME' == 'TIMESTAMP'
E             
E             - TIMESTAMP
E             + DATETIME or ('DATETIME' == 'FLOAT'
E             
E             - FLOAT
E             + DATETIME))

tests/integration/test_db_schema_integration.py:101: AssertionError
________________ test_model_and_db_schema_match[SimulatedTrade] ________________

real_db = <sqlalchemy.orm.session.Session object at 0x7ff1862b5e70>
db_inspector = <sqlalchemy.dialects.postgresql.base.PGInspector object at 0x7ff1862b5a50>
model_class = <class 'src.common.models.simulated_trade.SimulatedTrade'>

    @pytest.mark.parametrize("model_class", [mapper.class_ for mapper in Base.registry.mappers])
    def test_model_and_db_schema_match(real_db: Session, db_inspector, model_class):
        """
        - **테스트 대상**: 모든 SQLAlchemy 모델 클래스와 실제 DB 테이블 스키마
        - **목적**: 모델과 DB 스키마 간의 불일치가 없는지 검증합니다.
        - **시나리오**:
            1. `Base`에 등록된 모든 모델 클래스를 순회합니다.
            2. 각 모델에 대해, DB에 해당 테이블이 존재하는지 확인합니다.
            3. 모델의 모든 칼럼이 DB 테이블에 존재하는지, 타입과 Null 여부가 일치하는지 확인합니다.
            4. DB 테이블의 모든 칼럼이 모델에 정의되어 있는지 확인하여, 모델에 없는 불필요한 칼럼이 DB에 추가되었는지 검사합니다.
        - **Mock 대상**: 없음
        """
        if not hasattr(model_class, "__tablename__"):
            pytest.skip(f"Skipping {model_class.__name__}: Not a SQLAlchemy model with a __tablename__.")
    
        table_name = model_class.__tablename__
    
        # 1. 테이블 존재 여부 검증
        assert db_inspector.has_table(table_name), f"Table '{table_name}' does not exist in the database for model '{model_class.__name__}'."
    
        # 2. 모델과 DB의 칼럼 정보 가져오기
        model_columns = {col.name: col for col in model_class.__table__.columns}
        db_columns = {col['name']: col for col in db_inspector.get_columns(table_name)}
    
        # 3. 모델의 칼럼이 DB에 모두 존재하는지, 속성이 일치하는지 검증
        for col_name, model_col in model_columns.items():
            assert col_name in db_columns, f"Column '{col_name}' from model '{model_class.__name__}' not found in DB table '{table_name}'."
            db_col = db_columns[col_name]
    
            # 타입 검증 (DB 엔진별 타입 이름 차이를 고려한 단순 비교)
            model_type_str = str(model_col.type).split('(')[0]
            db_type_str = str(db_col['type']).split('(')[0]
            # 예: `String(100)` -> `String`, `VARCHAR(100)` -> `VARCHAR`
            # PostgreSQL의 `DOUBLE PRECISION`은 SQLAlchemy의 `FLOAT`에 해당
>           assert model_type_str == db_type_str or (model_type_str == "FLOAT" and db_type_str == "DOUBLE PRECISION"), \
                f"Type mismatch for column '{col_name}' in table '{table_name}': Model='{model_type_str}', DB='{db_type_str}'"
E           AssertionError: Type mismatch for column 'trade_time' in table 'simulated_trades': Model='DATETIME', DB='TIMESTAMP'
E           assert ('DATETIME' == 'TIMESTAMP'
E             
E             - TIMESTAMP
E             + DATETIME or ('DATETIME' == 'FLOAT'
E             
E             - FLOAT
E             + DATETIME))

tests/integration/test_db_schema_integration.py:101: AssertionError
__________________ test_model_and_db_schema_match[Watchlist] ___________________

real_db = <sqlalchemy.orm.session.Session object at 0x7ff186272770>
db_inspector = <sqlalchemy.dialects.postgresql.base.PGInspector object at 0x7ff186273a00>
model_class = <class 'src.common.models.watchlist.Watchlist'>

    @pytest.mark.parametrize("model_class", [mapper.class_ for mapper in Base.registry.mappers])
    def test_model_and_db_schema_match(real_db: Session, db_inspector, model_class):
        """
        - **테스트 대상**: 모든 SQLAlchemy 모델 클래스와 실제 DB 테이블 스키마
        - **목적**: 모델과 DB 스키마 간의 불일치가 없는지 검증합니다.
        - **시나리오**:
            1. `Base`에 등록된 모든 모델 클래스를 순회합니다.
            2. 각 모델에 대해, DB에 해당 테이블이 존재하는지 확인합니다.
            3. 모델의 모든 칼럼이 DB 테이블에 존재하는지, 타입과 Null 여부가 일치하는지 확인합니다.
            4. DB 테이블의 모든 칼럼이 모델에 정의되어 있는지 확인하여, 모델에 없는 불필요한 칼럼이 DB에 추가되었는지 검사합니다.
        - **Mock 대상**: 없음
        """
        if not hasattr(model_class, "__tablename__"):
            pytest.skip(f"Skipping {model_class.__name__}: Not a SQLAlchemy model with a __tablename__.")
    
        table_name = model_class.__tablename__
    
        # 1. 테이블 존재 여부 검증
        assert db_inspector.has_table(table_name), f"Table '{table_name}' does not exist in the database for model '{model_class.__name__}'."
    
        # 2. 모델과 DB의 칼럼 정보 가져오기
        model_columns = {col.name: col for col in model_class.__table__.columns}
        db_columns = {col['name']: col for col in db_inspector.get_columns(table_name)}
    
        # 3. 모델의 칼럼이 DB에 모두 존재하는지, 속성이 일치하는지 검증
        for col_name, model_col in model_columns.items():
            assert col_name in db_columns, f"Column '{col_name}' from model '{model_class.__name__}' not found in DB table '{table_name}'."
            db_col = db_columns[col_name]
    
            # 타입 검증 (DB 엔진별 타입 이름 차이를 고려한 단순 비교)
            model_type_str = str(model_col.type).split('(')[0]
            db_type_str = str(db_col['type']).split('(')[0]
            # 예: `String(100)` -> `String`, `VARCHAR(100)` -> `VARCHAR`
            # PostgreSQL의 `DOUBLE PRECISION`은 SQLAlchemy의 `FLOAT`에 해당
>           assert model_type_str == db_type_str or (model_type_str == "FLOAT" and db_type_str == "DOUBLE PRECISION"), \
                f"Type mismatch for column '{col_name}' in table '{table_name}': Model='{model_type_str}', DB='{db_type_str}'"
E           AssertionError: Type mismatch for column 'created_at' in table 'watch_list': Model='DATETIME', DB='TIMESTAMP'
E           assert ('DATETIME' == 'TIMESTAMP'
E             
E             - TIMESTAMP
E             + DATETIME or ('DATETIME' == 'FLOAT'
E             
E             - FLOAT
E             + DATETIME))

tests/integration/test_db_schema_integration.py:101: AssertionError
=============================== warnings summary ===============================
../../../usr/local/lib/python3.10/site-packages/pydantic/_internal/_config.py:323
../../../usr/local/lib/python3.10/site-packages/pydantic/_internal/_config.py:323
../../../usr/local/lib/python3.10/site-packages/pydantic/_internal/_config.py:323
  /usr/local/lib/python3.10/site-packages/pydantic/_internal/_config.py:323: PydanticDeprecatedSince20: Support for class-based `config` is deprecated, use ConfigDict instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.11/migration/
    warnings.warn(DEPRECATION_MESSAGE, DeprecationWarning)

../../../usr/local/lib/python3.10/site-packages/pydantic/_internal/_config.py:373
  /usr/local/lib/python3.10/site-packages/pydantic/_internal/_config.py:373: UserWarning: Valid config keys have changed in V2:
  * 'orm_mode' has been renamed to 'from_attributes'
    warnings.warn(message, UserWarning)

main.py:112
  /app/src/api/main.py:112: DeprecationWarning: 
          on_event is deprecated, use lifespan event handlers instead.
  
          Read more about it in the
          [FastAPI docs for Lifespan Events](https://fastapi.tiangolo.com/advanced/events/).
          
    @app.on_event("startup")

../../../usr/local/lib/python3.10/site-packages/fastapi/applications.py:4495
  /usr/local/lib/python3.10/site-packages/fastapi/applications.py:4495: DeprecationWarning: 
          on_event is deprecated, use lifespan event handlers instead.
  
          Read more about it in the
          [FastAPI docs for Lifespan Events](https://fastapi.tiangolo.com/advanced/events/).
          
    return self.router.on_event(event_type)

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
=========================== short test summary info ============================
FAILED tests/integration/test_db_schema_integration.py::test_model_and_db_schema_match[PriceAlert]
FAILED tests/integration/test_db_schema_integration.py::test_model_and_db_schema_match[SystemConfig]
FAILED tests/integration/test_db_schema_integration.py::test_model_and_db_schema_match[PredictionHistory]
FAILED tests/integration/test_db_schema_integration.py::test_model_and_db_schema_match[User]
FAILED tests/integration/test_db_schema_integration.py::test_model_and_db_schema_match[StockMaster]
FAILED tests/integration/test_db_schema_integration.py::test_model_and_db_schema_match[DailyPrice]
FAILED tests/integration/test_db_schema_integration.py::test_model_and_db_schema_match[Disclosure]
FAILED tests/integration/test_db_schema_integration.py::test_model_and_db_schema_match[SimulatedTrade]
FAILED tests/integration/test_db_schema_integration.py::test_model_and_db_schema_match[Watchlist]
=================== 9 failed, 1 passed, 6 warnings in 4.13s ====================
\n--- Running test_api_watchlist_integration.py ---
============================= test session starts ==============================
platform linux -- Python 3.10.18, pytest-8.4.1, pluggy-1.6.0
rootdir: /app/src/api
plugins: cov-6.2.1, timeout-2.4.0, anyio-4.10.0, asyncio-1.1.0
asyncio: mode=strict, asyncio_default_fixture_loop_scope=None, asyncio_default_test_loop_scope=function
collected 6 items

tests/integration/test_api_watchlist_integration.py FFFFFF               [100%]

=================================== FAILURES ===================================
__________________________ test_add_and_get_watchlist __________________________

client = <starlette.testclient.TestClient object at 0x7fd24c31ce50>
real_db = <sqlalchemy.orm.session.Session object at 0x7fd24c4aece0>
test_stock_master_data = [<src.common.models.stock_master.StockMaster object at 0x7fd24c31fc70>, <src.common.models.stock_master.StockMaster ob...ster.StockMaster object at 0x7fd24c2fb1f0>, <src.common.models.stock_master.StockMaster object at 0x7fd24c2fa110>, ...]

    def test_add_and_get_watchlist(client: TestClient, real_db, test_stock_master_data):
        """
        - **테스트 대상**: `POST /watchlist/add`, `GET /watchlist/get/{user_id}`
        - **목적**: 관심 종목을 성공적으로 추가하고, 추가된 종목이 조회되는지 확인합니다.
        - **시나리오**:
            1. 테스트용 사용자를 생성합니다.
            2. 특정 종목을 관심 목록에 추가 요청합니다.
            3. 200 OK 응답을 확인합니다.
            4. 해당 사용자의 관심 목록을 조회합니다.
            5. 200 OK 응답과 함께, 방금 추가한 종목이 목록에 포함되어 있는지 확인합니다.
        - **Mock 대상**: 없음
        """
        # Given
>       user = create_test_user(real_db)

tests/integration/test_api_watchlist_integration.py:30: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/helpers.py:14: in create_test_user
    user = User(
<string>:4: in __init__
    ???
/usr/local/lib/python3.10/site-packages/sqlalchemy/orm/state.py:571: in _initialize_instance
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/orm/state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.common.models.user.User object at 0x7fd24c2f6860>
kwargs = {'email': 'test_3c671d8096bb441e80ceae79261ba519@example.com', 'is_active': True, 'password_hash': '$2b$12$6.Gqb.eJrofiNV781/rGZOfcggvccXRTWCMEl1AHjYEX30boSOHt6', 'role': 'user', ...}
cls_ = <class 'src.common.models.user.User'>, k = 'password_hash'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'password_hash' is an invalid keyword argument for User

/usr/local/lib/python3.10/site-packages/sqlalchemy/orm/decl_base.py:2179: TypeError
---------------------------- Captured stdout setup -----------------------------
2025-08-31 17:49:06,925 - asyncio - DEBUG - Using selector: EpollSelector
2025-08-31 17:49:06,992 - src.api.main - INFO - 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
2025-08-31 17:49:07,194 - src.api.main - INFO - 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 17:49:07,366 - src.api.main - INFO - 테스트 StockMaster 데이터 시딩 완료.
2025-08-31 17:49:07,367 - src.api.main - INFO - 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 17:49:07,384 - src.api.main - INFO - 테스트 DailyPrice 데이터 시딩 완료.
------------------------------ Captured log setup ------------------------------
DEBUG    asyncio:selector_events.py:54 Using selector: EpollSelector
INFO     src.api.main:main.py:58 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
INFO     src.api.main:main.py:62 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:77 테스트 StockMaster 데이터 시딩 완료.
INFO     src.api.main:main.py:80 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:106 테스트 DailyPrice 데이터 시딩 완료.
----------------------------- Captured stdout call -----------------------------
2025-08-31 17:49:07,411 - passlib.handlers.bcrypt - WARNING - (trapped) error reading bcrypt version
Traceback (most recent call last):
  File "/usr/local/lib/python3.10/site-packages/passlib/handlers/bcrypt.py", line 620, in _load_backend_mixin
    version = _bcrypt.__about__.__version__
AttributeError: module 'bcrypt' has no attribute '__about__'
2025-08-31 17:49:07,412 - passlib.handlers.bcrypt - DEBUG - detected 'bcrypt' backend, version '<unknown>'
2025-08-31 17:49:07,413 - passlib.handlers.bcrypt - DEBUG - 'bcrypt' backend lacks $2$ support, enabling workaround
------------------------------ Captured log call -------------------------------
WARNING  passlib.handlers.bcrypt:bcrypt.py:622 (trapped) error reading bcrypt version
Traceback (most recent call last):
  File "/usr/local/lib/python3.10/site-packages/passlib/handlers/bcrypt.py", line 620, in _load_backend_mixin
    version = _bcrypt.__about__.__version__
AttributeError: module 'bcrypt' has no attribute '__about__'
DEBUG    passlib.handlers.bcrypt:bcrypt.py:625 detected 'bcrypt' backend, version '<unknown>'
DEBUG    passlib.handlers.bcrypt:bcrypt.py:406 'bcrypt' backend lacks $2$ support, enabling workaround
________________________ test_remove_watchlist_success _________________________

client = <starlette.testclient.TestClient object at 0x7fd24c31f5e0>
real_db = <sqlalchemy.orm.session.Session object at 0x7fd24c31eb60>
test_stock_master_data = [<src.common.models.stock_master.StockMaster object at 0x7fd24c31f850>, <src.common.models.stock_master.StockMaster ob...ster.StockMaster object at 0x7fd24b9139a0>, <src.common.models.stock_master.StockMaster object at 0x7fd24b913610>, ...]

    def test_remove_watchlist_success(client: TestClient, real_db, test_stock_master_data):
        """
        - **테스트 대상**: `POST /watchlist/remove`
        - **목적**: 관심 종목을 성공적으로 삭제하는지 확인합니다.
        - **시나리오**:
            1. 테스트 사용자의 관심 목록에 종목을 미리 추가합니다.
            2. 해당 종목을 관심 목록에서 삭제 요청합니다.
            3. 200 OK 응답과 성공 메시지를 확인합니다.
            4. 관심 목록을 다시 조회하여 해당 종목이 삭제되었는지 확인합니다.
        - **Mock 대상**: 없음
        """
        # Given
>       user = create_test_user(real_db)

tests/integration/test_api_watchlist_integration.py:58: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/helpers.py:14: in create_test_user
    user = User(
<string>:4: in __init__
    ???
/usr/local/lib/python3.10/site-packages/sqlalchemy/orm/state.py:571: in _initialize_instance
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/orm/state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.common.models.user.User object at 0x7fd24c31fb20>
kwargs = {'email': 'test_f5193d0cba1f49af9cfe864c3a35ffb7@example.com', 'is_active': True, 'password_hash': '$2b$12$pZPQ.B34EsX5X4kzzfv/DuQg50cyFjtVTIN7iErcU/BRGg1bBL8YS', 'role': 'user', ...}
cls_ = <class 'src.common.models.user.User'>, k = 'password_hash'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'password_hash' is an invalid keyword argument for User

/usr/local/lib/python3.10/site-packages/sqlalchemy/orm/decl_base.py:2179: TypeError
---------------------------- Captured stdout setup -----------------------------
2025-08-31 17:49:08,296 - asyncio - DEBUG - Using selector: EpollSelector
2025-08-31 17:49:08,311 - src.api.main - INFO - 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
2025-08-31 17:49:08,490 - src.api.main - INFO - 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 17:49:08,500 - src.api.main - INFO - 테스트 StockMaster 데이터 시딩 완료.
2025-08-31 17:49:08,500 - src.api.main - INFO - 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 17:49:08,514 - src.api.main - INFO - 테스트 DailyPrice 데이터 시딩 완료.
------------------------------ Captured log setup ------------------------------
DEBUG    asyncio:selector_events.py:54 Using selector: EpollSelector
INFO     src.api.main:main.py:58 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
INFO     src.api.main:main.py:62 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:77 테스트 StockMaster 데이터 시딩 완료.
INFO     src.api.main:main.py:80 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:106 테스트 DailyPrice 데이터 시딩 완료.
_________________________ test_add_watchlist_duplicate _________________________

client = <starlette.testclient.TestClient object at 0x7fd24c31e710>
real_db = <sqlalchemy.orm.session.Session object at 0x7fd24c2fa350>
test_stock_master_data = [<src.common.models.stock_master.StockMaster object at 0x7fd24c31fbe0>, <src.common.models.stock_master.StockMaster ob...ster.StockMaster object at 0x7fd24b912020>, <src.common.models.stock_master.StockMaster object at 0x7fd24b912c20>, ...]

    def test_add_watchlist_duplicate(client: TestClient, real_db, test_stock_master_data):
        """
        - **테스트 대상**: `POST /watchlist/add`
        - **목적**: 이미 추가된 종목을 다시 추가하려고 할 때, 중복 추가되지 않고 정상 처리되는지 확인합니다.
        - **시나리오**:
            1. 특정 종목을 관심 목록에 추가합니다.
            2. 동일한 종목을 다시 추가 요청합니다.
            3. 200 OK 응답과 함께, "이미 관심 목록에 있는 종목입니다." 메시지를 확인합니다.
        - **Mock 대상**: 없음
        """
        # Given
>       user = create_test_user(real_db)

tests/integration/test_api_watchlist_integration.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/helpers.py:14: in create_test_user
    user = User(
<string>:4: in __init__
    ???
/usr/local/lib/python3.10/site-packages/sqlalchemy/orm/state.py:571: in _initialize_instance
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/orm/state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.common.models.user.User object at 0x7fd24c2f9780>
kwargs = {'email': 'test_96881a3602464430a12568316afd11b3@example.com', 'is_active': True, 'password_hash': '$2b$12$LzOAIk8Or.IkvqJl1qliH.Rb5yfgMfVV8RYeHdOC1wpRJ9CKnRIQO', 'role': 'user', ...}
cls_ = <class 'src.common.models.user.User'>, k = 'password_hash'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'password_hash' is an invalid keyword argument for User

/usr/local/lib/python3.10/site-packages/sqlalchemy/orm/decl_base.py:2179: TypeError
---------------------------- Captured stdout setup -----------------------------
2025-08-31 17:49:09,261 - asyncio - DEBUG - Using selector: EpollSelector
2025-08-31 17:49:09,273 - src.api.main - INFO - 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
2025-08-31 17:49:09,466 - src.api.main - INFO - 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 17:49:09,474 - src.api.main - INFO - 테스트 StockMaster 데이터 시딩 완료.
2025-08-31 17:49:09,474 - src.api.main - INFO - 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 17:49:09,488 - src.api.main - INFO - 테스트 DailyPrice 데이터 시딩 완료.
------------------------------ Captured log setup ------------------------------
DEBUG    asyncio:selector_events.py:54 Using selector: EpollSelector
INFO     src.api.main:main.py:58 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
INFO     src.api.main:main.py:62 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:77 테스트 StockMaster 데이터 시딩 완료.
INFO     src.api.main:main.py:80 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:106 테스트 DailyPrice 데이터 시딩 완료.
_______________________ test_add_watchlist_invalid_user ________________________

client = <starlette.testclient.TestClient object at 0x7fd24c155990>

    def test_add_watchlist_invalid_user(client: TestClient):
        """
        - **테스트 대상**: `POST /watchlist/add`
        - **목적**: 존재하지 않는 사용자로 관심 종목 추가 시, 404 에러를 반환하는지 확인합니다.
        - **시나리오**:
            1. 존재하지 않는 `user_id`로 추가를 요청합니다.
            2. 404 Not Found 응답을 확인합니다.
        - **Mock 대상**: 없음
        """
        response = client.post("/watchlist/add", json={"user_id": 99999, "symbol": "005930"})
        assert response.status_code == 404
>       assert response.json()["detail"] == "User not found"
E       AssertionError: assert 'Not Found' == 'User not found'
E         
E         - User not found
E         + Not Found

tests/integration/test_api_watchlist_integration.py:105: AssertionError
---------------------------- Captured stdout setup -----------------------------
2025-08-31 17:49:10,389 - asyncio - DEBUG - Using selector: EpollSelector
2025-08-31 17:49:10,400 - src.api.main - INFO - 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
2025-08-31 17:49:10,589 - src.api.main - INFO - 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 17:49:10,597 - src.api.main - INFO - 테스트 StockMaster 데이터 시딩 완료.
2025-08-31 17:49:10,598 - src.api.main - INFO - 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 17:49:10,611 - src.api.main - INFO - 테스트 DailyPrice 데이터 시딩 완료.
------------------------------ Captured log setup ------------------------------
DEBUG    asyncio:selector_events.py:54 Using selector: EpollSelector
INFO     src.api.main:main.py:58 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
INFO     src.api.main:main.py:62 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:77 테스트 StockMaster 데이터 시딩 완료.
INFO     src.api.main:main.py:80 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:106 테스트 DailyPrice 데이터 시딩 완료.
----------------------------- Captured stdout call -----------------------------
2025-08-31 17:49:10,618 - httpx - INFO - HTTP Request: POST http://testserver/watchlist/add "HTTP/1.1 404 Not Found"
------------------------------ Captured log call -------------------------------
INFO     httpx:_client.py:1025 HTTP Request: POST http://testserver/watchlist/add "HTTP/1.1 404 Not Found"
_______________________ test_get_watchlist_invalid_user ________________________

client = <starlette.testclient.TestClient object at 0x7fd24b8986d0>

    def test_get_watchlist_invalid_user(client: TestClient):
        """
        - **테스트 대상**: `GET /watchlist/get/{user_id}`
        - **목적**: 존재하지 않는 사용자로 관심 종목 조회 시, 404 에러를 반환하는지 확인합니다.
        - **시나리오**:
            1. 존재하지 않는 `user_id`로 조회를 요청합니다.
            2. 404 Not Found 응답을 확인합니다.
        - **Mock 대상**: 없음
        """
        response = client.get("/watchlist/get/99999")
        assert response.status_code == 404
>       assert response.json()["detail"] == "User not found"
E       AssertionError: assert 'Not Found' == 'User not found'
E         
E         - User not found
E         + Not Found

tests/integration/test_api_watchlist_integration.py:119: AssertionError
---------------------------- Captured stdout setup -----------------------------
2025-08-31 17:49:10,833 - asyncio - DEBUG - Using selector: EpollSelector
2025-08-31 17:49:10,842 - src.api.main - INFO - 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
2025-08-31 17:49:11,026 - src.api.main - INFO - 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 17:49:11,034 - src.api.main - INFO - 테스트 StockMaster 데이터 시딩 완료.
2025-08-31 17:49:11,034 - src.api.main - INFO - 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 17:49:11,047 - src.api.main - INFO - 테스트 DailyPrice 데이터 시딩 완료.
------------------------------ Captured log setup ------------------------------
DEBUG    asyncio:selector_events.py:54 Using selector: EpollSelector
INFO     src.api.main:main.py:58 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
INFO     src.api.main:main.py:62 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:77 테스트 StockMaster 데이터 시딩 완료.
INFO     src.api.main:main.py:80 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:106 테스트 DailyPrice 데이터 시딩 완료.
----------------------------- Captured stdout call -----------------------------
2025-08-31 17:49:11,052 - httpx - INFO - HTTP Request: GET http://testserver/watchlist/get/99999 "HTTP/1.1 404 Not Found"
------------------------------ Captured log call -------------------------------
INFO     httpx:_client.py:1025 HTTP Request: GET http://testserver/watchlist/get/99999 "HTTP/1.1 404 Not Found"
______________________ test_add_watchlist_invalid_symbol _______________________

client = <starlette.testclient.TestClient object at 0x7fd24c2fa320>
real_db = <sqlalchemy.orm.session.Session object at 0x7fd24c2fb2e0>

    def test_add_watchlist_invalid_symbol(client: TestClient, real_db):
        """
        - **테스트 대상**: `POST /watchlist/add`
        - **목적**: 존재하지 않는 종목 코드로 관심 종목 추가 시, 404 에러를 반환하는지 확인합니다.
        - **시나리오**:
            1. 테스트 사용자를 생성합니다.
            2. 존재하지 않는 `symbol`로 추가를 요청합니다.
            3. 404 Not Found 응답을 확인합니다.
        - **Mock 대상**: 없음
        """
        # Given
>       user = create_test_user(real_db)

tests/integration/test_api_watchlist_integration.py:133: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/helpers.py:14: in create_test_user
    user = User(
<string>:4: in __init__
    ???
/usr/local/lib/python3.10/site-packages/sqlalchemy/orm/state.py:571: in _initialize_instance
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/orm/state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.common.models.user.User object at 0x7fd24b910550>
kwargs = {'email': 'test_dda4f26e3d444cb7afe60577edd0b3a7@example.com', 'is_active': True, 'password_hash': '$2b$12$yhUYQ4VqeJf6MboQcjInj.lTSccxMogUeOIE0GGyj6Mw3vmnc4Pge', 'role': 'user', ...}
cls_ = <class 'src.common.models.user.User'>, k = 'password_hash'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'password_hash' is an invalid keyword argument for User

/usr/local/lib/python3.10/site-packages/sqlalchemy/orm/decl_base.py:2179: TypeError
---------------------------- Captured stdout setup -----------------------------
2025-08-31 17:49:11,236 - asyncio - DEBUG - Using selector: EpollSelector
2025-08-31 17:49:11,250 - src.api.main - INFO - 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
2025-08-31 17:49:11,420 - src.api.main - INFO - 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 17:49:11,427 - src.api.main - INFO - 테스트 StockMaster 데이터 시딩 완료.
2025-08-31 17:49:11,427 - src.api.main - INFO - 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 17:49:11,442 - src.api.main - INFO - 테스트 DailyPrice 데이터 시딩 완료.
------------------------------ Captured log setup ------------------------------
DEBUG    asyncio:selector_events.py:54 Using selector: EpollSelector
INFO     src.api.main:main.py:58 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
INFO     src.api.main:main.py:62 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:77 테스트 StockMaster 데이터 시딩 완료.
INFO     src.api.main:main.py:80 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:106 테스트 DailyPrice 데이터 시딩 완료.
=============================== warnings summary ===============================
../../../usr/local/lib/python3.10/site-packages/pydantic/_internal/_config.py:323
../../../usr/local/lib/python3.10/site-packages/pydantic/_internal/_config.py:323
../../../usr/local/lib/python3.10/site-packages/pydantic/_internal/_config.py:323
  /usr/local/lib/python3.10/site-packages/pydantic/_internal/_config.py:323: PydanticDeprecatedSince20: Support for class-based `config` is deprecated, use ConfigDict instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.11/migration/
    warnings.warn(DEPRECATION_MESSAGE, DeprecationWarning)

../../../usr/local/lib/python3.10/site-packages/pydantic/_internal/_config.py:373
  /usr/local/lib/python3.10/site-packages/pydantic/_internal/_config.py:373: UserWarning: Valid config keys have changed in V2:
  * 'orm_mode' has been renamed to 'from_attributes'
    warnings.warn(message, UserWarning)

main.py:112
  /app/src/api/main.py:112: DeprecationWarning: 
          on_event is deprecated, use lifespan event handlers instead.
  
          Read more about it in the
          [FastAPI docs for Lifespan Events](https://fastapi.tiangolo.com/advanced/events/).
          
    @app.on_event("startup")

../../../usr/local/lib/python3.10/site-packages/fastapi/applications.py:4495
  /usr/local/lib/python3.10/site-packages/fastapi/applications.py:4495: DeprecationWarning: 
          on_event is deprecated, use lifespan event handlers instead.
  
          Read more about it in the
          [FastAPI docs for Lifespan Events](https://fastapi.tiangolo.com/advanced/events/).
          
    return self.router.on_event(event_type)

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
=========================== short test summary info ============================
FAILED tests/integration/test_api_watchlist_integration.py::test_add_and_get_watchlist
FAILED tests/integration/test_api_watchlist_integration.py::test_remove_watchlist_success
FAILED tests/integration/test_api_watchlist_integration.py::test_add_watchlist_duplicate
FAILED tests/integration/test_api_watchlist_integration.py::test_add_watchlist_invalid_user
FAILED tests/integration/test_api_watchlist_integration.py::test_get_watchlist_invalid_user
FAILED tests/integration/test_api_watchlist_integration.py::test_add_watchlist_invalid_symbol
======================== 6 failed, 6 warnings in 6.49s =========================
\n--- Running test_api_user_integration.py ---
============================= test session starts ==============================
platform linux -- Python 3.10.18, pytest-8.4.1, pluggy-1.6.0
rootdir: /app/src/api
plugins: cov-6.2.1, timeout-2.4.0, anyio-4.10.0, asyncio-1.1.0
asyncio: mode=strict, asyncio_default_fixture_loop_scope=None, asyncio_default_test_loop_scope=function
collected 11 items

tests/integration/test_api_user_integration.py 
\n--- Running test_api_user_integration.py (60s timeout) ---
============================= test session starts ==============================
platform linux -- Python 3.10.18, pytest-8.4.1, pluggy-1.6.0
rootdir: /app/src/api
plugins: cov-6.2.1, timeout-2.4.0, anyio-4.10.0, asyncio-1.1.0
asyncio: mode=strict, asyncio_default_fixture_loop_scope=None, asyncio_default_test_loop_scope=function
collected 11 items

tests/integration/test_api_user_integration.py .FFFF.F.FFF               [100%]

=================================== FAILURES ===================================
____________________ test_register_user_duplicate_username _____________________

client = <starlette.testclient.TestClient object at 0x7f0f7e9e1540>
real_db = <sqlalchemy.orm.session.Session object at 0x7f0f604c2410>

    def test_register_user_duplicate_username(client: TestClient, real_db: Session):
        """
        - **테스트 대상**: `POST /api/v1/users/register`
        - **목적**: 이미 존재하는 사용자 이름으로 가입 시도 시, 400 에러를 반환하는지 확인합니다.
        - **시나리오**:
            1. 테스트 사용자를 미리 생성합니다.
            2. 동일한 사용자 이름으로 다시 가입을 요청합니다.
            3. 400 Bad Request 응답과 함께, 중복 가입 오류 메시지가 반환되는지 확인합니다.
        - **Mock 대상**: 없음
        """
        # Given
>       user = create_test_user(real_db)

tests/integration/test_api_user_integration.py:58: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/helpers.py:14: in create_test_user
    user = User(
<string>:4: in __init__
    ???
/usr/local/lib/python3.10/site-packages/sqlalchemy/orm/state.py:571: in _initialize_instance
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/orm/state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.common.models.user.User object at 0x7f0f605a69b0>
kwargs = {'email': 'test_e3c1d79859e54849a131481168f108c2@example.com', 'is_active': True, 'password_hash': '$2b$12$9x4VcdwivC6fqEMaa9QbmeKyScQP2nm.siLGF6PuF9P9ixb3CQh3C', 'role': 'user', ...}
cls_ = <class 'src.common.models.user.User'>, k = 'password_hash'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'password_hash' is an invalid keyword argument for User

/usr/local/lib/python3.10/site-packages/sqlalchemy/orm/decl_base.py:2179: TypeError
---------------------------- Captured stdout setup -----------------------------
2025-08-31 17:50:17,095 - asyncio - DEBUG - Using selector: EpollSelector
2025-08-31 17:50:17,104 - src.api.main - INFO - 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
2025-08-31 17:50:17,274 - src.api.main - INFO - 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 17:50:17,281 - src.api.main - INFO - 테스트 StockMaster 데이터 시딩 완료.
2025-08-31 17:50:17,281 - src.api.main - INFO - 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 17:50:17,294 - src.api.main - INFO - 테스트 DailyPrice 데이터 시딩 완료.
------------------------------ Captured log setup ------------------------------
DEBUG    asyncio:selector_events.py:54 Using selector: EpollSelector
INFO     src.api.main:main.py:58 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
INFO     src.api.main:main.py:62 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:77 테스트 StockMaster 데이터 시딩 완료.
INFO     src.api.main:main.py:80 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:106 테스트 DailyPrice 데이터 시딩 완료.
___________________________ test_login_user_success ____________________________

client = <starlette.testclient.TestClient object at 0x7f0f5fb8a230>
real_db = <sqlalchemy.orm.session.Session object at 0x7f0f5fb8ba00>

    def test_login_user_success(client: TestClient, real_db: Session):
        """
        - **테스트 대상**: `POST /api/v1/users/login`
        - **목적**: 올바른 정보로 로그인 시, 성공적으로 JWT 토큰을 발급받는지 확인합니다.
        - **시나리오**:
            1. 테스트 사용자를 생성합니다.
            2. 해당 사용자의 정보로 로그인을 요청합니다.
            3. 200 OK 응답과 함께, `access_token`과 `token_type`이 포함된 응답을 확인합니다.
        - **Mock 대상**: 없음
        """
        # Given
>       user = create_test_user(real_db)

tests/integration/test_api_user_integration.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/helpers.py:14: in create_test_user
    user = User(
<string>:4: in __init__
    ???
/usr/local/lib/python3.10/site-packages/sqlalchemy/orm/state.py:571: in _initialize_instance
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/orm/state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.common.models.user.User object at 0x7f0f604f30d0>
kwargs = {'email': 'test_87eb346fd17b4721980cbeab33835195@example.com', 'is_active': True, 'password_hash': '$2b$12$PAQB7WRg6tW1aYT4rqy61.mX0/GwwXTs2zb87NmnmhCFIudcfEyfe', 'role': 'user', ...}
cls_ = <class 'src.common.models.user.User'>, k = 'password_hash'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'password_hash' is an invalid keyword argument for User

/usr/local/lib/python3.10/site-packages/sqlalchemy/orm/decl_base.py:2179: TypeError
---------------------------- Captured stdout setup -----------------------------
2025-08-31 17:50:18,183 - asyncio - DEBUG - Using selector: EpollSelector
2025-08-31 17:50:18,191 - src.api.main - INFO - 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
2025-08-31 17:50:18,360 - src.api.main - INFO - 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 17:50:18,367 - src.api.main - INFO - 테스트 StockMaster 데이터 시딩 완료.
2025-08-31 17:50:18,367 - src.api.main - INFO - 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 17:50:18,379 - src.api.main - INFO - 테스트 DailyPrice 데이터 시딩 완료.
------------------------------ Captured log setup ------------------------------
DEBUG    asyncio:selector_events.py:54 Using selector: EpollSelector
INFO     src.api.main:main.py:58 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
INFO     src.api.main:main.py:62 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:77 테스트 StockMaster 데이터 시딩 완료.
INFO     src.api.main:main.py:80 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:106 테스트 DailyPrice 데이터 시딩 완료.
________________________ test_login_user_wrong_password ________________________

client = <starlette.testclient.TestClient object at 0x7f0f5fbe1f90>
real_db = <sqlalchemy.orm.session.Session object at 0x7f0f5fbe15d0>

    def test_login_user_wrong_password(client: TestClient, real_db: Session):
        """
        - **테스트 대상**: `POST /api/v1/users/login`
        - **목적**: 틀린 비밀번호로 로그인 시, 401 에러를 반환하는지 확인합니다.
        - **시나리오**:
            1. 테스트 사용자를 생성합니다.
            2. 틀린 비밀번호로 로그인을 요청합니다.
            3. 401 Unauthorized 응답을 확인합니다.
        - **Mock 대상**: 없음
        """
        # Given
>       user = create_test_user(real_db)

tests/integration/test_api_user_integration.py:101: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/helpers.py:14: in create_test_user
    user = User(
<string>:4: in __init__
    ???
/usr/local/lib/python3.10/site-packages/sqlalchemy/orm/state.py:571: in _initialize_instance
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/orm/state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.common.models.user.User object at 0x7f0f5fbe2890>
kwargs = {'email': 'test_011047ae67ee423a8f0be7337fc8fe67@example.com', 'is_active': True, 'password_hash': '$2b$12$PhgDTgFECoGWQP4FojYKb.yMFB1qE6MJ.In4xlaVTWbxvaofDPEbO', 'role': 'user', ...}
cls_ = <class 'src.common.models.user.User'>, k = 'password_hash'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'password_hash' is an invalid keyword argument for User

/usr/local/lib/python3.10/site-packages/sqlalchemy/orm/decl_base.py:2179: TypeError
---------------------------- Captured stdout setup -----------------------------
2025-08-31 17:50:19,016 - asyncio - DEBUG - Using selector: EpollSelector
2025-08-31 17:50:19,030 - src.api.main - INFO - 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
2025-08-31 17:50:19,208 - src.api.main - INFO - 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 17:50:19,215 - src.api.main - INFO - 테스트 StockMaster 데이터 시딩 완료.
2025-08-31 17:50:19,215 - src.api.main - INFO - 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 17:50:19,227 - src.api.main - INFO - 테스트 DailyPrice 데이터 시딩 완료.
------------------------------ Captured log setup ------------------------------
DEBUG    asyncio:selector_events.py:54 Using selector: EpollSelector
INFO     src.api.main:main.py:58 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
INFO     src.api.main:main.py:62 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:77 테스트 StockMaster 데이터 시딩 완료.
INFO     src.api.main:main.py:80 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:106 테스트 DailyPrice 데이터 시딩 완료.
_____________________________ test_get_me_success ______________________________

client = <starlette.testclient.TestClient object at 0x7f0f605a70d0>
real_db = <sqlalchemy.orm.session.Session object at 0x7f0f7bbe2a40>

    def test_get_me_success(client: TestClient, real_db: Session):
        """
        - **테스트 대상**: `GET /api/v1/users/me`
        - **목적**: 인증된 사용자가 자신의 정보를 성공적으로 조회하는지 확인합니다.
        - **시나리오**:
            1. 테스트 사용자를 생성하고 인증 헤더를 발급받습니다.
            2. `/me` 엔드포인트를 호출합니다.
            3. 200 OK 응답과 함께, 자신의 사용자 정보가 반환되는지 확인합니다.
        - **Mock 대상**: 없음
        """
        # Given
>       user = create_test_user(real_db)

tests/integration/test_api_user_integration.py:122: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/helpers.py:14: in create_test_user
    user = User(
<string>:4: in __init__
    ???
/usr/local/lib/python3.10/site-packages/sqlalchemy/orm/state.py:571: in _initialize_instance
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/orm/state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.common.models.user.User object at 0x7f0f605a7310>
kwargs = {'email': 'test_d15f79b516e645f198d1e310240db1d0@example.com', 'is_active': True, 'password_hash': '$2b$12$mzus9WNVDd2pKqjURuhSEejG1C3H9ZPvoKSSpoEbnYfFQI/SABSw.', 'role': 'user', ...}
cls_ = <class 'src.common.models.user.User'>, k = 'password_hash'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'password_hash' is an invalid keyword argument for User

/usr/local/lib/python3.10/site-packages/sqlalchemy/orm/decl_base.py:2179: TypeError
---------------------------- Captured stdout setup -----------------------------
2025-08-31 17:50:20,084 - asyncio - DEBUG - Using selector: EpollSelector
2025-08-31 17:50:20,099 - src.api.main - INFO - 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
2025-08-31 17:50:20,295 - src.api.main - INFO - 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 17:50:20,303 - src.api.main - INFO - 테스트 StockMaster 데이터 시딩 완료.
2025-08-31 17:50:20,304 - src.api.main - INFO - 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 17:50:20,315 - src.api.main - INFO - 테스트 DailyPrice 데이터 시딩 완료.
------------------------------ Captured log setup ------------------------------
DEBUG    asyncio:selector_events.py:54 Using selector: EpollSelector
INFO     src.api.main:main.py:58 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
INFO     src.api.main:main.py:62 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:77 테스트 StockMaster 데이터 시딩 완료.
INFO     src.api.main:main.py:80 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:106 테스트 DailyPrice 데이터 시딩 완료.
____________________________ test_update_me_success ____________________________

client = <starlette.testclient.TestClient object at 0x7f0f604c1b10>
real_db = <sqlalchemy.orm.session.Session object at 0x7f0f604c25c0>

    def test_update_me_success(client: TestClient, real_db: Session):
        """
        - **테스트 대상**: `PUT /api/v1/users/me`
        - **목적**: 인증된 사용자가 자신의 정보를 성공적으로 수정하는지 확인합니다.
        - **시나리오**:
            1. 테스트 사용자를 생성하고 인증 헤더를 발급받습니다.
            2. 새로운 이메일 주소를 포함하여 수정 API를 호출합니다.
            3. 200 OK 응답과 함께, 이메일이 수정된 사용자 정보가 반환되는지 확인합니다.
        - **Mock 대상**: 없음
        """
        # Given
>       user = create_test_user(real_db)

tests/integration/test_api_user_integration.py:158: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/helpers.py:14: in create_test_user
    user = User(
<string>:4: in __init__
    ???
/usr/local/lib/python3.10/site-packages/sqlalchemy/orm/state.py:571: in _initialize_instance
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/orm/state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.common.models.user.User object at 0x7f0f604c1c00>
kwargs = {'email': 'test_18c2da5dbd6043b4852c72764598b306@example.com', 'is_active': True, 'password_hash': '$2b$12$QqsMkPVfw0ZZ.PtX2/jT4u7XDpxkNz6lMB5OoOxMGD1Kda4G2BtOm', 'role': 'user', ...}
cls_ = <class 'src.common.models.user.User'>, k = 'password_hash'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'password_hash' is an invalid keyword argument for User

/usr/local/lib/python3.10/site-packages/sqlalchemy/orm/decl_base.py:2179: TypeError
---------------------------- Captured stdout setup -----------------------------
2025-08-31 17:50:21,371 - asyncio - DEBUG - Using selector: EpollSelector
2025-08-31 17:50:21,385 - src.api.main - INFO - 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
2025-08-31 17:50:21,586 - src.api.main - INFO - 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 17:50:21,593 - src.api.main - INFO - 테스트 StockMaster 데이터 시딩 완료.
2025-08-31 17:50:21,593 - src.api.main - INFO - 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 17:50:21,605 - src.api.main - INFO - 테스트 DailyPrice 데이터 시딩 완료.
------------------------------ Captured log setup ------------------------------
DEBUG    asyncio:selector_events.py:54 Using selector: EpollSelector
INFO     src.api.main:main.py:58 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
INFO     src.api.main:main.py:62 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:77 테스트 StockMaster 데이터 시딩 완료.
INFO     src.api.main:main.py:80 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:106 테스트 DailyPrice 데이터 시딩 완료.
_________________________ test_get_user_stats_success __________________________

client = <starlette.testclient.TestClient object at 0x7f0f60653940>
real_db = <sqlalchemy.orm.session.Session object at 0x7f0f60653130>

    def test_get_user_stats_success(client: TestClient, real_db: Session):
        """
        - **테스트 대상**: `GET /api/v1/users/stats/{user_id}`
        - **목적**: 특정 사용자의 통계 정보를 성공적으로 조회하는지 확인합니다.
        - **시나리오**:
            1. 테스트 사용자를 생성합니다.
            2. 해당 사용자의 ID로 통계 조회 API를 호출합니다.
            3. 200 OK 응답과 함께, `trade_count` 등의 통계 정보가 포함된 응답을 확인합니다.
        - **Mock 대상**: 없음
        """
        # Given
>       user = create_test_user(real_db)

tests/integration/test_api_user_integration.py:207: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/helpers.py:14: in create_test_user
    user = User(
<string>:4: in __init__
    ???
/usr/local/lib/python3.10/site-packages/sqlalchemy/orm/state.py:571: in _initialize_instance
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/orm/state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.common.models.user.User object at 0x7f0f5fbe3e20>
kwargs = {'email': 'test_ba85130dd79e4458a3e642ee8007dfc1@example.com', 'is_active': True, 'password_hash': '$2b$12$DrxrDjOPZN6Xp2MSMx6YSOjuv3MMlC2BIgd0xHNKdxraNvVKvgeAC', 'role': 'user', ...}
cls_ = <class 'src.common.models.user.User'>, k = 'password_hash'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'password_hash' is an invalid keyword argument for User

/usr/local/lib/python3.10/site-packages/sqlalchemy/orm/decl_base.py:2179: TypeError
---------------------------- Captured stdout setup -----------------------------
2025-08-31 17:50:22,904 - asyncio - DEBUG - Using selector: EpollSelector
2025-08-31 17:50:22,922 - src.api.main - INFO - 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
2025-08-31 17:50:23,145 - src.api.main - INFO - 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 17:50:23,152 - src.api.main - INFO - 테스트 StockMaster 데이터 시딩 완료.
2025-08-31 17:50:23,153 - src.api.main - INFO - 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 17:50:23,163 - src.api.main - INFO - 테스트 DailyPrice 데이터 시딩 완료.
------------------------------ Captured log setup ------------------------------
DEBUG    asyncio:selector_events.py:54 Using selector: EpollSelector
INFO     src.api.main:main.py:58 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
INFO     src.api.main:main.py:62 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:77 테스트 StockMaster 데이터 시딩 완료.
INFO     src.api.main:main.py:80 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:106 테스트 DailyPrice 데이터 시딩 완료.
_________________________ test_get_all_users_as_admin __________________________

client = <starlette.testclient.TestClient object at 0x7f0f5fb8bd60>
real_db = <sqlalchemy.orm.session.Session object at 0x7f0f5fb8b9d0>

    def test_get_all_users_as_admin(client: TestClient, real_db: Session):
        """
        - **테스트 대상**: `GET /api/v1/users/`
        - **목적**: 관리자 권한으로 모든 사용자 목록을 조회하는 기능을 확인합니다.
        - **시나리오**:
            1. 관리자 사용자를 포함하여 여러 사용자를 생성합니다.
            2. 관리자 인증 헤더로 사용자 목록 API를 호출합니다.
            3. 200 OK 응답과 함께, 생성된 사용자들이 포함된 목록이 반환되는지 확인합니다.
        - **Mock 대상**: 없음
        """
        # Given
>       admin_user = create_test_user(real_db, role="admin")

tests/integration/test_api_user_integration.py:229: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/helpers.py:14: in create_test_user
    user = User(
<string>:4: in __init__
    ???
/usr/local/lib/python3.10/site-packages/sqlalchemy/orm/state.py:571: in _initialize_instance
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/orm/state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.common.models.user.User object at 0x7f0f5fbe2800>
kwargs = {'email': 'test_ae5e5023d39c42d3ac7599894e5cf562@example.com', 'is_active': True, 'password_hash': '$2b$12$At5Z7IY.DW93GIvvvkpGg.mNHhARPSRCHUl07dXieH6xAF1DAG0YW', 'role': 'admin', ...}
cls_ = <class 'src.common.models.user.User'>, k = 'password_hash'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'password_hash' is an invalid keyword argument for User

/usr/local/lib/python3.10/site-packages/sqlalchemy/orm/decl_base.py:2179: TypeError
---------------------------- Captured stdout setup -----------------------------
2025-08-31 17:50:23,831 - asyncio - DEBUG - Using selector: EpollSelector
2025-08-31 17:50:23,842 - src.api.main - INFO - 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
2025-08-31 17:50:24,024 - src.api.main - INFO - 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 17:50:24,033 - src.api.main - INFO - 테스트 StockMaster 데이터 시딩 완료.
2025-08-31 17:50:24,034 - src.api.main - INFO - 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 17:50:24,048 - src.api.main - INFO - 테스트 DailyPrice 데이터 시딩 완료.
------------------------------ Captured log setup ------------------------------
DEBUG    asyncio:selector_events.py:54 Using selector: EpollSelector
INFO     src.api.main:main.py:58 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
INFO     src.api.main:main.py:62 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:77 테스트 StockMaster 데이터 시딩 완료.
INFO     src.api.main:main.py:80 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:106 테스트 DailyPrice 데이터 시딩 완료.
__________________________ test_get_all_users_as_user __________________________

client = <starlette.testclient.TestClient object at 0x7f0f5fbe37c0>
real_db = <sqlalchemy.orm.session.Session object at 0x7f0f5fbe2410>

    def test_get_all_users_as_user(client: TestClient, real_db: Session):
        """
        - **테스트 대상**: `GET /api/v1/users/`
        - **목적**: 일반 사용자가 전체 사용자 목록 조회 시, 403 에러를 받는지 확인합니다.
        - **시나리오**:
            1. 일반 사용자를 생성하고 인증 헤더를 발급받습니다.
            2. 사용자 목록 API를 호출합니다.
            3. 403 Forbidden 응답을 확인합니다.
        - **Mock 대상**: 없음
        """
        # Given
>       user = create_test_user(real_db, role="user")

tests/integration/test_api_user_integration.py:251: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/helpers.py:14: in create_test_user
    user = User(
<string>:4: in __init__
    ???
/usr/local/lib/python3.10/site-packages/sqlalchemy/orm/state.py:571: in _initialize_instance
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/orm/state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.common.models.user.User object at 0x7f0f5fbe1570>
kwargs = {'email': 'test_d9bd898653ac4d0ba50304e2bd079d68@example.com', 'is_active': True, 'password_hash': '$2b$12$UOKvgt55oRGYcrE7Xhi0DevZ.aoYp2/dRl/iCioG0ufsq2DRJ5K0a', 'role': 'user', ...}
cls_ = <class 'src.common.models.user.User'>, k = 'password_hash'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'password_hash' is an invalid keyword argument for User

/usr/local/lib/python3.10/site-packages/sqlalchemy/orm/decl_base.py:2179: TypeError
---------------------------- Captured stdout setup -----------------------------
2025-08-31 17:50:24,670 - asyncio - DEBUG - Using selector: EpollSelector
2025-08-31 17:50:24,696 - src.api.main - INFO - 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
2025-08-31 17:50:24,881 - src.api.main - INFO - 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 17:50:24,889 - src.api.main - INFO - 테스트 StockMaster 데이터 시딩 완료.
2025-08-31 17:50:24,890 - src.api.main - INFO - 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 17:50:24,907 - src.api.main - INFO - 테스트 DailyPrice 데이터 시딩 완료.
------------------------------ Captured log setup ------------------------------
DEBUG    asyncio:selector_events.py:54 Using selector: EpollSelector
INFO     src.api.main:main.py:58 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
INFO     src.api.main:main.py:62 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:77 테스트 StockMaster 데이터 시딩 완료.
INFO     src.api.main:main.py:80 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:106 테스트 DailyPrice 데이터 시딩 완료.
=============================== warnings summary ===============================
../../../usr/local/lib/python3.10/site-packages/pydantic/_internal/_config.py:323
../../../usr/local/lib/python3.10/site-packages/pydantic/_internal/_config.py:323
../../../usr/local/lib/python3.10/site-packages/pydantic/_internal/_config.py:323
  /usr/local/lib/python3.10/site-packages/pydantic/_internal/_config.py:323: PydanticDeprecatedSince20: Support for class-based `config` is deprecated, use ConfigDict instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.11/migration/
    warnings.warn(DEPRECATION_MESSAGE, DeprecationWarning)

../../../usr/local/lib/python3.10/site-packages/pydantic/_internal/_config.py:373
  /usr/local/lib/python3.10/site-packages/pydantic/_internal/_config.py:373: UserWarning: Valid config keys have changed in V2:
  * 'orm_mode' has been renamed to 'from_attributes'
    warnings.warn(message, UserWarning)

main.py:112
  /app/src/api/main.py:112: DeprecationWarning: 
          on_event is deprecated, use lifespan event handlers instead.
  
          Read more about it in the
          [FastAPI docs for Lifespan Events](https://fastapi.tiangolo.com/advanced/events/).
          
    @app.on_event("startup")

../../../usr/local/lib/python3.10/site-packages/fastapi/applications.py:4495
  /usr/local/lib/python3.10/site-packages/fastapi/applications.py:4495: DeprecationWarning: 
          on_event is deprecated, use lifespan event handlers instead.
  
          Read more about it in the
          [FastAPI docs for Lifespan Events](https://fastapi.tiangolo.com/advanced/events/).
          
    return self.router.on_event(event_type)

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
=========================== short test summary info ============================
FAILED tests/integration/test_api_user_integration.py::test_register_user_duplicate_username
FAILED tests/integration/test_api_user_integration.py::test_login_user_success
FAILED tests/integration/test_api_user_integration.py::test_login_user_wrong_password
FAILED tests/integration/test_api_user_integration.py::test_get_me_success - ...
FAILED tests/integration/test_api_user_integration.py::test_update_me_success
FAILED tests/integration/test_api_user_integration.py::test_get_user_stats_success
FAILED tests/integration/test_api_user_integration.py::test_get_all_users_as_admin
FAILED tests/integration/test_api_user_integration.py::test_get_all_users_as_user
=================== 8 failed, 3 passed, 6 warnings in 11.48s ===================
\n--- Running test_api_stock_master_integration.py ---
============================= test session starts ==============================
platform linux -- Python 3.10.18, pytest-8.4.1, pluggy-1.6.0
rootdir: /app/src/api
plugins: cov-6.2.1, timeout-2.4.0, anyio-4.10.0, asyncio-1.1.0
asyncio: mode=strict, asyncio_default_fixture_loop_scope=None, asyncio_default_test_loop_scope=function
collected 8 items

tests/integration/test_api_stock_master_integration.py FFFFFFEE          [100%]

==================================== ERRORS ====================================
_ ERROR at setup of TestStockMasterRouter.test_get_current_price_and_change_success _
file /app/src/api/tests/integration/test_api_stock_master_integration.py, line 150
      def test_get_current_price_and_change_success(self, client: TestClient, override_stock_service_dependencies, real_db: Session):
E       fixture 'override_stock_service_dependencies' not found
>       available fixtures: _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _session_scoped_runner, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, client, cov, db_engine, doctest_namespace, event_loop_policy, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, monkeypatch, no_cover, pytestconfig, real_db, record_property, record_testsuite_property, record_xml_attribute, recwarn, setup_method, test_stock_master_data, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory
>       use 'pytest --fixtures [testpath]' for help on them.

/app/src/api/tests/integration/test_api_stock_master_integration.py:150
---------------------------- Captured stdout setup -----------------------------
2025-08-31 17:50:37,922 - asyncio - DEBUG - Using selector: EpollSelector
2025-08-31 17:50:37,934 - src.api.main - INFO - 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
2025-08-31 17:50:38,080 - src.api.main - INFO - 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 17:50:38,087 - src.api.main - INFO - 테스트 StockMaster 데이터 시딩 완료.
2025-08-31 17:50:38,087 - src.api.main - INFO - 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 17:50:38,097 - src.api.main - INFO - 테스트 DailyPrice 데이터 시딩 완료.
------------------------------ Captured log setup ------------------------------
DEBUG    asyncio:selector_events.py:54 Using selector: EpollSelector
INFO     src.api.main:main.py:58 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
INFO     src.api.main:main.py:62 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:77 테스트 StockMaster 데이터 시딩 완료.
INFO     src.api.main:main.py:80 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:106 테스트 DailyPrice 데이터 시딩 완료.
_ ERROR at setup of TestStockMasterRouter.test_get_current_price_and_change_not_found _
file /app/src/api/tests/integration/test_api_stock_master_integration.py, line 173
      def test_get_current_price_and_change_not_found(self, client: TestClient, override_stock_service_dependencies, real_db: Session):
E       fixture 'override_stock_service_dependencies' not found
>       available fixtures: _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _session_scoped_runner, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, client, cov, db_engine, doctest_namespace, event_loop_policy, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, monkeypatch, no_cover, pytestconfig, real_db, record_property, record_testsuite_property, record_xml_attribute, recwarn, setup_method, test_stock_master_data, test_user, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory
>       use 'pytest --fixtures [testpath]' for help on them.

/app/src/api/tests/integration/test_api_stock_master_integration.py:173
---------------------------- Captured stdout setup -----------------------------
2025-08-31 17:50:38,273 - asyncio - DEBUG - Using selector: EpollSelector
2025-08-31 17:50:38,283 - src.api.main - INFO - 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
2025-08-31 17:50:38,472 - src.api.main - INFO - 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 17:50:38,480 - src.api.main - INFO - 테스트 StockMaster 데이터 시딩 완료.
2025-08-31 17:50:38,480 - src.api.main - INFO - 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 17:50:38,493 - src.api.main - INFO - 테스트 DailyPrice 데이터 시딩 완료.
------------------------------ Captured log setup ------------------------------
DEBUG    asyncio:selector_events.py:54 Using selector: EpollSelector
INFO     src.api.main:main.py:58 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
INFO     src.api.main:main.py:62 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:77 테스트 StockMaster 데이터 시딩 완료.
INFO     src.api.main:main.py:80 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:106 테스트 DailyPrice 데이터 시딩 완료.
=================================== FAILURES ===================================
__________________ TestStockMasterRouter.test_get_all_symbols __________________

self = <test_api_stock_master_integration.TestStockMasterRouter object at 0x7f345fca2ce0>
client = <starlette.testclient.TestClient object at 0x7f345fc8af80>
test_stock_master_data = [<src.common.models.stock_master.StockMaster object at 0x7f345fc8a230>, <src.common.models.stock_master.StockMaster ob...ster.StockMaster object at 0x7f345fbb3b80>, <src.common.models.stock_master.StockMaster object at 0x7f345fbb3a00>, ...]

    def test_get_all_symbols(self, client: TestClient, test_stock_master_data):
        """
        - **테스트 대상**: `GET /symbols/`
        - **목적**: 전체 종목 목록을 정상적으로 조회하는지 확인합니다.
        - **시나리오**:
            1. `test_stock_master_data` fixture를 통해 DB에 5개의 종목을 생성합니다.
            2. 전체 목록 조회 API를 호출합니다.
            3. 200 OK 응답과 함께, 5개의 종목 정보가 포함된 목록이 반환되는지 확인합니다.
        - **Mock 대상**: 없음 (DB 직접 사용)
        """
        # When
        response = client.get("/symbols/")
    
        # Then
>       assert response.status_code == 200
E       assert 404 == 200
E        +  where 404 = <Response [404 Not Found]>.status_code

tests/integration/test_api_stock_master_integration.py:54: AssertionError
---------------------------- Captured stdout setup -----------------------------
2025-08-31 17:50:35,024 - asyncio - DEBUG - Using selector: EpollSelector
2025-08-31 17:50:35,054 - src.api.main - INFO - 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
2025-08-31 17:50:35,242 - src.api.main - INFO - 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 17:50:35,253 - src.api.main - INFO - 테스트 StockMaster 데이터 시딩 완료.
2025-08-31 17:50:35,253 - src.api.main - INFO - 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 17:50:35,270 - src.api.main - INFO - 테스트 DailyPrice 데이터 시딩 완료.
------------------------------ Captured log setup ------------------------------
DEBUG    asyncio:selector_events.py:54 Using selector: EpollSelector
INFO     src.api.main:main.py:58 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
INFO     src.api.main:main.py:62 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:77 테스트 StockMaster 데이터 시딩 완료.
INFO     src.api.main:main.py:80 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:106 테스트 DailyPrice 데이터 시딩 완료.
----------------------------- Captured stdout call -----------------------------
2025-08-31 17:50:35,304 - httpx - INFO - HTTP Request: GET http://testserver/symbols/ "HTTP/1.1 404 Not Found"
------------------------------ Captured log call -------------------------------
INFO     httpx:_client.py:1025 HTTP Request: GET http://testserver/symbols/ "HTTP/1.1 404 Not Found"
_______________ TestStockMasterRouter.test_get_all_symbols_empty _______________

self = <test_api_stock_master_integration.TestStockMasterRouter object at 0x7f345fca2d70>
client = <starlette.testclient.TestClient object at 0x7f345fc8a4d0>

    def test_get_all_symbols_empty(self, client: TestClient):
        """
        - **테스트 대상**: `GET /symbols/`
        - **목적**: DB에 종목 정보가 없을 때, 빈 목록을 정상적으로 반환하는지 확인합니다.
        - **시나리오**:
            1. `setup_method` fixture가 DB를 비웁니다.
            2. 전체 목록 조회 API를 호출합니다.
            3. 200 OK 응답과 함께, `total_count`가 0인 빈 목록이 반환되는지 확인합니다.
        - **Mock 대상**: 없음
        """
        # When
        response = client.get("/symbols/")
    
        # Then
>       assert response.status_code == 200
E       assert 404 == 200
E        +  where 404 = <Response [404 Not Found]>.status_code

tests/integration/test_api_stock_master_integration.py:74: AssertionError
---------------------------- Captured stdout setup -----------------------------
2025-08-31 17:50:35,668 - asyncio - DEBUG - Using selector: EpollSelector
2025-08-31 17:50:35,681 - src.api.main - INFO - 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
2025-08-31 17:50:35,918 - src.api.main - INFO - 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 17:50:35,924 - src.api.main - INFO - 테스트 StockMaster 데이터 시딩 완료.
2025-08-31 17:50:35,925 - src.api.main - INFO - 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 17:50:35,938 - src.api.main - INFO - 테스트 DailyPrice 데이터 시딩 완료.
------------------------------ Captured log setup ------------------------------
DEBUG    asyncio:selector_events.py:54 Using selector: EpollSelector
INFO     src.api.main:main.py:58 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
INFO     src.api.main:main.py:62 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:77 테스트 StockMaster 데이터 시딩 완료.
INFO     src.api.main:main.py:80 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:106 테스트 DailyPrice 데이터 시딩 완료.
----------------------------- Captured stdout call -----------------------------
2025-08-31 17:50:35,942 - httpx - INFO - HTTP Request: GET http://testserver/symbols/ "HTTP/1.1 404 Not Found"
------------------------------ Captured log call -------------------------------
INFO     httpx:_client.py:1025 HTTP Request: GET http://testserver/symbols/ "HTTP/1.1 404 Not Found"
______________ TestStockMasterRouter.test_search_symbols_by_name _______________

self = <test_api_stock_master_integration.TestStockMasterRouter object at 0x7f345fca2fb0>
client = <starlette.testclient.TestClient object at 0x7f345fbb33a0>
test_stock_master_data = [<src.common.models.stock_master.StockMaster object at 0x7f345fbb02e0>, <src.common.models.stock_master.StockMaster ob...ster.StockMaster object at 0x7f345f28a740>, <src.common.models.stock_master.StockMaster object at 0x7f345f28a2f0>, ...]

    def test_search_symbols_by_name(self, client: TestClient, test_stock_master_data):
        """
        - **테스트 대상**: `GET /symbols/search`
        - **목적**: 종목명으로 종목을 검색하는 기능이 정상적으로 동작하는지 확인합니다.
        - **시나리오**:
            1. `test_stock_master_data` fixture로 테스트 데이터를 준비합니다.
            2. `query` 파라미터에 "삼성전자"를 넣어 검색 API를 호출합니다.
            3. 200 OK 응답과 함께, 삼성전자 종목 정보 1건이 반환되는지 확인합니다.
        - **Mock 대상**: 없음
        """
        # When
        response = client.get("/symbols/search?query=삼성전자")
    
        # Then
>       assert response.status_code == 200
E       assert 404 == 200
E        +  where 404 = <Response [404 Not Found]>.status_code

tests/integration/test_api_stock_master_integration.py:93: AssertionError
---------------------------- Captured stdout setup -----------------------------
2025-08-31 17:50:36,139 - asyncio - DEBUG - Using selector: EpollSelector
2025-08-31 17:50:36,154 - src.api.main - INFO - 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
2025-08-31 17:50:36,322 - src.api.main - INFO - 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 17:50:36,327 - src.api.main - INFO - 테스트 StockMaster 데이터 시딩 완료.
2025-08-31 17:50:36,328 - src.api.main - INFO - 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 17:50:36,338 - src.api.main - INFO - 테스트 DailyPrice 데이터 시딩 완료.
------------------------------ Captured log setup ------------------------------
DEBUG    asyncio:selector_events.py:54 Using selector: EpollSelector
INFO     src.api.main:main.py:58 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
INFO     src.api.main:main.py:62 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:77 테스트 StockMaster 데이터 시딩 완료.
INFO     src.api.main:main.py:80 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:106 테스트 DailyPrice 데이터 시딩 완료.
----------------------------- Captured stdout call -----------------------------
2025-08-31 17:50:36,362 - httpx - INFO - HTTP Request: GET http://testserver/symbols/search?query=%EC%82%BC%EC%84%B1%EC%A0%84%EC%9E%90 "HTTP/1.1 404 Not Found"
------------------------------ Captured log call -------------------------------
INFO     httpx:_client.py:1025 HTTP Request: GET http://testserver/symbols/search?query=%EC%82%BC%EC%84%B1%EC%A0%84%EC%9E%90 "HTTP/1.1 404 Not Found"
_____________ TestStockMasterRouter.test_search_symbols_by_symbol ______________

self = <test_api_stock_master_integration.TestStockMasterRouter object at 0x7f345fca2b90>
client = <starlette.testclient.TestClient object at 0x7f345f204df0>
test_stock_master_data = [<src.common.models.stock_master.StockMaster object at 0x7f345fbb0370>, <src.common.models.stock_master.StockMaster ob...ster.StockMaster object at 0x7f345fbb0460>, <src.common.models.stock_master.StockMaster object at 0x7f345fbb0040>, ...]

    def test_search_symbols_by_symbol(self, client: TestClient, test_stock_master_data):
        """
        - **테스트 대상**: `GET /symbols/search`
        - **목적**: 종목 코드로 종목을 검색하는 기능이 정상적으로 동작하는지 확인합니다.
        - **시나리오**:
            1. `test_stock_master_data` fixture로 테스트 데이터를 준비합니다.
            2. `query` 파라미터에 "035720"(카카오)를 넣어 검색 API를 호출합니다.
            3. 200 OK 응답과 함께, 카카오 종목 정보 1건이 반환되는지 확인합니다.
        - **Mock 대상**: 없음
        """
        # When
        response = client.get("/symbols/search?query=035720")
    
        # Then
>       assert response.status_code == 200
E       assert 404 == 200
E        +  where 404 = <Response [404 Not Found]>.status_code

tests/integration/test_api_stock_master_integration.py:112: AssertionError
---------------------------- Captured stdout setup -----------------------------
2025-08-31 17:50:36,556 - asyncio - DEBUG - Using selector: EpollSelector
2025-08-31 17:50:36,568 - src.api.main - INFO - 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
2025-08-31 17:50:36,741 - src.api.main - INFO - 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 17:50:36,748 - src.api.main - INFO - 테스트 StockMaster 데이터 시딩 완료.
2025-08-31 17:50:36,749 - src.api.main - INFO - 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 17:50:36,760 - src.api.main - INFO - 테스트 DailyPrice 데이터 시딩 완료.
------------------------------ Captured log setup ------------------------------
DEBUG    asyncio:selector_events.py:54 Using selector: EpollSelector
INFO     src.api.main:main.py:58 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
INFO     src.api.main:main.py:62 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:77 테스트 StockMaster 데이터 시딩 완료.
INFO     src.api.main:main.py:80 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:106 테스트 DailyPrice 데이터 시딩 완료.
----------------------------- Captured stdout call -----------------------------
2025-08-31 17:50:36,785 - httpx - INFO - HTTP Request: GET http://testserver/symbols/search?query=035720 "HTTP/1.1 404 Not Found"
------------------------------ Captured log call -------------------------------
INFO     httpx:_client.py:1025 HTTP Request: GET http://testserver/symbols/search?query=035720 "HTTP/1.1 404 Not Found"
_____________ TestStockMasterRouter.test_search_symbols_no_results _____________

self = <test_api_stock_master_integration.TestStockMasterRouter object at 0x7f345fca3610>
client = <starlette.testclient.TestClient object at 0x7f345f289420>

    def test_search_symbols_no_results(self, client: TestClient):
        """
        - **테스트 대상**: `GET /symbols/search`
        - **목적**: 검색 결과가 없을 때, 빈 목록을 정상적으로 반환하는지 확인합니다.
        - **시나리오**:
            1. DB에 없는 검색어로 API를 호출합니다.
            2. 200 OK 응답과 함께 빈 목록이 반환되는지 확인합니다.
        - **Mock 대상**: 없음
        """
        # When
        response = client.get("/symbols/search?query=없는종목")
    
        # Then
>       assert response.status_code == 200
E       assert 404 == 200
E        +  where 404 = <Response [404 Not Found]>.status_code

tests/integration/test_api_stock_master_integration.py:130: AssertionError
---------------------------- Captured stdout setup -----------------------------
2025-08-31 17:50:36,998 - asyncio - DEBUG - Using selector: EpollSelector
2025-08-31 17:50:37,018 - src.api.main - INFO - 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
2025-08-31 17:50:37,232 - src.api.main - INFO - 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 17:50:37,239 - src.api.main - INFO - 테스트 StockMaster 데이터 시딩 완료.
2025-08-31 17:50:37,240 - src.api.main - INFO - 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 17:50:37,251 - src.api.main - INFO - 테스트 DailyPrice 데이터 시딩 완료.
------------------------------ Captured log setup ------------------------------
DEBUG    asyncio:selector_events.py:54 Using selector: EpollSelector
INFO     src.api.main:main.py:58 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
INFO     src.api.main:main.py:62 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:77 테스트 StockMaster 데이터 시딩 완료.
INFO     src.api.main:main.py:80 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:106 테스트 DailyPrice 데이터 시딩 완료.
----------------------------- Captured stdout call -----------------------------
2025-08-31 17:50:37,254 - httpx - INFO - HTTP Request: GET http://testserver/symbols/search?query=%EC%97%86%EB%8A%94%EC%A2%85%EB%AA%A9 "HTTP/1.1 404 Not Found"
------------------------------ Captured log call -------------------------------
INFO     httpx:_client.py:1025 HTTP Request: GET http://testserver/symbols/search?query=%EC%97%86%EB%8A%94%EC%A2%85%EB%AA%A9 "HTTP/1.1 404 Not Found"
____________ TestStockMasterRouter.test_search_symbols_empty_query _____________

self = <test_api_stock_master_integration.TestStockMasterRouter object at 0x7f345fca3880>
client = <starlette.testclient.TestClient object at 0x7f345f28bca0>

    def test_search_symbols_empty_query(self, client: TestClient):
        """
        - **테스트 대상**: `GET /symbols/search`
        - **목적**: 검색어를 비워둔 채 요청 시, 422 Unprocessable Entity 에러를 반환하는지 확인합니다.
        - **시나리오**:
            1. `query` 파라미터를 빈 문자열로 하여 API를 호출합니다.
            2. FastAPI의 유효성 검사에 의해 422 에러가 발생하는지 확인합니다.
        - **Mock 대상**: 없음
        """
        # When
        response = client.get("/symbols/search?query=")
    
        # Then
>       assert response.status_code == 422
E       assert 404 == 422
E        +  where 404 = <Response [404 Not Found]>.status_code

tests/integration/test_api_stock_master_integration.py:148: AssertionError
---------------------------- Captured stdout setup -----------------------------
2025-08-31 17:50:37,441 - asyncio - DEBUG - Using selector: EpollSelector
2025-08-31 17:50:37,449 - src.api.main - INFO - 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
2025-08-31 17:50:37,641 - src.api.main - INFO - 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 17:50:37,646 - src.api.main - INFO - 테스트 StockMaster 데이터 시딩 완료.
2025-08-31 17:50:37,647 - src.api.main - INFO - 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 17:50:37,658 - src.api.main - INFO - 테스트 DailyPrice 데이터 시딩 완료.
------------------------------ Captured log setup ------------------------------
DEBUG    asyncio:selector_events.py:54 Using selector: EpollSelector
INFO     src.api.main:main.py:58 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
INFO     src.api.main:main.py:62 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:77 테스트 StockMaster 데이터 시딩 완료.
INFO     src.api.main:main.py:80 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:106 테스트 DailyPrice 데이터 시딩 완료.
----------------------------- Captured stdout call -----------------------------
2025-08-31 17:50:37,663 - httpx - INFO - HTTP Request: GET http://testserver/symbols/search?query= "HTTP/1.1 404 Not Found"
------------------------------ Captured log call -------------------------------
INFO     httpx:_client.py:1025 HTTP Request: GET http://testserver/symbols/search?query= "HTTP/1.1 404 Not Found"
=============================== warnings summary ===============================
../../../usr/local/lib/python3.10/site-packages/pydantic/_internal/_config.py:323
../../../usr/local/lib/python3.10/site-packages/pydantic/_internal/_config.py:323
../../../usr/local/lib/python3.10/site-packages/pydantic/_internal/_config.py:323
  /usr/local/lib/python3.10/site-packages/pydantic/_internal/_config.py:323: PydanticDeprecatedSince20: Support for class-based `config` is deprecated, use ConfigDict instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.11/migration/
    warnings.warn(DEPRECATION_MESSAGE, DeprecationWarning)

../../../usr/local/lib/python3.10/site-packages/pydantic/_internal/_config.py:373
  /usr/local/lib/python3.10/site-packages/pydantic/_internal/_config.py:373: UserWarning: Valid config keys have changed in V2:
  * 'orm_mode' has been renamed to 'from_attributes'
    warnings.warn(message, UserWarning)

main.py:112
  /app/src/api/main.py:112: DeprecationWarning: 
          on_event is deprecated, use lifespan event handlers instead.
  
          Read more about it in the
          [FastAPI docs for Lifespan Events](https://fastapi.tiangolo.com/advanced/events/).
          
    @app.on_event("startup")

../../../usr/local/lib/python3.10/site-packages/fastapi/applications.py:4495
  /usr/local/lib/python3.10/site-packages/fastapi/applications.py:4495: DeprecationWarning: 
          on_event is deprecated, use lifespan event handlers instead.
  
          Read more about it in the
          [FastAPI docs for Lifespan Events](https://fastapi.tiangolo.com/advanced/events/).
          
    return self.router.on_event(event_type)

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
=========================== short test summary info ============================
FAILED tests/integration/test_api_stock_master_integration.py::TestStockMasterRouter::test_get_all_symbols
FAILED tests/integration/test_api_stock_master_integration.py::TestStockMasterRouter::test_get_all_symbols_empty
FAILED tests/integration/test_api_stock_master_integration.py::TestStockMasterRouter::test_search_symbols_by_name
FAILED tests/integration/test_api_stock_master_integration.py::TestStockMasterRouter::test_search_symbols_by_symbol
FAILED tests/integration/test_api_stock_master_integration.py::TestStockMasterRouter::test_search_symbols_no_results
FAILED tests/integration/test_api_stock_master_integration.py::TestStockMasterRouter::test_search_symbols_empty_query
ERROR tests/integration/test_api_stock_master_integration.py::TestStockMasterRouter::test_get_current_price_and_change_success
ERROR tests/integration/test_api_stock_master_integration.py::TestStockMasterRouter::test_get_current_price_and_change_not_found
=================== 6 failed, 6 warnings, 2 errors in 5.38s ====================
\n--- Running test_api_simulated_trade_integration.py ---
============================= test session starts ==============================
platform linux -- Python 3.10.18, pytest-8.4.1, pluggy-1.6.0
rootdir: /app/src/api
plugins: cov-6.2.1, timeout-2.4.0, anyio-4.10.0, asyncio-1.1.0
asyncio: mode=strict, asyncio_default_fixture_loop_scope=None, asyncio_default_test_loop_scope=function
collected 8 items

tests/integration/test_api_simulated_trade_integration.py FFFFFFFF       [100%]

=================================== FAILURES ===================================
_____________________ test_simulate_trade_and_get_history ______________________

client = <starlette.testclient.TestClient object at 0x7fe531b8fc70>
real_db = <sqlalchemy.orm.session.Session object at 0x7fe531d4efb0>

    def test_simulate_trade_and_get_history(client: TestClient, real_db):
        """
        - **테스트 대상**: `POST /trade/simulate`, `GET /trade/history/{user_id}`
        - **목적**: 모의 거래를 성공적으로 기록하고, 해당 거래가 이력 조회 시 정상적으로 반환되는지 확인합니다.
        - **시나리오**:
            1. 테스트용 사용자를 생성합니다.
            2. 모의 매수 거래를 요청합니다.
            3. 200 OK 응답을 확인합니다.
            4. 거래 이력 조회를 요청합니다.
            5. 200 OK 응답과 함께, 방금 기록한 거래가 포함된 이력이 반환되는지 확인합니다.
        - **Mock 대상**: 없음
        """
        # Given: 테스트용 사용자 생성
>       user = create_test_user(real_db)

tests/integration/test_api_simulated_trade_integration.py:29: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/helpers.py:14: in create_test_user
    user = User(
<string>:4: in __init__
    ???
/usr/local/lib/python3.10/site-packages/sqlalchemy/orm/state.py:571: in _initialize_instance
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/orm/state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.common.models.user.User object at 0x7fe531b8d5d0>
kwargs = {'email': 'test_6232dba4f2864112913cbc3b25aa9316@example.com', 'is_active': True, 'password_hash': '$2b$12$r2s7BfmsJljPiR8mLQpl1.H5xpeTeWmelujTJWbl69qtDwL/NT4cq', 'role': 'user', ...}
cls_ = <class 'src.common.models.user.User'>, k = 'password_hash'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'password_hash' is an invalid keyword argument for User

/usr/local/lib/python3.10/site-packages/sqlalchemy/orm/decl_base.py:2179: TypeError
---------------------------- Captured stdout setup -----------------------------
2025-08-31 17:50:51,242 - asyncio - DEBUG - Using selector: EpollSelector
2025-08-31 17:50:51,386 - src.api.main - INFO - 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
2025-08-31 17:50:51,662 - src.api.main - INFO - 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 17:50:51,704 - src.api.main - INFO - 테스트 StockMaster 데이터 시딩 완료.
2025-08-31 17:50:51,704 - src.api.main - INFO - 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 17:50:51,722 - src.api.main - INFO - 테스트 DailyPrice 데이터 시딩 완료.
------------------------------ Captured log setup ------------------------------
DEBUG    asyncio:selector_events.py:54 Using selector: EpollSelector
INFO     src.api.main:main.py:58 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
INFO     src.api.main:main.py:62 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:77 테스트 StockMaster 데이터 시딩 완료.
INFO     src.api.main:main.py:80 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:106 테스트 DailyPrice 데이터 시딩 완료.
----------------------------- Captured stdout call -----------------------------
2025-08-31 17:50:51,725 - passlib.handlers.bcrypt - WARNING - (trapped) error reading bcrypt version
Traceback (most recent call last):
  File "/usr/local/lib/python3.10/site-packages/passlib/handlers/bcrypt.py", line 620, in _load_backend_mixin
    version = _bcrypt.__about__.__version__
AttributeError: module 'bcrypt' has no attribute '__about__'
2025-08-31 17:50:51,727 - passlib.handlers.bcrypt - DEBUG - detected 'bcrypt' backend, version '<unknown>'
2025-08-31 17:50:51,728 - passlib.handlers.bcrypt - DEBUG - 'bcrypt' backend lacks $2$ support, enabling workaround
------------------------------ Captured log call -------------------------------
WARNING  passlib.handlers.bcrypt:bcrypt.py:622 (trapped) error reading bcrypt version
Traceback (most recent call last):
  File "/usr/local/lib/python3.10/site-packages/passlib/handlers/bcrypt.py", line 620, in _load_backend_mixin
    version = _bcrypt.__about__.__version__
AttributeError: module 'bcrypt' has no attribute '__about__'
DEBUG    passlib.handlers.bcrypt:bcrypt.py:625 detected 'bcrypt' backend, version '<unknown>'
DEBUG    passlib.handlers.bcrypt:bcrypt.py:406 'bcrypt' backend lacks $2$ support, enabling workaround
___________________________ test_simulate_trade_sell ___________________________

client = <starlette.testclient.TestClient object at 0x7fe531b8dc90>
real_db = <sqlalchemy.orm.session.Session object at 0x7fe54c3b86d0>

    def test_simulate_trade_sell(client: TestClient, real_db):
        """
        - **테스트 대상**: `POST /trade/simulate` (매도 시나리오)
        - **목적**: 모의 매도 거래가 정상적으로 기록되는지 확인합니다.
        - **시나리오**:
            1. 테스트용 사용자를 생성하고, 매수 거래를 먼저 기록합니다.
            2. 동일 종목에 대해 매도 거래를 요청합니다.
            3. 200 OK 응답을 확인합니다.
            4. 거래 이력을 조회하여 매수와 매도 거래가 모두 기록되었는지 확인합니다.
        - **Mock 대상**: 없음
        """
        # Given: 테스트용 사용자 및 매수 거래 생성
>       user = create_test_user(real_db)

tests/integration/test_api_simulated_trade_integration.py:57: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/helpers.py:14: in create_test_user
    user = User(
<string>:4: in __init__
    ???
/usr/local/lib/python3.10/site-packages/sqlalchemy/orm/state.py:571: in _initialize_instance
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/orm/state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.common.models.user.User object at 0x7fe531b8c6d0>
kwargs = {'email': 'test_4d8ad5547c844264af59b2017a2c43f9@example.com', 'is_active': True, 'password_hash': '$2b$12$EbX/y5.tvEtKrGQTRSwck.cqrpuU8ePW8a3N6s.Pm7cPZGsqDBEZ2', 'role': 'user', ...}
cls_ = <class 'src.common.models.user.User'>, k = 'password_hash'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'password_hash' is an invalid keyword argument for User

/usr/local/lib/python3.10/site-packages/sqlalchemy/orm/decl_base.py:2179: TypeError
---------------------------- Captured stdout setup -----------------------------
2025-08-31 17:50:52,468 - asyncio - DEBUG - Using selector: EpollSelector
2025-08-31 17:50:52,479 - src.api.main - INFO - 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
2025-08-31 17:50:52,653 - src.api.main - INFO - 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 17:50:52,662 - src.api.main - INFO - 테스트 StockMaster 데이터 시딩 완료.
2025-08-31 17:50:52,662 - src.api.main - INFO - 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 17:50:52,677 - src.api.main - INFO - 테스트 DailyPrice 데이터 시딩 완료.
------------------------------ Captured log setup ------------------------------
DEBUG    asyncio:selector_events.py:54 Using selector: EpollSelector
INFO     src.api.main:main.py:58 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
INFO     src.api.main:main.py:62 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:77 테스트 StockMaster 데이터 시딩 완료.
INFO     src.api.main:main.py:80 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:106 테스트 DailyPrice 데이터 시딩 완료.
____________________ test_get_trade_history_multiple_trades ____________________

client = <starlette.testclient.TestClient object at 0x7fe53112af50>
real_db = <sqlalchemy.orm.session.Session object at 0x7fe53112b160>

    def test_get_trade_history_multiple_trades(client: TestClient, real_db):
        """
        - **테스트 대상**: `GET /trade/history/{user_id}`
        - **목적**: 여러 건의 모의 거래가 기록되었을 때, 이력 조회 기능이 정상적으로 동작하는지 확인합니다.
        - **시나리오**:
            1. 여러 건의 매수/매도 거래를 기록합니다.
            2. 거래 이력을 조회합니다.
            3. 200 OK 응답과 함께, 모든 거래가 최신순으로 정렬되어 반환되는지 확인합니다.
        - **Mock 대상**: 없음
        """
        # Given: 여러 건의 모의 거래 기록
>       user = create_test_user(real_db)

tests/integration/test_api_simulated_trade_integration.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/helpers.py:14: in create_test_user
    user = User(
<string>:4: in __init__
    ???
/usr/local/lib/python3.10/site-packages/sqlalchemy/orm/state.py:571: in _initialize_instance
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/orm/state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.common.models.user.User object at 0x7fe53112ba00>
kwargs = {'email': 'test_d4c0e668cb5e444a9456fe2f24c2926c@example.com', 'is_active': True, 'password_hash': '$2b$12$C3vS2t.uNLZyL4m.Wf1ATuWFlk0qo6oy5fmPKgH4Mbn1WfZJlNY/O', 'role': 'user', ...}
cls_ = <class 'src.common.models.user.User'>, k = 'password_hash'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'password_hash' is an invalid keyword argument for User

/usr/local/lib/python3.10/site-packages/sqlalchemy/orm/decl_base.py:2179: TypeError
---------------------------- Captured stdout setup -----------------------------
2025-08-31 17:50:53,334 - asyncio - DEBUG - Using selector: EpollSelector
2025-08-31 17:50:53,342 - src.api.main - INFO - 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
2025-08-31 17:50:53,500 - src.api.main - INFO - 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 17:50:53,507 - src.api.main - INFO - 테스트 StockMaster 데이터 시딩 완료.
2025-08-31 17:50:53,508 - src.api.main - INFO - 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 17:50:53,523 - src.api.main - INFO - 테스트 DailyPrice 데이터 시딩 완료.
------------------------------ Captured log setup ------------------------------
DEBUG    asyncio:selector_events.py:54 Using selector: EpollSelector
INFO     src.api.main:main.py:58 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
INFO     src.api.main:main.py:62 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:77 테스트 StockMaster 데이터 시딩 완료.
INFO     src.api.main:main.py:80 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:106 테스트 DailyPrice 데이터 시딩 완료.
_________________________ test_get_trade_stats_success _________________________

client = <starlette.testclient.TestClient object at 0x7fe531ce3310>
real_db = <sqlalchemy.orm.session.Session object at 0x7fe531ce1540>

    def test_get_trade_stats_success(client: TestClient, real_db):
        """
        - **테스트 대상**: `GET /trade/history/{user_id}` (통계 부분)
        - **목적**: 거래 이력 조회 시, 통계 정보가 정상적으로 계산되어 반환되는지 확인합니다.
        - **시나리오**:
            1. 수익과 손실이 모두 발생하는 여러 거래를 기록합니다.
            2. 거래 이력을 조회합니다.
            3. 200 OK 응답과 함께, `statistics` 필드에 총 손익, 승률 등의 정보가 포함되어 있는지 확인합니다.
        - **Mock 대상**: 없음
        """
        # Given: 여러 건의 모의 거래 기록
>       user = create_test_user(real_db)

tests/integration/test_api_simulated_trade_integration.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/helpers.py:14: in create_test_user
    user = User(
<string>:4: in __init__
    ???
/usr/local/lib/python3.10/site-packages/sqlalchemy/orm/state.py:571: in _initialize_instance
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/orm/state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.common.models.user.User object at 0x7fe531ce34f0>
kwargs = {'email': 'test_8dda6ee3defc4ea1bcc115756ac8fcc0@example.com', 'is_active': True, 'password_hash': '$2b$12$dFnwXd3xAtGj0.D4.HFY/O9bXddQSeJNgBESWHnzwDYo19ffPmI7G', 'role': 'user', ...}
cls_ = <class 'src.common.models.user.User'>, k = 'password_hash'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'password_hash' is an invalid keyword argument for User

/usr/local/lib/python3.10/site-packages/sqlalchemy/orm/decl_base.py:2179: TypeError
---------------------------- Captured stdout setup -----------------------------
2025-08-31 17:50:54,214 - asyncio - DEBUG - Using selector: EpollSelector
2025-08-31 17:50:54,227 - src.api.main - INFO - 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
2025-08-31 17:50:54,393 - src.api.main - INFO - 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 17:50:54,399 - src.api.main - INFO - 테스트 StockMaster 데이터 시딩 완료.
2025-08-31 17:50:54,399 - src.api.main - INFO - 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 17:50:54,409 - src.api.main - INFO - 테스트 DailyPrice 데이터 시딩 완료.
------------------------------ Captured log setup ------------------------------
DEBUG    asyncio:selector_events.py:54 Using selector: EpollSelector
INFO     src.api.main:main.py:58 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
INFO     src.api.main:main.py:62 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:77 테스트 StockMaster 데이터 시딩 완료.
INFO     src.api.main:main.py:80 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:106 테스트 DailyPrice 데이터 시딩 완료.
_______________________ test_simulate_trade_invalid_user _______________________

client = <starlette.testclient.TestClient object at 0x7fe531b8d600>

    def test_simulate_trade_invalid_user(client: TestClient):
        """
        - **테스트 대상**: `POST /trade/simulate`
        - **목적**: 존재하지 않는 사용자로 모의 거래 요청 시, 404 에러를 반환하는지 확인합니다.
        - **시나리오**:
            1. 존재하지 않는 `user_id`로 거래를 요청합니다.
            2. 404 Not Found 응답을 확인합니다.
        - **Mock 대상**: 없음
        """
        response = client.post("/trade/simulate", json={"user_id": 99999, "symbol": "005930", "trade_type": "buy", "price": 80000, "quantity": 10})
        assert response.status_code == 404
>       assert response.json()["detail"] == "User not found"
E       AssertionError: assert 'Not Found' == 'User not found'
E         
E         - User not found
E         + Not Found

tests/integration/test_api_simulated_trade_integration.py:143: AssertionError
---------------------------- Captured stdout setup -----------------------------
2025-08-31 17:50:54,997 - asyncio - DEBUG - Using selector: EpollSelector
2025-08-31 17:50:55,009 - src.api.main - INFO - 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
2025-08-31 17:50:55,165 - src.api.main - INFO - 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 17:50:55,172 - src.api.main - INFO - 테스트 StockMaster 데이터 시딩 완료.
2025-08-31 17:50:55,172 - src.api.main - INFO - 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 17:50:55,182 - src.api.main - INFO - 테스트 DailyPrice 데이터 시딩 완료.
------------------------------ Captured log setup ------------------------------
DEBUG    asyncio:selector_events.py:54 Using selector: EpollSelector
INFO     src.api.main:main.py:58 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
INFO     src.api.main:main.py:62 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:77 테스트 StockMaster 데이터 시딩 완료.
INFO     src.api.main:main.py:80 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:106 테스트 DailyPrice 데이터 시딩 완료.
----------------------------- Captured stdout call -----------------------------
2025-08-31 17:50:55,187 - httpx - INFO - HTTP Request: POST http://testserver/trade/simulate "HTTP/1.1 404 Not Found"
------------------------------ Captured log call -------------------------------
INFO     httpx:_client.py:1025 HTTP Request: POST http://testserver/trade/simulate "HTTP/1.1 404 Not Found"
_____________________ test_get_trade_history_invalid_user ______________________

client = <starlette.testclient.TestClient object at 0x7fe531a32710>

    def test_get_trade_history_invalid_user(client: TestClient):
        """
        - **테스트 대상**: `GET /trade/history/{user_id}`
        - **목적**: 존재하지 않는 사용자로 거래 이력 조회 요청 시, 404 에러를 반환하는지 확인합니다.
        - **시나리오**:
            1. 존재하지 않는 `user_id`로 이력 조회를 요청합니다.
            2. 404 Not Found 응답을 확인합니다.
        - **Mock 대상**: 없음
        """
        response = client.get("/trade/history/99999")
        assert response.status_code == 404
>       assert response.json()["detail"] == "User not found"
E       AssertionError: assert 'Not Found' == 'User not found'
E         
E         - User not found
E         + Not Found

tests/integration/test_api_simulated_trade_integration.py:157: AssertionError
---------------------------- Captured stdout setup -----------------------------
2025-08-31 17:50:55,355 - asyncio - DEBUG - Using selector: EpollSelector
2025-08-31 17:50:55,363 - src.api.main - INFO - 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
2025-08-31 17:50:55,526 - src.api.main - INFO - 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 17:50:55,534 - src.api.main - INFO - 테스트 StockMaster 데이터 시딩 완료.
2025-08-31 17:50:55,534 - src.api.main - INFO - 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 17:50:55,549 - src.api.main - INFO - 테스트 DailyPrice 데이터 시딩 완료.
------------------------------ Captured log setup ------------------------------
DEBUG    asyncio:selector_events.py:54 Using selector: EpollSelector
INFO     src.api.main:main.py:58 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
INFO     src.api.main:main.py:62 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:77 테스트 StockMaster 데이터 시딩 완료.
INFO     src.api.main:main.py:80 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:106 테스트 DailyPrice 데이터 시딩 완료.
----------------------------- Captured stdout call -----------------------------
2025-08-31 17:50:55,553 - httpx - INFO - HTTP Request: GET http://testserver/trade/history/99999 "HTTP/1.1 404 Not Found"
------------------------------ Captured log call -------------------------------
INFO     httpx:_client.py:1025 HTTP Request: GET http://testserver/trade/history/99999 "HTTP/1.1 404 Not Found"
______________________ test_get_trade_stats_invalid_user _______________________

client = <starlette.testclient.TestClient object at 0x7fe531194580>

    def test_get_trade_stats_invalid_user(client: TestClient):
        """
        - **테스트 대상**: `GET /trade/history/{user_id}` (통계 부분)
        - **목적**: 존재하지 않는 사용자로 통계 조회 요청 시, 404 에러를 반환하는지 확인합니다.
        - **시나리오**:
            1. 존재하지 않는 `user_id`로 이력/통계 조회를 요청합니다.
            2. 404 Not Found 응답을 확인합니다.
        - **Mock 대상**: 없음
        """
        # 참고: 현재 통계는 이력 조회(/trade/history/{user_id})에 포함되어 반환됩니다.
        # 따라서 이 테스트는 `test_get_trade_history_invalid_user`와 동일한 동작을 검증합니다.
        response = client.get("/trade/history/99999")
        assert response.status_code == 404
>       assert response.json()["detail"] == "User not found"
E       AssertionError: assert 'Not Found' == 'User not found'
E         
E         - User not found
E         + Not Found

tests/integration/test_api_simulated_trade_integration.py:173: AssertionError
---------------------------- Captured stdout setup -----------------------------
2025-08-31 17:50:55,753 - asyncio - DEBUG - Using selector: EpollSelector
2025-08-31 17:50:55,766 - src.api.main - INFO - 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
2025-08-31 17:50:55,931 - src.api.main - INFO - 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 17:50:55,937 - src.api.main - INFO - 테스트 StockMaster 데이터 시딩 완료.
2025-08-31 17:50:55,938 - src.api.main - INFO - 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 17:50:55,947 - src.api.main - INFO - 테스트 DailyPrice 데이터 시딩 완료.
------------------------------ Captured log setup ------------------------------
DEBUG    asyncio:selector_events.py:54 Using selector: EpollSelector
INFO     src.api.main:main.py:58 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
INFO     src.api.main:main.py:62 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:77 테스트 StockMaster 데이터 시딩 완료.
INFO     src.api.main:main.py:80 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:106 테스트 DailyPrice 데이터 시딩 완료.
----------------------------- Captured stdout call -----------------------------
2025-08-31 17:50:55,951 - httpx - INFO - HTTP Request: GET http://testserver/trade/history/99999 "HTTP/1.1 404 Not Found"
------------------------------ Captured log call -------------------------------
INFO     httpx:_client.py:1025 HTTP Request: GET http://testserver/trade/history/99999 "HTTP/1.1 404 Not Found"
______________________ test_simulate_trade_invalid_input _______________________

client = <starlette.testclient.TestClient object at 0x7fe531197fa0>
real_db = <sqlalchemy.orm.session.Session object at 0x7fe531194910>

    def test_simulate_trade_invalid_input(client: TestClient, real_db):
        """
        - **테스트 대상**: `POST /trade/simulate`
        - **목적**: 유효하지 않은 입력값으로 모의 거래 요청 시, 422 에러를 반환하는지 확인합니다.
        - **시나리오**:
            1. `trade_type`에 허용되지 않는 값을 넣어 요청하고 422 응답을 확인합니다.
            2. 필수 필드(`quantity`)를 누락하여 요청하고 422 응답을 확인합니다.
        - **Mock 대상**: 없음
        """
>       user = create_test_user(real_db)

tests/integration/test_api_simulated_trade_integration.py:185: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/helpers.py:14: in create_test_user
    user = User(
<string>:4: in __init__
    ???
/usr/local/lib/python3.10/site-packages/sqlalchemy/orm/state.py:571: in _initialize_instance
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/orm/state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.common.models.user.User object at 0x7fe531b8d930>
kwargs = {'email': 'test_ebaa906198fd42daa14216aeee27e1a0@example.com', 'is_active': True, 'password_hash': '$2b$12$/CKixw.N.keXqdeQh7WyauRtz8KlAv6b/9/.gnCweH36rlewryyPW', 'role': 'user', ...}
cls_ = <class 'src.common.models.user.User'>, k = 'password_hash'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'password_hash' is an invalid keyword argument for User

/usr/local/lib/python3.10/site-packages/sqlalchemy/orm/decl_base.py:2179: TypeError
---------------------------- Captured stdout setup -----------------------------
2025-08-31 17:50:56,122 - asyncio - DEBUG - Using selector: EpollSelector
2025-08-31 17:50:56,134 - src.api.main - INFO - 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
2025-08-31 17:50:56,293 - src.api.main - INFO - 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 17:50:56,300 - src.api.main - INFO - 테스트 StockMaster 데이터 시딩 완료.
2025-08-31 17:50:56,300 - src.api.main - INFO - 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 17:50:56,311 - src.api.main - INFO - 테스트 DailyPrice 데이터 시딩 완료.
------------------------------ Captured log setup ------------------------------
DEBUG    asyncio:selector_events.py:54 Using selector: EpollSelector
INFO     src.api.main:main.py:58 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
INFO     src.api.main:main.py:62 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:77 테스트 StockMaster 데이터 시딩 완료.
INFO     src.api.main:main.py:80 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:106 테스트 DailyPrice 데이터 시딩 완료.
=============================== warnings summary ===============================
../../../usr/local/lib/python3.10/site-packages/pydantic/_internal/_config.py:323
../../../usr/local/lib/python3.10/site-packages/pydantic/_internal/_config.py:323
../../../usr/local/lib/python3.10/site-packages/pydantic/_internal/_config.py:323
  /usr/local/lib/python3.10/site-packages/pydantic/_internal/_config.py:323: PydanticDeprecatedSince20: Support for class-based `config` is deprecated, use ConfigDict instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.11/migration/
    warnings.warn(DEPRECATION_MESSAGE, DeprecationWarning)

../../../usr/local/lib/python3.10/site-packages/pydantic/_internal/_config.py:373
  /usr/local/lib/python3.10/site-packages/pydantic/_internal/_config.py:373: UserWarning: Valid config keys have changed in V2:
  * 'orm_mode' has been renamed to 'from_attributes'
    warnings.warn(message, UserWarning)

main.py:112
  /app/src/api/main.py:112: DeprecationWarning: 
          on_event is deprecated, use lifespan event handlers instead.
  
          Read more about it in the
          [FastAPI docs for Lifespan Events](https://fastapi.tiangolo.com/advanced/events/).
          
    @app.on_event("startup")

../../../usr/local/lib/python3.10/site-packages/fastapi/applications.py:4495
  /usr/local/lib/python3.10/site-packages/fastapi/applications.py:4495: DeprecationWarning: 
          on_event is deprecated, use lifespan event handlers instead.
  
          Read more about it in the
          [FastAPI docs for Lifespan Events](https://fastapi.tiangolo.com/advanced/events/).
          
    return self.router.on_event(event_type)

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
=========================== short test summary info ============================
FAILED tests/integration/test_api_simulated_trade_integration.py::test_simulate_trade_and_get_history
FAILED tests/integration/test_api_simulated_trade_integration.py::test_simulate_trade_sell
FAILED tests/integration/test_api_simulated_trade_integration.py::test_get_trade_history_multiple_trades
FAILED tests/integration/test_api_simulated_trade_integration.py::test_get_trade_stats_success
FAILED tests/integration/test_api_simulated_trade_integration.py::test_simulate_trade_invalid_user
FAILED tests/integration/test_api_simulated_trade_integration.py::test_get_trade_history_invalid_user
FAILED tests/integration/test_api_simulated_trade_integration.py::test_get_trade_stats_invalid_user
FAILED tests/integration/test_api_simulated_trade_integration.py::test_simulate_trade_invalid_input
======================== 8 failed, 6 warnings in 7.90s =========================
\n--- Running test_api_bot_router_integration.py ---
============================= test session starts ==============================
platform linux -- Python 3.10.18, pytest-8.4.1, pluggy-1.6.0
rootdir: /app/src/api
plugins: cov-6.2.1, timeout-2.4.0, anyio-4.10.0, asyncio-1.1.0
asyncio: mode=strict, asyncio_default_fixture_loop_scope=None, asyncio_default_test_loop_scope=function
collected 10 items

tests/integration/test_api_bot_router_integration.py EEEEEEE.EE          [100%]

==================================== ERRORS ====================================
______ ERROR at setup of test_toggle_disclosure_alert_new_user_and_alert _______

fixturedef = <FixtureDef argname='test_user' scope='function' baseid='tests'>
request = <SubRequest 'test_user' for <Coroutine test_toggle_disclosure_alert_new_user_and_alert>>

    @pytest.hookimpl(wrapper=True)
    def pytest_fixture_setup(fixturedef: FixtureDef, request) -> object | None:
        asyncio_mode = _get_asyncio_mode(request.config)
        if not _is_asyncio_fixture_function(fixturedef.func):
            if asyncio_mode == Mode.STRICT:
                # Ignore async fixtures without explicit asyncio mark in strict mode
                # This applies to pytest_trio fixtures, for example
>               return (yield)

/usr/local/lib/python3.10/site-packages/pytest_asyncio/plugin.py:681: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

real_db = <sqlalchemy.orm.session.Session object at 0x7f5aebf7f190>

    @pytest.fixture(scope="function")
    def test_user(real_db: Session):
        """테스트용 사용자 생성 및 반환"""
        user_service = UserService()
        telegram_id = int(f"123{uuid4().hex[:7]}", 16) # Unique telegram_id
        username = f"test_user_{uuid4().hex[:8]}"
        email = f"{username}@test.com"
        password = "test_password"
    
>       user = user_service.create_user(
            real_db,
            username=username,
            email=email,
            password=password,
            telegram_id=telegram_id
        )
E       TypeError: UserService.create_user() got an unexpected keyword argument 'username'

tests/conftest.py:89: TypeError
___ ERROR at setup of test_toggle_disclosure_alert_existing_alert_on_to_off ____

fixturedef = <FixtureDef argname='test_user' scope='function' baseid='tests'>
request = <SubRequest 'test_user' for <Coroutine test_toggle_disclosure_alert_existing_alert_on_to_off>>

    @pytest.hookimpl(wrapper=True)
    def pytest_fixture_setup(fixturedef: FixtureDef, request) -> object | None:
        asyncio_mode = _get_asyncio_mode(request.config)
        if not _is_asyncio_fixture_function(fixturedef.func):
            if asyncio_mode == Mode.STRICT:
                # Ignore async fixtures without explicit asyncio mark in strict mode
                # This applies to pytest_trio fixtures, for example
>               return (yield)

/usr/local/lib/python3.10/site-packages/pytest_asyncio/plugin.py:681: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

real_db = <sqlalchemy.orm.session.Session object at 0x7f5aebc979d0>

    @pytest.fixture(scope="function")
    def test_user(real_db: Session):
        """테스트용 사용자 생성 및 반환"""
        user_service = UserService()
        telegram_id = int(f"123{uuid4().hex[:7]}", 16) # Unique telegram_id
        username = f"test_user_{uuid4().hex[:8]}"
        email = f"{username}@test.com"
        password = "test_password"
    
>       user = user_service.create_user(
            real_db,
            username=username,
            email=email,
            password=password,
            telegram_id=telegram_id
        )
E       TypeError: UserService.create_user() got an unexpected keyword argument 'username'

tests/conftest.py:89: TypeError
________ ERROR at setup of test_set_price_alert_existing_user_new_alert ________

fixturedef = <FixtureDef argname='test_user' scope='function' baseid='tests'>
request = <SubRequest 'test_user' for <Coroutine test_set_price_alert_existing_user_new_alert>>

    @pytest.hookimpl(wrapper=True)
    def pytest_fixture_setup(fixturedef: FixtureDef, request) -> object | None:
        asyncio_mode = _get_asyncio_mode(request.config)
        if not _is_asyncio_fixture_function(fixturedef.func):
            if asyncio_mode == Mode.STRICT:
                # Ignore async fixtures without explicit asyncio mark in strict mode
                # This applies to pytest_trio fixtures, for example
>               return (yield)

/usr/local/lib/python3.10/site-packages/pytest_asyncio/plugin.py:681: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

real_db = <sqlalchemy.orm.session.Session object at 0x7f5aebf13c70>

    @pytest.fixture(scope="function")
    def test_user(real_db: Session):
        """테스트용 사용자 생성 및 반환"""
        user_service = UserService()
        telegram_id = int(f"123{uuid4().hex[:7]}", 16) # Unique telegram_id
        username = f"test_user_{uuid4().hex[:8]}"
        email = f"{username}@test.com"
        password = "test_password"
    
>       user = user_service.create_user(
            real_db,
            username=username,
            email=email,
            password=password,
            telegram_id=telegram_id
        )
E       TypeError: UserService.create_user() got an unexpected keyword argument 'username'

tests/conftest.py:89: TypeError
_________ ERROR at setup of test_set_price_alert_existing_alert_update _________

fixturedef = <FixtureDef argname='test_user' scope='function' baseid='tests'>
request = <SubRequest 'test_user' for <Coroutine test_set_price_alert_existing_alert_update>>

    @pytest.hookimpl(wrapper=True)
    def pytest_fixture_setup(fixturedef: FixtureDef, request) -> object | None:
        asyncio_mode = _get_asyncio_mode(request.config)
        if not _is_asyncio_fixture_function(fixturedef.func):
            if asyncio_mode == Mode.STRICT:
                # Ignore async fixtures without explicit asyncio mark in strict mode
                # This applies to pytest_trio fixtures, for example
>               return (yield)

/usr/local/lib/python3.10/site-packages/pytest_asyncio/plugin.py:681: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

real_db = <sqlalchemy.orm.session.Session object at 0x7f5aebc972e0>

    @pytest.fixture(scope="function")
    def test_user(real_db: Session):
        """테스트용 사용자 생성 및 반환"""
        user_service = UserService()
        telegram_id = int(f"123{uuid4().hex[:7]}", 16) # Unique telegram_id
        username = f"test_user_{uuid4().hex[:8]}"
        email = f"{username}@test.com"
        password = "test_password"
    
>       user = user_service.create_user(
            real_db,
            username=username,
            email=email,
            password=password,
            telegram_id=telegram_id
        )
E       TypeError: UserService.create_user() got an unexpected keyword argument 'username'

tests/conftest.py:89: TypeError
__________________ ERROR at setup of test_list_alerts_for_bot __________________

fixturedef = <FixtureDef argname='test_user' scope='function' baseid='tests'>
request = <SubRequest 'test_user' for <Coroutine test_list_alerts_for_bot>>

    @pytest.hookimpl(wrapper=True)
    def pytest_fixture_setup(fixturedef: FixtureDef, request) -> object | None:
        asyncio_mode = _get_asyncio_mode(request.config)
        if not _is_asyncio_fixture_function(fixturedef.func):
            if asyncio_mode == Mode.STRICT:
                # Ignore async fixtures without explicit asyncio mark in strict mode
                # This applies to pytest_trio fixtures, for example
>               return (yield)

/usr/local/lib/python3.10/site-packages/pytest_asyncio/plugin.py:681: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

real_db = <sqlalchemy.orm.session.Session object at 0x7f5aebe1a440>

    @pytest.fixture(scope="function")
    def test_user(real_db: Session):
        """테스트용 사용자 생성 및 반환"""
        user_service = UserService()
        telegram_id = int(f"123{uuid4().hex[:7]}", 16) # Unique telegram_id
        username = f"test_user_{uuid4().hex[:8]}"
        email = f"{username}@test.com"
        password = "test_password"
    
>       user = user_service.create_user(
            real_db,
            username=username,
            email=email,
            password=password,
            telegram_id=telegram_id
        )
E       TypeError: UserService.create_user() got an unexpected keyword argument 'username'

tests/conftest.py:89: TypeError
_____________ ERROR at setup of test_list_alerts_for_bot_no_alerts _____________

fixturedef = <FixtureDef argname='test_user' scope='function' baseid='tests'>
request = <SubRequest 'test_user' for <Function test_list_alerts_for_bot_no_alerts>>

    @pytest.hookimpl(wrapper=True)
    def pytest_fixture_setup(fixturedef: FixtureDef, request) -> object | None:
        asyncio_mode = _get_asyncio_mode(request.config)
        if not _is_asyncio_fixture_function(fixturedef.func):
            if asyncio_mode == Mode.STRICT:
                # Ignore async fixtures without explicit asyncio mark in strict mode
                # This applies to pytest_trio fixtures, for example
>               return (yield)

/usr/local/lib/python3.10/site-packages/pytest_asyncio/plugin.py:681: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

real_db = <sqlalchemy.orm.session.Session object at 0x7f5aebdc7970>

    @pytest.fixture(scope="function")
    def test_user(real_db: Session):
        """테스트용 사용자 생성 및 반환"""
        user_service = UserService()
        telegram_id = int(f"123{uuid4().hex[:7]}", 16) # Unique telegram_id
        username = f"test_user_{uuid4().hex[:8]}"
        email = f"{username}@test.com"
        password = "test_password"
    
>       user = user_service.create_user(
            real_db,
            username=username,
            email=email,
            password=password,
            telegram_id=telegram_id
        )
E       TypeError: UserService.create_user() got an unexpected keyword argument 'username'

tests/conftest.py:89: TypeError
_____________ ERROR at setup of test_remove_alert_for_bot_success ______________

fixturedef = <FixtureDef argname='test_user' scope='function' baseid='tests'>
request = <SubRequest 'test_user' for <Coroutine test_remove_alert_for_bot_success>>

    @pytest.hookimpl(wrapper=True)
    def pytest_fixture_setup(fixturedef: FixtureDef, request) -> object | None:
        asyncio_mode = _get_asyncio_mode(request.config)
        if not _is_asyncio_fixture_function(fixturedef.func):
            if asyncio_mode == Mode.STRICT:
                # Ignore async fixtures without explicit asyncio mark in strict mode
                # This applies to pytest_trio fixtures, for example
>               return (yield)

/usr/local/lib/python3.10/site-packages/pytest_asyncio/plugin.py:681: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

real_db = <sqlalchemy.orm.session.Session object at 0x7f5aebdc0940>

    @pytest.fixture(scope="function")
    def test_user(real_db: Session):
        """테스트용 사용자 생성 및 반환"""
        user_service = UserService()
        telegram_id = int(f"123{uuid4().hex[:7]}", 16) # Unique telegram_id
        username = f"test_user_{uuid4().hex[:8]}"
        email = f"{username}@test.com"
        password = "test_password"
    
>       user = user_service.create_user(
            real_db,
            username=username,
            email=email,
            password=password,
            telegram_id=telegram_id
        )
E       TypeError: UserService.create_user() got an unexpected keyword argument 'username'

tests/conftest.py:89: TypeError
___________ ERROR at setup of test_remove_alert_for_bot_unauthorized ___________

fixturedef = <FixtureDef argname='test_user' scope='function' baseid='tests'>
request = <SubRequest 'test_user' for <Coroutine test_remove_alert_for_bot_unauthorized>>

    @pytest.hookimpl(wrapper=True)
    def pytest_fixture_setup(fixturedef: FixtureDef, request) -> object | None:
        asyncio_mode = _get_asyncio_mode(request.config)
        if not _is_asyncio_fixture_function(fixturedef.func):
            if asyncio_mode == Mode.STRICT:
                # Ignore async fixtures without explicit asyncio mark in strict mode
                # This applies to pytest_trio fixtures, for example
>               return (yield)

/usr/local/lib/python3.10/site-packages/pytest_asyncio/plugin.py:681: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

real_db = <sqlalchemy.orm.session.Session object at 0x7f5aebdc5000>

    @pytest.fixture(scope="function")
    def test_user(real_db: Session):
        """테스트용 사용자 생성 및 반환"""
        user_service = UserService()
        telegram_id = int(f"123{uuid4().hex[:7]}", 16) # Unique telegram_id
        username = f"test_user_{uuid4().hex[:8]}"
        email = f"{username}@test.com"
        password = "test_password"
    
>       user = user_service.create_user(
            real_db,
            username=username,
            email=email,
            password=password,
            telegram_id=telegram_id
        )
E       TypeError: UserService.create_user() got an unexpected keyword argument 'username'

tests/conftest.py:89: TypeError
___________ ERROR at setup of test_deactivate_alert_for_bot_success ____________

fixturedef = <FixtureDef argname='test_user' scope='function' baseid='tests'>
request = <SubRequest 'test_user' for <Coroutine test_deactivate_alert_for_bot_success>>

    @pytest.hookimpl(wrapper=True)
    def pytest_fixture_setup(fixturedef: FixtureDef, request) -> object | None:
        asyncio_mode = _get_asyncio_mode(request.config)
        if not _is_asyncio_fixture_function(fixturedef.func):
            if asyncio_mode == Mode.STRICT:
                # Ignore async fixtures without explicit asyncio mark in strict mode
                # This applies to pytest_trio fixtures, for example
>               return (yield)

/usr/local/lib/python3.10/site-packages/pytest_asyncio/plugin.py:681: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

real_db = <sqlalchemy.orm.session.Session object at 0x7f5aebc16b60>

    @pytest.fixture(scope="function")
    def test_user(real_db: Session):
        """테스트용 사용자 생성 및 반환"""
        user_service = UserService()
        telegram_id = int(f"123{uuid4().hex[:7]}", 16) # Unique telegram_id
        username = f"test_user_{uuid4().hex[:8]}"
        email = f"{username}@test.com"
        password = "test_password"
    
>       user = user_service.create_user(
            real_db,
            username=username,
            email=email,
            password=password,
            telegram_id=telegram_id
        )
E       TypeError: UserService.create_user() got an unexpected keyword argument 'username'

tests/conftest.py:89: TypeError
=============================== warnings summary ===============================
../../../usr/local/lib/python3.10/site-packages/pydantic/_internal/_config.py:323
../../../usr/local/lib/python3.10/site-packages/pydantic/_internal/_config.py:323
../../../usr/local/lib/python3.10/site-packages/pydantic/_internal/_config.py:323
  /usr/local/lib/python3.10/site-packages/pydantic/_internal/_config.py:323: PydanticDeprecatedSince20: Support for class-based `config` is deprecated, use ConfigDict instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.11/migration/
    warnings.warn(DEPRECATION_MESSAGE, DeprecationWarning)

../../../usr/local/lib/python3.10/site-packages/pydantic/_internal/_config.py:373
  /usr/local/lib/python3.10/site-packages/pydantic/_internal/_config.py:373: UserWarning: Valid config keys have changed in V2:
  * 'orm_mode' has been renamed to 'from_attributes'
    warnings.warn(message, UserWarning)

main.py:112
  /app/src/api/main.py:112: DeprecationWarning: 
          on_event is deprecated, use lifespan event handlers instead.
  
          Read more about it in the
          [FastAPI docs for Lifespan Events](https://fastapi.tiangolo.com/advanced/events/).
          
    @app.on_event("startup")

../../../usr/local/lib/python3.10/site-packages/fastapi/applications.py:4495
  /usr/local/lib/python3.10/site-packages/fastapi/applications.py:4495: DeprecationWarning: 
          on_event is deprecated, use lifespan event handlers instead.
  
          Read more about it in the
          [FastAPI docs for Lifespan Events](https://fastapi.tiangolo.com/advanced/events/).
          
    return self.router.on_event(event_type)

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
=========================== short test summary info ============================
ERROR tests/integration/test_api_bot_router_integration.py::test_toggle_disclosure_alert_new_user_and_alert
ERROR tests/integration/test_api_bot_router_integration.py::test_toggle_disclosure_alert_existing_alert_on_to_off
ERROR tests/integration/test_api_bot_router_integration.py::test_set_price_alert_existing_user_new_alert
ERROR tests/integration/test_api_bot_router_integration.py::test_set_price_alert_existing_alert_update
ERROR tests/integration/test_api_bot_router_integration.py::test_list_alerts_for_bot
ERROR tests/integration/test_api_bot_router_integration.py::test_list_alerts_for_bot_no_alerts
ERROR tests/integration/test_api_bot_router_integration.py::test_remove_alert_for_bot_success
ERROR tests/integration/test_api_bot_router_integration.py::test_remove_alert_for_bot_unauthorized
ERROR tests/integration/test_api_bot_router_integration.py::test_deactivate_alert_for_bot_success
=================== 1 passed, 6 warnings, 9 errors in 4.63s ====================
\n--- Running test_api_alerts_price_integration.py ---
============================= test session starts ==============================
platform linux -- Python 3.10.18, pytest-8.4.1, pluggy-1.6.0
rootdir: /app/src/api
plugins: cov-6.2.1, timeout-2.4.0, anyio-4.10.0, asyncio-1.1.0
asyncio: mode=strict, asyncio_default_fixture_loop_scope=None, asyncio_default_test_loop_scope=function
collected 2 items

tests/integration/test_api_alerts_price_integration.py FF                [100%]

=================================== FAILURES ===================================
______________ test_set_price_alert_for_bot_with_repeat_interval _______________

client = <starlette.testclient.TestClient object at 0x7fa58e00f6d0>
db_session = <sqlalchemy.orm.session.Session object at 0x7fa58e038e20>

    @pytest.mark.asyncio
    async def test_set_price_alert_for_bot_with_repeat_interval(client: TestClient, db_session: Session):
        """
        - **테스트 대상**: `POST /bot/alert/price`
        - **목적**: 봇을 통해 신규 가격 알림을 설정할 때, `repeat_interval` 필드가 올바르게 저장되는지 확인합니다.
        - **시나리오**:
            1. `repeat_interval`을 포함한 알림 생성 페이로드를 구성합니다.
            2. API를 호출하여 알림을 생성합니다.
            3. 200 OK 응답과 함께 반환된 데이터에 `repeat_interval`이 포함되어 있는지 확인합니다.
            4. 데이터베이스에 저장된 실제 데이터에도 `repeat_interval`이 올바르게 기록되었는지 확인합니다.
        - **Mock 대상**: 없음
        """
        # Given: 테스트용 데이터 정의
        telegram_user_id = 12345
        symbol = "005930"
        payload = {
            "telegram_user_id": telegram_user_id,
            "telegram_username": "testuser",
            "telegram_first_name": "Test",
            "telegram_last_name": "User",
            "symbol": symbol,
            "target_price": 75000.0,
            "condition": "gte",
            "repeat_interval": "daily"
        }
    
        # When: API 호출
        response = client.post("/bot/alert/price", json=payload)
    
        # Then: API 응답 검증
>       assert response.status_code == 200
E       assert 404 == 200
E        +  where 404 = <Response [404 Not Found]>.status_code

tests/integration/test_api_alerts_price_integration.py:93: AssertionError
---------------------------- Captured stdout setup -----------------------------
2025-08-31 17:51:21,150 - asyncio - DEBUG - Using selector: EpollSelector
2025-08-31 17:51:21,181 - src.api.main - INFO - 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
2025-08-31 17:51:21,352 - src.api.main - INFO - 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 17:51:21,387 - src.api.main - INFO - 테스트 StockMaster 데이터 시딩 완료.
2025-08-31 17:51:21,388 - src.api.main - INFO - 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 17:51:21,527 - src.api.main - INFO - 테스트 DailyPrice 데이터 시딩 완료.
2025-08-31 17:51:21,718 - asyncio - DEBUG - Using selector: EpollSelector
2025-08-31 17:51:21,719 - asyncio - DEBUG - Using selector: EpollSelector
------------------------------ Captured log setup ------------------------------
DEBUG    asyncio:selector_events.py:54 Using selector: EpollSelector
INFO     src.api.main:main.py:58 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
INFO     src.api.main:main.py:62 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:77 테스트 StockMaster 데이터 시딩 완료.
INFO     src.api.main:main.py:80 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:106 테스트 DailyPrice 데이터 시딩 완료.
DEBUG    asyncio:selector_events.py:54 Using selector: EpollSelector
DEBUG    asyncio:selector_events.py:54 Using selector: EpollSelector
----------------------------- Captured stdout call -----------------------------
2025-08-31 17:51:21,724 - httpx - INFO - HTTP Request: POST http://testserver/bot/alert/price "HTTP/1.1 404 Not Found"
------------------------------ Captured log call -------------------------------
INFO     httpx:_client.py:1025 HTTP Request: POST http://testserver/bot/alert/price "HTTP/1.1 404 Not Found"
_____________ test_update_price_alert_for_bot_with_repeat_interval _____________

client = <starlette.testclient.TestClient object at 0x7fa58e00f6d0>
db_session = <sqlalchemy.orm.session.Session object at 0x7fa58d5f7dc0>

    @pytest.mark.asyncio
    async def test_update_price_alert_for_bot_with_repeat_interval(client: TestClient, db_session: Session):
        """
        - **테스트 대상**: `POST /bot/alert/price` (업데이트 시나리오)
        - **목적**: 봇을 통해 기존 가격 알림을 업데이트할 때, `repeat_interval` 필드가 올바르게 변경되는지 확인합니다.
        - **시나리오**:
            1. `repeat_interval`이 없는 초기 알림을 생성합니다.
            2. `repeat_interval`을 포함한 페이로드로 동일한 심볼에 대해 다시 API를 호출하여 알림을 업데이트합니다.
            3. 200 OK 응답과 함께 반환된 데이터에 업데이트된 `repeat_interval`이 포함되어 있는지 확인합니다.
            4. 데이터베이스에 저장된 데이터도 올바르게 업데이트되었는지 확인합니다.
        - **Mock 대상**: 없음
        """
        # Given: 초기 알림 데이터 생성
        telegram_user_id = 12346
        symbol = "005930"
        initial_payload = {
            "telegram_user_id": telegram_user_id,
            "telegram_username": "testuser2",
            "telegram_first_name": "Test2",
            "telegram_last_name": "User2",
            "symbol": symbol,
            "target_price": 70000.0,
            "condition": "lte"
        }
        client.post("/bot/alert/price", json=initial_payload)
    
        # When: repeat_interval을 포함하여 업데이트 요청
        update_payload = {
            "telegram_user_id": telegram_user_id,
            "telegram_username": "testuser2",
            "telegram_first_name": "Test2",
            "telegram_last_name": "User2",
            "symbol": symbol,
            "target_price": 76000.0,
            "condition": "gte",
            "repeat_interval": "weekly"
        }
        response = client.post("/bot/alert/price", json=update_payload)
    
        # Then: API 응답 검증
>       assert response.status_code == 200
E       assert 404 == 200
E        +  where 404 = <Response [404 Not Found]>.status_code

tests/integration/test_api_alerts_price_integration.py:146: AssertionError
---------------------------- Captured stdout setup -----------------------------
2025-08-31 17:51:22,240 - asyncio - DEBUG - Using selector: EpollSelector
------------------------------ Captured log setup ------------------------------
DEBUG    asyncio:selector_events.py:54 Using selector: EpollSelector
----------------------------- Captured stdout call -----------------------------
2025-08-31 17:51:22,245 - httpx - INFO - HTTP Request: POST http://testserver/bot/alert/price "HTTP/1.1 404 Not Found"
2025-08-31 17:51:22,248 - httpx - INFO - HTTP Request: POST http://testserver/bot/alert/price "HTTP/1.1 404 Not Found"
------------------------------ Captured log call -------------------------------
INFO     httpx:_client.py:1025 HTTP Request: POST http://testserver/bot/alert/price "HTTP/1.1 404 Not Found"
INFO     httpx:_client.py:1025 HTTP Request: POST http://testserver/bot/alert/price "HTTP/1.1 404 Not Found"
=============================== warnings summary ===============================
../../../usr/local/lib/python3.10/site-packages/pydantic/_internal/_config.py:323
../../../usr/local/lib/python3.10/site-packages/pydantic/_internal/_config.py:323
../../../usr/local/lib/python3.10/site-packages/pydantic/_internal/_config.py:323
  /usr/local/lib/python3.10/site-packages/pydantic/_internal/_config.py:323: PydanticDeprecatedSince20: Support for class-based `config` is deprecated, use ConfigDict instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.11/migration/
    warnings.warn(DEPRECATION_MESSAGE, DeprecationWarning)

../../../usr/local/lib/python3.10/site-packages/pydantic/_internal/_config.py:373
  /usr/local/lib/python3.10/site-packages/pydantic/_internal/_config.py:373: UserWarning: Valid config keys have changed in V2:
  * 'orm_mode' has been renamed to 'from_attributes'
    warnings.warn(message, UserWarning)

main.py:112
  /app/src/api/main.py:112: DeprecationWarning: 
          on_event is deprecated, use lifespan event handlers instead.
  
          Read more about it in the
          [FastAPI docs for Lifespan Events](https://fastapi.tiangolo.com/advanced/events/).
          
    @app.on_event("startup")

../../../usr/local/lib/python3.10/site-packages/fastapi/applications.py:4495
  /usr/local/lib/python3.10/site-packages/fastapi/applications.py:4495: DeprecationWarning: 
          on_event is deprecated, use lifespan event handlers instead.
  
          Read more about it in the
          [FastAPI docs for Lifespan Events](https://fastapi.tiangolo.com/advanced/events/).
          
    return self.router.on_event(event_type)

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
=========================== short test summary info ============================
FAILED tests/integration/test_api_alerts_price_integration.py::test_set_price_alert_for_bot_with_repeat_interval
FAILED tests/integration/test_api_alerts_price_integration.py::test_update_price_alert_for_bot_with_repeat_interval
======================== 2 failed, 6 warnings in 2.00s =========================
\n--- Running test_api_alerts_integration.py ---
============================= test session starts ==============================
platform linux -- Python 3.10.18, pytest-8.4.1, pluggy-1.6.0
rootdir: /app/src/api
plugins: cov-6.2.1, timeout-2.4.0, anyio-4.10.0, asyncio-1.1.0
asyncio: mode=strict, asyncio_default_fixture_loop_scope=None, asyncio_default_test_loop_scope=function
collected 5 items

tests/integration/test_api_alerts_integration.py F....                   [100%]

=================================== FAILURES ===================================
_________________ TestTelegramAlertRouter.test_alert_scenario __________________

self = <test_api_alerts_integration.TestTelegramAlertRouter object at 0x7fa59c2c4340>
client = <starlette.testclient.TestClient object at 0x7fa59c2e1fc0>
real_db = <sqlalchemy.orm.session.Session object at 0x7fa59c62f280>

    def test_alert_scenario(self, client: TestClient, real_db: Session):
        """
        - **테스트 대상**: `/api/v1/alerts/` 전체 엔드포인트 (POST, GET, PUT, DELETE)
        - **목적**: 가격 알림의 생성, 조회, 수정, 삭제(CRUD) 전체 시나리오가 정상적으로 동작하는지 확인합니다.
        - **시나리오**:
            1. 새로운 가격 알림을 생성합니다. (이 과정에서 사용자도 함께 생성됩니다.)
            2. 생성된 알림이 목록에 정상적으로 조회되는지 확인합니다.
            3. 생성된 알림의 설정을 (공시 알림) 수정합니다.
            4. 수정된 알림을 삭제합니다.
            5. 삭제 후 알림 목록이 비어있는지 확인합니다.
        - **Mock 대상**: 없음
        """
        telegram_id = 123456789
        symbol = "005930"
    
        # 1. 신규 알림 생성
        create_payload = {
            "telegram_id": telegram_id,
            "symbol": symbol,
            "target_price": 80000,
            "condition": "gte",
            "is_active": True
        }
        create_response = client.post("/api/v1/alerts/", json=create_payload)
        assert create_response.status_code == 200
        created_alert = create_response.json()
        assert created_alert["symbol"] == symbol
    
        # DB에서 사용자 및 알림 생성 확인
        user_in_db = real_db.query(User).filter(User.telegram_id == telegram_id).first()
        assert user_in_db is not None
        alert_in_db = real_db.query(PriceAlert).filter(PriceAlert.user_id == user_in_db.id, PriceAlert.symbol == symbol).first()
        assert alert_in_db is not None
        assert alert_in_db.target_price == 80000
    
        # 2. 알림 목록 조회
>       list_response = client.get(f"/api/v1/alerts/{telegram_id}")

tests/integration/test_api_alerts_integration.py:60: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/starlette/testclient.py:479: in get
    return super().get(
/usr/local/lib/python3.10/site-packages/httpx/_client.py:1053: in get
    return self.request(
/usr/local/lib/python3.10/site-packages/starlette/testclient.py:451: in request
    return super().request(
/usr/local/lib/python3.10/site-packages/httpx/_client.py:825: in request
    return self.send(request, auth=auth, follow_redirects=follow_redirects)
/usr/local/lib/python3.10/site-packages/httpx/_client.py:914: in send
    response = self._send_handling_auth(
/usr/local/lib/python3.10/site-packages/httpx/_client.py:942: in _send_handling_auth
    response = self._send_handling_redirects(
/usr/local/lib/python3.10/site-packages/httpx/_client.py:979: in _send_handling_redirects
    response = self._send_single_request(request)
/usr/local/lib/python3.10/site-packages/httpx/_client.py:1014: in _send_single_request
    response = transport.handle_request(request)
/usr/local/lib/python3.10/site-packages/starlette/testclient.py:354: in handle_request
    raise exc
/usr/local/lib/python3.10/site-packages/starlette/testclient.py:351: in handle_request
    portal.call(self.app, scope, receive, send)
/usr/local/lib/python3.10/site-packages/anyio/from_thread.py:291: in call
    return cast(T_Retval, self.start_task_soon(func, *args).result())
/usr/local/lib/python3.10/concurrent/futures/_base.py:458: in result
    return self.__get_result()
/usr/local/lib/python3.10/concurrent/futures/_base.py:403: in __get_result
    raise self._exception
/usr/local/lib/python3.10/site-packages/anyio/from_thread.py:222: in _call_func
    retval = await retval_or_awaitable
/usr/local/lib/python3.10/site-packages/fastapi/applications.py:1054: in __call__
    await super().__call__(scope, receive, send)
/usr/local/lib/python3.10/site-packages/starlette/applications.py:113: in __call__
    await self.middleware_stack(scope, receive, send)
/usr/local/lib/python3.10/site-packages/starlette/middleware/errors.py:186: in __call__
    raise exc
/usr/local/lib/python3.10/site-packages/starlette/middleware/errors.py:164: in __call__
    await self.app(scope, receive, _send)
/usr/local/lib/python3.10/site-packages/starlette/middleware/exceptions.py:63: in __call__
    await wrap_app_handling_exceptions(self.app, conn)(scope, receive, send)
/usr/local/lib/python3.10/site-packages/starlette/_exception_handler.py:53: in wrapped_app
    raise exc
/usr/local/lib/python3.10/site-packages/starlette/_exception_handler.py:42: in wrapped_app
    await app(scope, receive, sender)
/usr/local/lib/python3.10/site-packages/starlette/routing.py:716: in __call__
    await self.middleware_stack(scope, receive, send)
/usr/local/lib/python3.10/site-packages/starlette/routing.py:736: in app
    await route.handle(scope, receive, send)
/usr/local/lib/python3.10/site-packages/starlette/routing.py:290: in handle
    await self.app(scope, receive, send)
/usr/local/lib/python3.10/site-packages/starlette/routing.py:78: in app
    await wrap_app_handling_exceptions(app, request)(scope, receive, send)
/usr/local/lib/python3.10/site-packages/starlette/_exception_handler.py:53: in wrapped_app
    raise exc
/usr/local/lib/python3.10/site-packages/starlette/_exception_handler.py:42: in wrapped_app
    await app(scope, receive, sender)
/usr/local/lib/python3.10/site-packages/starlette/routing.py:75: in app
    response = await f(request)
/usr/local/lib/python3.10/site-packages/fastapi/routing.py:302: in app
    raw_response = await run_endpoint_function(
/usr/local/lib/python3.10/site-packages/fastapi/routing.py:215: in run_endpoint_function
    return await run_in_threadpool(dependant.call, **values)
/usr/local/lib/python3.10/site-packages/starlette/concurrency.py:38: in run_in_threadpool
    return await anyio.to_thread.run_sync(func)
/usr/local/lib/python3.10/site-packages/anyio/to_thread.py:56: in run_sync
    return await get_async_backend().run_sync_in_worker_thread(
/usr/local/lib/python3.10/site-packages/anyio/_backends/_asyncio.py:2476: in run_sync_in_worker_thread
    return await future
/usr/local/lib/python3.10/site-packages/anyio/_backends/_asyncio.py:967: in run
    result = context.run(func, *args)
routers/notification.py:51: in get_my_alerts
    return [PriceAlertRead.model_validate(r, update={'stock_name': r.stock.name if r.stock else None, 'notify_on_disclosure': r.notify_on_disclosure}) for r in results]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

.0 = <list_iterator object at 0x7fa59ba61750>

>   return [PriceAlertRead.model_validate(r, update={'stock_name': r.stock.name if r.stock else None, 'notify_on_disclosure': r.notify_on_disclosure}) for r in results]
E   TypeError: BaseModel.model_validate() got an unexpected keyword argument 'update'

routers/notification.py:51: TypeError
---------------------------- Captured stdout setup -----------------------------
2025-08-31 17:51:33,169 - asyncio - DEBUG - Using selector: EpollSelector
2025-08-31 17:51:33,216 - src.api.main - INFO - 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
2025-08-31 17:51:33,461 - src.api.main - INFO - 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 17:51:33,611 - src.api.main - INFO - 테스트 StockMaster 데이터 시딩 완료.
2025-08-31 17:51:33,611 - src.api.main - INFO - 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 17:51:33,629 - src.api.main - INFO - 테스트 DailyPrice 데이터 시딩 완료.
------------------------------ Captured log setup ------------------------------
DEBUG    asyncio:selector_events.py:54 Using selector: EpollSelector
INFO     src.api.main:main.py:58 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
INFO     src.api.main:main.py:62 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:77 테스트 StockMaster 데이터 시딩 완료.
INFO     src.api.main:main.py:80 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:106 테스트 DailyPrice 데이터 시딩 완료.
----------------------------- Captured stdout call -----------------------------
2025-08-31 17:51:33,636 - src.common.services.price_alert_service - DEBUG - PriceAlertService 초기화.
Creating alert with payload: symbol='005930' target_price=80000.0 condition='gte' change_percent=None change_type=None notify_on_disclosure=True repeat_interval=None telegram_id=123456789 is_active=True
2025-08-31 17:51:33,644 - src.api.services.user_service - DEBUG - get_user_by_telegram_id 호출: telegram_id=123456789
2025-08-31 17:51:33,651 - src.api.services.user_service - DEBUG - create_user_from_telegram 호출: telegram_id=123456789, username=tg_123456789
2025-08-31 17:51:33,664 - src.api.services.user_service - INFO - 텔레그램 사용자 생성 성공: telegram_id=123456789, id=1
2025-08-31 17:51:33,664 - src.common.services.price_alert_service - DEBUG - 가격 알림 생성 시도: user_id=1, symbol=005930
2025-08-31 17:51:33,683 - src.common.services.price_alert_service - INFO - 가격 알림 생성 성공: alert_id=1
2025-08-31 17:51:33,689 - httpx - INFO - HTTP Request: POST http://testserver/api/v1/alerts/ "HTTP/1.1 200 OK"
2025-08-31 17:51:33,701 - src.common.services.price_alert_service - DEBUG - PriceAlertService 초기화.
2025-08-31 17:51:33,703 - src.api.services.user_service - DEBUG - get_user_by_telegram_id 호출: telegram_id=123456789
------------------------------ Captured log call -------------------------------
DEBUG    src.common.services.price_alert_service:price_alert_service.py:21 PriceAlertService 초기화.
DEBUG    src.api.services.user_service:user_service.py:24 get_user_by_telegram_id 호출: telegram_id=123456789
DEBUG    src.api.services.user_service:user_service.py:49 create_user_from_telegram 호출: telegram_id=123456789, username=tg_123456789
INFO     src.api.services.user_service:user_service.py:61 텔레그램 사용자 생성 성공: telegram_id=123456789, id=1
DEBUG    src.common.services.price_alert_service:price_alert_service.py:25 가격 알림 생성 시도: user_id=1, symbol=005930
INFO     src.common.services.price_alert_service:price_alert_service.py:49 가격 알림 생성 성공: alert_id=1
INFO     httpx:_client.py:1025 HTTP Request: POST http://testserver/api/v1/alerts/ "HTTP/1.1 200 OK"
DEBUG    src.common.services.price_alert_service:price_alert_service.py:21 PriceAlertService 초기화.
DEBUG    src.api.services.user_service:user_service.py:24 get_user_by_telegram_id 호출: telegram_id=123456789
=============================== warnings summary ===============================
../../../usr/local/lib/python3.10/site-packages/pydantic/_internal/_config.py:323
../../../usr/local/lib/python3.10/site-packages/pydantic/_internal/_config.py:323
../../../usr/local/lib/python3.10/site-packages/pydantic/_internal/_config.py:323
  /usr/local/lib/python3.10/site-packages/pydantic/_internal/_config.py:323: PydanticDeprecatedSince20: Support for class-based `config` is deprecated, use ConfigDict instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.11/migration/
    warnings.warn(DEPRECATION_MESSAGE, DeprecationWarning)

../../../usr/local/lib/python3.10/site-packages/pydantic/_internal/_config.py:373
  /usr/local/lib/python3.10/site-packages/pydantic/_internal/_config.py:373: UserWarning: Valid config keys have changed in V2:
  * 'orm_mode' has been renamed to 'from_attributes'
    warnings.warn(message, UserWarning)

main.py:112
  /app/src/api/main.py:112: DeprecationWarning: 
          on_event is deprecated, use lifespan event handlers instead.
  
          Read more about it in the
          [FastAPI docs for Lifespan Events](https://fastapi.tiangolo.com/advanced/events/).
          
    @app.on_event("startup")

../../../usr/local/lib/python3.10/site-packages/fastapi/applications.py:4495
  /usr/local/lib/python3.10/site-packages/fastapi/applications.py:4495: DeprecationWarning: 
          on_event is deprecated, use lifespan event handlers instead.
  
          Read more about it in the
          [FastAPI docs for Lifespan Events](https://fastapi.tiangolo.com/advanced/events/).
          
    return self.router.on_event(event_type)

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
=========================== short test summary info ============================
FAILED tests/integration/test_api_alerts_integration.py::TestTelegramAlertRouter::test_alert_scenario
=================== 1 failed, 4 passed, 6 warnings in 5.04s ====================
\n--- Running test_api_prediction_history_integration.py ---
============================= test session starts ==============================
platform linux -- Python 3.10.18, pytest-8.4.1, pluggy-1.6.0
rootdir: /app/src/api
plugins: cov-6.2.1, timeout-2.4.0, anyio-4.10.0, asyncio-1.1.0
asyncio: mode=strict, asyncio_default_fixture_loop_scope=None, asyncio_default_test_loop_scope=function
collected 7 items

tests/integration/test_api_prediction_history_integration.py FFFFFFF     [100%]

=================================== FAILURES ===================================
_______ TestPredictionHistoryRouter.test_get_prediction_history_success ________

self = <test_api_prediction_history_integration.TestPredictionHistoryRouter object at 0x7f77b61bca00>
client = <starlette.testclient.TestClient object at 0x7f77b6369ff0>
real_db = <sqlalchemy.orm.session.Session object at 0x7f77b6517070>

    def test_get_prediction_history_success(self, client: TestClient, real_db: Session):
        """
        - **테스트 대상**: `GET /prediction/history/{user_id}`
        - **목적**: 특정 사용자의 주가 예측 이력을 성공적으로 조회하는지 확인합니다.
        - **시나리오**:
            - 테스트용 사용자와 두 개의 예측 이력을 생성합니다.
            - 해당 사용자의 ID로 API를 호출합니다.
            - 200 OK 응답과 함께 2개의 이력이 최신순으로 정렬되어 반환되는지 확인합니다.
        - **Mock 대상**: 없음
        """
        # Given: 테스트 사용자 및 예측 이력 데이터 생성
>       user = create_test_user(real_db)

tests/integration/test_api_prediction_history_integration.py:65: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/helpers.py:14: in create_test_user
    user = User(
<string>:4: in __init__
    ???
/usr/local/lib/python3.10/site-packages/sqlalchemy/orm/state.py:571: in _initialize_instance
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/orm/state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.common.models.user.User object at 0x7f77d481d180>
kwargs = {'email': 'test_61408e95a12f42cf9d430725dd62f7ed@example.com', 'is_active': True, 'password_hash': '$2b$12$MI4BpyUjaWyusdOcJUKVDOp6XL2d9twepfFEYXqr3EiYB852hdova', 'role': 'user', ...}
cls_ = <class 'src.common.models.user.User'>, k = 'password_hash'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'password_hash' is an invalid keyword argument for User

/usr/local/lib/python3.10/site-packages/sqlalchemy/orm/decl_base.py:2179: TypeError
---------------------------- Captured stdout setup -----------------------------
2025-08-31 17:51:48,883 - asyncio - DEBUG - Using selector: EpollSelector
2025-08-31 17:51:48,934 - src.api.main - INFO - 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
2025-08-31 17:51:49,187 - src.api.main - INFO - 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 17:51:49,199 - src.api.main - INFO - 테스트 StockMaster 데이터 시딩 완료.
2025-08-31 17:51:49,200 - src.api.main - INFO - 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 17:51:49,216 - src.api.main - INFO - 테스트 DailyPrice 데이터 시딩 완료.
------------------------------ Captured log setup ------------------------------
DEBUG    asyncio:selector_events.py:54 Using selector: EpollSelector
INFO     src.api.main:main.py:58 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
INFO     src.api.main:main.py:62 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:77 테스트 StockMaster 데이터 시딩 완료.
INFO     src.api.main:main.py:80 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:106 테스트 DailyPrice 데이터 시딩 완료.
----------------------------- Captured stdout call -----------------------------
2025-08-31 17:51:49,219 - passlib.handlers.bcrypt - WARNING - (trapped) error reading bcrypt version
Traceback (most recent call last):
  File "/usr/local/lib/python3.10/site-packages/passlib/handlers/bcrypt.py", line 620, in _load_backend_mixin
    version = _bcrypt.__about__.__version__
AttributeError: module 'bcrypt' has no attribute '__about__'
2025-08-31 17:51:49,222 - passlib.handlers.bcrypt - DEBUG - detected 'bcrypt' backend, version '<unknown>'
2025-08-31 17:51:49,223 - passlib.handlers.bcrypt - DEBUG - 'bcrypt' backend lacks $2$ support, enabling workaround
------------------------------ Captured log call -------------------------------
WARNING  passlib.handlers.bcrypt:bcrypt.py:622 (trapped) error reading bcrypt version
Traceback (most recent call last):
  File "/usr/local/lib/python3.10/site-packages/passlib/handlers/bcrypt.py", line 620, in _load_backend_mixin
    version = _bcrypt.__about__.__version__
AttributeError: module 'bcrypt' has no attribute '__about__'
DEBUG    passlib.handlers.bcrypt:bcrypt.py:625 detected 'bcrypt' backend, version '<unknown>'
DEBUG    passlib.handlers.bcrypt:bcrypt.py:406 'bcrypt' backend lacks $2$ support, enabling workaround
____ TestPredictionHistoryRouter.test_get_prediction_history_not_found_user ____

self = <test_api_prediction_history_integration.TestPredictionHistoryRouter object at 0x7f77b61bcc70>
client = <starlette.testclient.TestClient object at 0x7f77b636a290>

    def test_get_prediction_history_not_found_user(self, client: TestClient):
        """
        - **테스트 대상**: `GET /prediction/history/{user_id}`
        - **목적**: 존재하지 않는 사용자에 대해 API 호출 시, 빈 목록을 정상적으로 반환하는지 확인합니다.
        - **시나리오**:
            - 존재하지 않는 사용자 ID(99999)로 API를 호출합니다.
            - 200 OK 응답과 함께 빈 이력 목록이 반환되는지 확인합니다.
        - **Mock 대상**: 없음
        """
        # When: 존재하지 않는 사용자 ID로 API 호출
        response = client.get("/prediction/history/99999")
    
        # Then: 404 Not Found 대신 200 OK와 빈 리스트를 반환하는 것이 현재 정책
>       assert response.status_code == 200
E       assert 404 == 200
E        +  where 404 = <Response [404 Not Found]>.status_code

tests/integration/test_api_prediction_history_integration.py:92: AssertionError
---------------------------- Captured stdout setup -----------------------------
2025-08-31 17:51:49,990 - asyncio - DEBUG - Using selector: EpollSelector
2025-08-31 17:51:49,998 - src.api.main - INFO - 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
2025-08-31 17:51:50,178 - src.api.main - INFO - 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 17:51:50,186 - src.api.main - INFO - 테스트 StockMaster 데이터 시딩 완료.
2025-08-31 17:51:50,186 - src.api.main - INFO - 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 17:51:50,197 - src.api.main - INFO - 테스트 DailyPrice 데이터 시딩 완료.
------------------------------ Captured log setup ------------------------------
DEBUG    asyncio:selector_events.py:54 Using selector: EpollSelector
INFO     src.api.main:main.py:58 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
INFO     src.api.main:main.py:62 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:77 테스트 StockMaster 데이터 시딩 완료.
INFO     src.api.main:main.py:80 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:106 테스트 DailyPrice 데이터 시딩 완료.
----------------------------- Captured stdout call -----------------------------
2025-08-31 17:51:50,202 - httpx - INFO - HTTP Request: GET http://testserver/prediction/history/99999 "HTTP/1.1 404 Not Found"
------------------------------ Captured log call -------------------------------
INFO     httpx:_client.py:1025 HTTP Request: GET http://testserver/prediction/history/99999 "HTTP/1.1 404 Not Found"
________ TestPredictionHistoryRouter.test_get_prediction_history_empty _________

self = <test_api_prediction_history_integration.TestPredictionHistoryRouter object at 0x7f77b61bcdc0>
client = <starlette.testclient.TestClient object at 0x7f77b6369810>
real_db = <sqlalchemy.orm.session.Session object at 0x7f77b635cf70>

    def test_get_prediction_history_empty(self, client: TestClient, real_db: Session):
        """
        - **테스트 대상**: `GET /prediction/history/{user_id}`
        - **목적**: 예측 이력이 없는 사용자에 대해 API 호출 시, 빈 목록을 정상적으로 반환하는지 확인합니다.
        - **시나리오**:
            - 테스트 사용자를 생성하지만 예측 이력은 생성하지 않습니다.
            - 해당 사용자의 ID로 API를 호출합니다.
            - 200 OK 응답과 함께 빈 이력 목록이 반환되는지 확인합니다.
        - **Mock 대상**: 없음
        """
        # Given: 사용자만 생성
>       user = create_test_user(real_db)

tests/integration/test_api_prediction_history_integration.py:106: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/helpers.py:14: in create_test_user
    user = User(
<string>:4: in __init__
    ???
/usr/local/lib/python3.10/site-packages/sqlalchemy/orm/state.py:571: in _initialize_instance
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/orm/state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.common.models.user.User object at 0x7f77b6368cd0>
kwargs = {'email': 'test_6f879431cca742eda4253c55d455c4b8@example.com', 'is_active': True, 'password_hash': '$2b$12$Q8M7XOyOjQ/XGV5tcEmh4uR3QNpLvmCeNCvd66XOz4utmeVBQLnEy', 'role': 'user', ...}
cls_ = <class 'src.common.models.user.User'>, k = 'password_hash'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'password_hash' is an invalid keyword argument for User

/usr/local/lib/python3.10/site-packages/sqlalchemy/orm/decl_base.py:2179: TypeError
---------------------------- Captured stdout setup -----------------------------
2025-08-31 17:51:50,378 - asyncio - DEBUG - Using selector: EpollSelector
2025-08-31 17:51:50,392 - src.api.main - INFO - 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
2025-08-31 17:51:50,603 - src.api.main - INFO - 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 17:51:50,624 - src.api.main - INFO - 테스트 StockMaster 데이터 시딩 완료.
2025-08-31 17:51:50,625 - src.api.main - INFO - 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 17:51:50,638 - src.api.main - INFO - 테스트 DailyPrice 데이터 시딩 완료.
------------------------------ Captured log setup ------------------------------
DEBUG    asyncio:selector_events.py:54 Using selector: EpollSelector
INFO     src.api.main:main.py:58 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
INFO     src.api.main:main.py:62 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:77 테스트 StockMaster 데이터 시딩 완료.
INFO     src.api.main:main.py:80 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:106 테스트 DailyPrice 데이터 시딩 완료.
______ TestPredictionHistoryRouter.test_get_prediction_history_pagination ______

self = <test_api_prediction_history_integration.TestPredictionHistoryRouter object at 0x7f77b61bd4e0>
client = <starlette.testclient.TestClient object at 0x7f77b635dd20>
real_db = <sqlalchemy.orm.session.Session object at 0x7f77b635d090>

    def test_get_prediction_history_pagination(self, client: TestClient, real_db: Session):
        """
        - **테스트 대상**: `GET /prediction/history/{user_id}`
        - **목적**: 페이지네이션(페이지 번호, 페이지 크기) 기능이 정상적으로 동작하는지 확인합니다.
        - **시나리오**:
            - 14개의 예측 이력 데이터를 생성합니다.
            - 첫 번째 페이지(크기 5)를 요청하고, 5개의 데이터가 최신순으로 반환되는지 확인합니다.
            - 두 번째 페이지(크기 5)를 요청하고, 다음 5개의 데이터가 최신순으로 반환되는지 확인합니다.
        - **Mock 대상**: 없음
        """
        # Given: 14개의 테스트 데이터 생성
>       user = create_test_user(real_db)

tests/integration/test_api_prediction_history_integration.py:126: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/helpers.py:14: in create_test_user
    user = User(
<string>:4: in __init__
    ???
/usr/local/lib/python3.10/site-packages/sqlalchemy/orm/state.py:571: in _initialize_instance
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/orm/state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.common.models.user.User object at 0x7f77b636cd90>
kwargs = {'email': 'test_425a1f522a5d4ae8aaa2ba73c36d02b2@example.com', 'is_active': True, 'password_hash': '$2b$12$vj6qHymtpqDG32F1t0JPkOtVi1UHGIMLmD1MvIuL4jrGh1JsOFmE.', 'role': 'user', ...}
cls_ = <class 'src.common.models.user.User'>, k = 'password_hash'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'password_hash' is an invalid keyword argument for User

/usr/local/lib/python3.10/site-packages/sqlalchemy/orm/decl_base.py:2179: TypeError
---------------------------- Captured stdout setup -----------------------------
2025-08-31 17:51:51,264 - asyncio - DEBUG - Using selector: EpollSelector
2025-08-31 17:51:51,273 - src.api.main - INFO - 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
2025-08-31 17:51:51,438 - src.api.main - INFO - 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 17:51:51,446 - src.api.main - INFO - 테스트 StockMaster 데이터 시딩 완료.
2025-08-31 17:51:51,446 - src.api.main - INFO - 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 17:51:51,455 - src.api.main - INFO - 테스트 DailyPrice 데이터 시딩 완료.
------------------------------ Captured log setup ------------------------------
DEBUG    asyncio:selector_events.py:54 Using selector: EpollSelector
INFO     src.api.main:main.py:58 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
INFO     src.api.main:main.py:62 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:77 테스트 StockMaster 데이터 시딩 완료.
INFO     src.api.main:main.py:80 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:106 테스트 DailyPrice 데이터 시딩 완료.
___ TestPredictionHistoryRouter.test_get_prediction_history_filter_by_symbol ___

self = <test_api_prediction_history_integration.TestPredictionHistoryRouter object at 0x7f77b61bd0f0>
client = <starlette.testclient.TestClient object at 0x7f77b621bb20>
real_db = <sqlalchemy.orm.session.Session object at 0x7f77b621b8e0>

    def test_get_prediction_history_filter_by_symbol(self, client: TestClient, real_db: Session):
        """
        - **테스트 대상**: `GET /prediction/history/{user_id}`
        - **목적**: 특정 종목 코드로 예측 이력을 필터링하는 기능이 정상적으로 동작하는지 확인합니다.
        - **시나리오**:
            - 여러 종목의 예측 이력을 생성합니다.
            - 특정 종목 코드(`005930`)를 쿼리 파라미터로 전달하여 API를 호출합니다.
            - 해당 종목의 이력만 반환되는지 확인합니다.
        - **Mock 대상**: 없음
        """
        # Given: 다양한 예측 이력 데이터 생성
>       user = create_test_user(real_db)

tests/integration/test_api_prediction_history_integration.py:163: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/helpers.py:14: in create_test_user
    user = User(
<string>:4: in __init__
    ???
/usr/local/lib/python3.10/site-packages/sqlalchemy/orm/state.py:571: in _initialize_instance
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/orm/state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.common.models.user.User object at 0x7f77b62184c0>
kwargs = {'email': 'test_590e91dcabc74e969bffc8b80d996b1b@example.com', 'is_active': True, 'password_hash': '$2b$12$n34le6eGixvtWXjYGPN7Z.AIGE15PMtLhhGBQPQvCR11fEvZyCX9u', 'role': 'user', ...}
cls_ = <class 'src.common.models.user.User'>, k = 'password_hash'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'password_hash' is an invalid keyword argument for User

/usr/local/lib/python3.10/site-packages/sqlalchemy/orm/decl_base.py:2179: TypeError
---------------------------- Captured stdout setup -----------------------------
2025-08-31 17:51:52,313 - asyncio - DEBUG - Using selector: EpollSelector
2025-08-31 17:51:52,327 - src.api.main - INFO - 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
2025-08-31 17:51:52,518 - src.api.main - INFO - 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 17:51:52,524 - src.api.main - INFO - 테스트 StockMaster 데이터 시딩 완료.
2025-08-31 17:51:52,524 - src.api.main - INFO - 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 17:51:52,536 - src.api.main - INFO - 테스트 DailyPrice 데이터 시딩 완료.
------------------------------ Captured log setup ------------------------------
DEBUG    asyncio:selector_events.py:54 Using selector: EpollSelector
INFO     src.api.main:main.py:58 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
INFO     src.api.main:main.py:62 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:77 테스트 StockMaster 데이터 시딩 완료.
INFO     src.api.main:main.py:80 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:106 테스트 DailyPrice 데이터 시딩 완료.
_ TestPredictionHistoryRouter.test_get_prediction_history_filter_by_prediction _

self = <test_api_prediction_history_integration.TestPredictionHistoryRouter object at 0x7f77b61bd810>
client = <starlette.testclient.TestClient object at 0x7f77b635fe50>
real_db = <sqlalchemy.orm.session.Session object at 0x7f77b635e500>

    def test_get_prediction_history_filter_by_prediction(self, client: TestClient, real_db: Session):
        """
        - **테스트 대상**: `GET /prediction/history/{user_id}`
        - **목적**: 특정 예측 결과로 이력을 필터링하는 기능이 정상적으로 동작하는지 확인합니다.
        - **시나리오**:
            - 여러 예측 결과(상승, 하락, 유지)를 포함하는 이력을 생성합니다.
            - 특정 예측 결과(`상승`)를 쿼리 파라미터로 전달하여 API를 호출합니다.
            - 해당 예측 결과의 이력만 반환되는지 확인합니다.
        - **Mock 대상**: 없음
        """
        # Given: 다양한 예측 이력 데이터 생성
>       user = create_test_user(real_db)

tests/integration/test_api_prediction_history_integration.py:188: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/helpers.py:14: in create_test_user
    user = User(
<string>:4: in __init__
    ???
/usr/local/lib/python3.10/site-packages/sqlalchemy/orm/state.py:571: in _initialize_instance
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/orm/state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.common.models.user.User object at 0x7f77b621a7a0>
kwargs = {'email': 'test_8a98968d7b804ef6933682aad6c45f02@example.com', 'is_active': True, 'password_hash': '$2b$12$7JVbpsciFrD1Zs9OTHCdYOmdCuG18y5Hu8Y5a0EWBTmjJ/rUSF4By', 'role': 'user', ...}
cls_ = <class 'src.common.models.user.User'>, k = 'password_hash'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'password_hash' is an invalid keyword argument for User

/usr/local/lib/python3.10/site-packages/sqlalchemy/orm/decl_base.py:2179: TypeError
---------------------------- Captured stdout setup -----------------------------
2025-08-31 17:51:53,187 - asyncio - DEBUG - Using selector: EpollSelector
2025-08-31 17:51:53,197 - src.api.main - INFO - 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
2025-08-31 17:51:53,377 - src.api.main - INFO - 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 17:51:53,385 - src.api.main - INFO - 테스트 StockMaster 데이터 시딩 완료.
2025-08-31 17:51:53,385 - src.api.main - INFO - 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 17:51:53,397 - src.api.main - INFO - 테스트 DailyPrice 데이터 시딩 완료.
------------------------------ Captured log setup ------------------------------
DEBUG    asyncio:selector_events.py:54 Using selector: EpollSelector
INFO     src.api.main:main.py:58 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
INFO     src.api.main:main.py:62 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:77 테스트 StockMaster 데이터 시딩 완료.
INFO     src.api.main:main.py:80 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:106 테스트 DailyPrice 데이터 시딩 완료.
_ TestPredictionHistoryRouter.test_get_prediction_history_filter_by_symbol_and_prediction _

self = <test_api_prediction_history_integration.TestPredictionHistoryRouter object at 0x7f77b61bd660>
client = <starlette.testclient.TestClient object at 0x7f77b635d900>
real_db = <sqlalchemy.orm.session.Session object at 0x7f77b635ce20>

    def test_get_prediction_history_filter_by_symbol_and_prediction(self, client: TestClient, real_db: Session):
        """
        - **테스트 대상**: `GET /prediction/history/{user_id}`
        - **목적**: 종목 코드와 예측 결과를 동시에 사용하여 이력을 필터링하는 기능이 정상 동작하는지 확인합니다.
        - **시나리오**:
            - 여러 예측 이력을 생성합니다.
            - 특정 종목 코드와 예측 결과를 쿼리 파라미터로 전달하여 API를 호출합니다.
            - 두 조건을 모두 만족하는 이력만 반환되는지 확인합니다.
        - **Mock 대상**: 없음
        """
        # Given: 다양한 예측 이력 데이터 생성
>       user = create_test_user(real_db)

tests/integration/test_api_prediction_history_integration.py:213: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/helpers.py:14: in create_test_user
    user = User(
<string>:4: in __init__
    ???
/usr/local/lib/python3.10/site-packages/sqlalchemy/orm/state.py:571: in _initialize_instance
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/orm/state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.common.models.user.User object at 0x7f77b635ca00>
kwargs = {'email': 'test_1c8fd758682c4ebca803bbbf1c12a747@example.com', 'is_active': True, 'password_hash': '$2b$12$ub7B2ZJLTlXIfYB3FzBSoePA5G069AmOKGT6Qn3b6WDjYYh2J0clG', 'role': 'user', ...}
cls_ = <class 'src.common.models.user.User'>, k = 'password_hash'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'password_hash' is an invalid keyword argument for User

/usr/local/lib/python3.10/site-packages/sqlalchemy/orm/decl_base.py:2179: TypeError
---------------------------- Captured stdout setup -----------------------------
2025-08-31 17:51:54,368 - asyncio - DEBUG - Using selector: EpollSelector
2025-08-31 17:51:54,386 - src.api.main - INFO - 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
2025-08-31 17:51:54,558 - src.api.main - INFO - 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 17:51:54,565 - src.api.main - INFO - 테스트 StockMaster 데이터 시딩 완료.
2025-08-31 17:51:54,566 - src.api.main - INFO - 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 17:51:54,579 - src.api.main - INFO - 테스트 DailyPrice 데이터 시딩 완료.
------------------------------ Captured log setup ------------------------------
DEBUG    asyncio:selector_events.py:54 Using selector: EpollSelector
INFO     src.api.main:main.py:58 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
INFO     src.api.main:main.py:62 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:77 테스트 StockMaster 데이터 시딩 완료.
INFO     src.api.main:main.py:80 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:106 테스트 DailyPrice 데이터 시딩 완료.
=============================== warnings summary ===============================
../../../usr/local/lib/python3.10/site-packages/pydantic/_internal/_config.py:323
../../../usr/local/lib/python3.10/site-packages/pydantic/_internal/_config.py:323
../../../usr/local/lib/python3.10/site-packages/pydantic/_internal/_config.py:323
  /usr/local/lib/python3.10/site-packages/pydantic/_internal/_config.py:323: PydanticDeprecatedSince20: Support for class-based `config` is deprecated, use ConfigDict instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.11/migration/
    warnings.warn(DEPRECATION_MESSAGE, DeprecationWarning)

../../../usr/local/lib/python3.10/site-packages/pydantic/_internal/_config.py:373
  /usr/local/lib/python3.10/site-packages/pydantic/_internal/_config.py:373: UserWarning: Valid config keys have changed in V2:
  * 'orm_mode' has been renamed to 'from_attributes'
    warnings.warn(message, UserWarning)

main.py:112
  /app/src/api/main.py:112: DeprecationWarning: 
          on_event is deprecated, use lifespan event handlers instead.
  
          Read more about it in the
          [FastAPI docs for Lifespan Events](https://fastapi.tiangolo.com/advanced/events/).
          
    @app.on_event("startup")

../../../usr/local/lib/python3.10/site-packages/fastapi/applications.py:4495
  /usr/local/lib/python3.10/site-packages/fastapi/applications.py:4495: DeprecationWarning: 
          on_event is deprecated, use lifespan event handlers instead.
  
          Read more about it in the
          [FastAPI docs for Lifespan Events](https://fastapi.tiangolo.com/advanced/events/).
          
    return self.router.on_event(event_type)

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
=========================== short test summary info ============================
FAILED tests/integration/test_api_prediction_history_integration.py::TestPredictionHistoryRouter::test_get_prediction_history_success
FAILED tests/integration/test_api_prediction_history_integration.py::TestPredictionHistoryRouter::test_get_prediction_history_not_found_user
FAILED tests/integration/test_api_prediction_history_integration.py::TestPredictionHistoryRouter::test_get_prediction_history_empty
FAILED tests/integration/test_api_prediction_history_integration.py::TestPredictionHistoryRouter::test_get_prediction_history_pagination
FAILED tests/integration/test_api_prediction_history_integration.py::TestPredictionHistoryRouter::test_get_prediction_history_filter_by_symbol
FAILED tests/integration/test_api_prediction_history_integration.py::TestPredictionHistoryRouter::test_get_prediction_history_filter_by_prediction
FAILED tests/integration/test_api_prediction_history_integration.py::TestPredictionHistoryRouter::test_get_prediction_history_filter_by_symbol_and_prediction
======================== 7 failed, 6 warnings in 7.83s =========================
\n--- Running test_admin_scheduler_integration.py ---

\n--- Running test_admin_scheduler_integration.py (60s timeout) ---
============================= test session starts ==============================
platform linux -- Python 3.10.18, pytest-8.4.1, pluggy-1.6.0
rootdir: /app/src/api
plugins: cov-6.2.1, timeout-2.4.0, anyio-4.10.0, asyncio-1.1.0
asyncio: mode=strict, asyncio_default_fixture_loop_scope=None, asyncio_default_test_loop_scope=function
collected 1 item

tests/integration/test_admin_scheduler_integration.py .                  [100%]

=============================== warnings summary ===============================
../../../usr/local/lib/python3.10/site-packages/pydantic/_internal/_config.py:323
../../../usr/local/lib/python3.10/site-packages/pydantic/_internal/_config.py:323
../../../usr/local/lib/python3.10/site-packages/pydantic/_internal/_config.py:323
  /usr/local/lib/python3.10/site-packages/pydantic/_internal/_config.py:323: PydanticDeprecatedSince20: Support for class-based `config` is deprecated, use ConfigDict instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.11/migration/
    warnings.warn(DEPRECATION_MESSAGE, DeprecationWarning)

../../../usr/local/lib/python3.10/site-packages/pydantic/_internal/_config.py:373
  /usr/local/lib/python3.10/site-packages/pydantic/_internal/_config.py:373: UserWarning: Valid config keys have changed in V2:
  * 'orm_mode' has been renamed to 'from_attributes'
    warnings.warn(message, UserWarning)

main.py:112
  /app/src/api/main.py:112: DeprecationWarning: 
          on_event is deprecated, use lifespan event handlers instead.
  
          Read more about it in the
          [FastAPI docs for Lifespan Events](https://fastapi.tiangolo.com/advanced/events/).
          
    @app.on_event("startup")

../../../usr/local/lib/python3.10/site-packages/fastapi/applications.py:4495
  /usr/local/lib/python3.10/site-packages/fastapi/applications.py:4495: DeprecationWarning: 
          on_event is deprecated, use lifespan event handlers instead.
  
          Read more about it in the
          [FastAPI docs for Lifespan Events](https://fastapi.tiangolo.com/advanced/events/).
          
    return self.router.on_event(event_type)

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
======================== 1 passed, 6 warnings in 0.08s =========================
\n--- Running test_stock_service_integration.py ---
============================= test session starts ==============================
platform linux -- Python 3.10.18, pytest-8.4.1, pluggy-1.6.0
rootdir: /app/src/api
plugins: cov-6.2.1, timeout-2.4.0, anyio-4.10.0, asyncio-1.1.0
asyncio: mode=strict, asyncio_default_fixture_loop_scope=None, asyncio_default_test_loop_scope=function
collected 31 items

tests/integration/test_stock_service_integration.py 
\n--- Running test_stock_service_integration.py (60s timeout) ---
============================= test session starts ==============================
platform linux -- Python 3.10.18, pytest-8.4.1, pluggy-1.6.0
rootdir: /app/src/api
plugins: cov-6.2.1, timeout-2.4.0, anyio-4.10.0, asyncio-1.1.0
asyncio: mode=strict, asyncio_default_fixture_loop_scope=None, asyncio_default_test_loop_scope=function
collected 31 items

tests/integration/test_stock_service_integration.py F
\n--- Running test_price_alert_service_integration.py ---
============================= test session starts ==============================
platform linux -- Python 3.10.18, pytest-8.4.1, pluggy-1.6.0
rootdir: /app/src/api
plugins: cov-6.2.1, timeout-2.4.0, anyio-4.10.0, asyncio-1.1.0
asyncio: mode=strict, asyncio_default_fixture_loop_scope=None, asyncio_default_test_loop_scope=function
collected 1 item

tests/integration/test_price_alert_service_integration.py F              [100%]

=================================== FAILURES ===================================
____________ test_check_price_alerts_publishes_to_redis_on_trigger _____________

price_alert_service = <src.common.services.price_alert_service.PriceAlertService object at 0x7f17550a3a60>
real_db = <sqlalchemy.orm.session.Session object at 0x7f17550a3940>

    @pytest.mark.asyncio
    async def test_check_price_alerts_publishes_to_redis_on_trigger(price_alert_service, real_db):
        """알림 조건 충족 시 check_price_alerts가 Redis에 메시지를 발행하는지 통합 테스트"""
        # 1. Redis 구독 클라이언트 설정
        redis_client = redis.Redis(host=REDIS_HOST, port=REDIS_PORT, decode_responses=True)
        pubsub = redis_client.pubsub()
        await pubsub.subscribe("notifications")
        await asyncio.sleep(0.1)
    
        # 2. Given: 테스트 데이터 설정
        # 사용자 생성
>       test_user = User(id=1, username="testuser", email="test@example.com", telegram_id="12345", password_hash="hashed_password")

tests/integration/test_price_alert_service_integration.py:42: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
<string>:4: in __init__
    ???
/usr/local/lib/python3.10/site-packages/sqlalchemy/orm/state.py:571: in _initialize_instance
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/orm/state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.common.models.user.User object at 0x7f1754f515d0>
kwargs = {'email': 'test@example.com', 'id': 1, 'password_hash': 'hashed_password', 'telegram_id': '12345', ...}
cls_ = <class 'src.common.models.user.User'>, k = 'password_hash'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'password_hash' is an invalid keyword argument for User

/usr/local/lib/python3.10/site-packages/sqlalchemy/orm/decl_base.py:2179: TypeError
---------------------------- Captured stdout setup -----------------------------
2025-08-31 18:01:59,075 - src.common.services.price_alert_service - DEBUG - PriceAlertService 초기화.
2025-08-31 18:01:59,434 - asyncio - DEBUG - Using selector: EpollSelector
2025-08-31 18:01:59,435 - asyncio - DEBUG - Using selector: EpollSelector
------------------------------ Captured log setup ------------------------------
DEBUG    src.common.services.price_alert_service:price_alert_service.py:21 PriceAlertService 초기화.
DEBUG    asyncio:selector_events.py:54 Using selector: EpollSelector
DEBUG    asyncio:selector_events.py:54 Using selector: EpollSelector
=============================== warnings summary ===============================
../../../usr/local/lib/python3.10/site-packages/pydantic/_internal/_config.py:323
../../../usr/local/lib/python3.10/site-packages/pydantic/_internal/_config.py:323
../../../usr/local/lib/python3.10/site-packages/pydantic/_internal/_config.py:323
  /usr/local/lib/python3.10/site-packages/pydantic/_internal/_config.py:323: PydanticDeprecatedSince20: Support for class-based `config` is deprecated, use ConfigDict instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.11/migration/
    warnings.warn(DEPRECATION_MESSAGE, DeprecationWarning)

../../../usr/local/lib/python3.10/site-packages/pydantic/_internal/_config.py:373
  /usr/local/lib/python3.10/site-packages/pydantic/_internal/_config.py:373: UserWarning: Valid config keys have changed in V2:
  * 'orm_mode' has been renamed to 'from_attributes'
    warnings.warn(message, UserWarning)

main.py:112
  /app/src/api/main.py:112: DeprecationWarning: 
          on_event is deprecated, use lifespan event handlers instead.
  
          Read more about it in the
          [FastAPI docs for Lifespan Events](https://fastapi.tiangolo.com/advanced/events/).
          
    @app.on_event("startup")

../../../usr/local/lib/python3.10/site-packages/fastapi/applications.py:4495
  /usr/local/lib/python3.10/site-packages/fastapi/applications.py:4495: DeprecationWarning: 
          on_event is deprecated, use lifespan event handlers instead.
  
          Read more about it in the
          [FastAPI docs for Lifespan Events](https://fastapi.tiangolo.com/advanced/events/).
          
    return self.router.on_event(event_type)

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
=========================== short test summary info ============================
FAILED tests/integration/test_price_alert_service_integration.py::test_check_price_alerts_publishes_to_redis_on_trigger
======================== 1 failed, 6 warnings in 4.56s =========================
\n--- Running test_price_alert_service_integration.py ---
============================= test session starts ==============================
platform linux -- Python 3.10.18, pytest-8.4.1, pluggy-1.6.0
rootdir: /app/src/api
plugins: cov-6.2.1, timeout-2.4.0, anyio-4.10.0, asyncio-1.1.0
asyncio: mode=strict, asyncio_default_fixture_loop_scope=None, asyncio_default_test_loop_scope=function
collected 1 item

tests/integration/test_price_alert_service_integration.py .              [100%]

=============================== warnings summary ===============================
../../../usr/local/lib/python3.10/site-packages/pydantic/_internal/_config.py:323
../../../usr/local/lib/python3.10/site-packages/pydantic/_internal/_config.py:323
../../../usr/local/lib/python3.10/site-packages/pydantic/_internal/_config.py:323
  /usr/local/lib/python3.10/site-packages/pydantic/_internal/_config.py:323: PydanticDeprecatedSince20: Support for class-based `config` is deprecated, use ConfigDict instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.11/migration/
    warnings.warn(DEPRECATION_MESSAGE, DeprecationWarning)

../../../usr/local/lib/python3.10/site-packages/pydantic/_internal/_config.py:373
  /usr/local/lib/python3.10/site-packages/pydantic/_internal/_config.py:373: UserWarning: Valid config keys have changed in V2:
  * 'orm_mode' has been renamed to 'from_attributes'
    warnings.warn(message, UserWarning)

main.py:112
  /app/src/api/main.py:112: DeprecationWarning: 
          on_event is deprecated, use lifespan event handlers instead.
  
          Read more about it in the
          [FastAPI docs for Lifespan Events](https://fastapi.tiangolo.com/advanced/events/).
          
    @app.on_event("startup")

../../../usr/local/lib/python3.10/site-packages/fastapi/applications.py:4495
  /usr/local/lib/python3.10/site-packages/fastapi/applications.py:4495: DeprecationWarning: 
          on_event is deprecated, use lifespan event handlers instead.
  
          Read more about it in the
          [FastAPI docs for Lifespan Events](https://fastapi.tiangolo.com/advanced/events/).
          
    return self.router.on_event(event_type)

tests/integration/test_price_alert_service_integration.py::test_check_price_alerts_publishes_to_redis_on_trigger
  /app/src/common/services/price_alert_service.py:144: DeprecationWarning: Call to deprecated close. (Use aclose() instead) -- Deprecated since version 5.0.1.
    await redis_client.close()

tests/integration/test_price_alert_service_integration.py::test_check_price_alerts_publishes_to_redis_on_trigger
  /app/src/api/tests/integration/test_price_alert_service_integration.py:84: DeprecationWarning: Call to deprecated close. (Use aclose() instead) -- Deprecated since version 5.0.1.
    await redis_client.close()

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
======================== 1 passed, 8 warnings in 1.34s =========================
\n--- Running test_api_admin_integration.py ---
============================= test session starts ==============================
platform linux -- Python 3.10.18, pytest-8.4.1, pluggy-1.6.0
rootdir: /app/src/api
plugins: cov-6.2.1, timeout-2.4.0, anyio-4.10.0, asyncio-1.1.0
asyncio: mode=strict, asyncio_default_fixture_loop_scope=None, asyncio_default_test_loop_scope=function
collected 24 items

tests/integration/test_api_admin_integration.py FFFFFFFFFFFFFFFFFFFFFFFF [100%]

=================================== FAILURES ===================================
__________________ TestAdminRouter.test_admin_stats_as_admin ___________________

self = <test_api_admin_integration.TestAdminRouter object at 0x7ffb1000c1f0>
client = <starlette.testclient.TestClient object at 0x7ffb1000c4c0>
admin_user_and_headers = (<src.common.models.user.User object at 0x7ffb10117910>, {'Authorization': 'Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ...Y1Nzg5NTIwIiwicm9sZSI6ImFkbWluIiwidXNlcl9pZCI6MSwiZXhwIjoxNzU2NjY1MTcwfQ.WQnJnYLVfEfG578jis9Aub3IjezYbavumrbWvE13IEE'})

    def test_admin_stats_as_admin(self, client: TestClient, admin_user_and_headers):
        """
        - **테스트 대상**: `GET /admin/admin_stats`
        - **목적**: 관리자가 시스템 통계 정보를 정상적으로 조회하는지 확인합니다.
        - **시나리오**:
            - 관리자 사용자로 인증합니다.
            - 통계 API를 호출합니다.
        - **Mock 대상**: `get_current_active_admin_user` (의존성 주입 오버라이드)
        """
        admin_user, headers = admin_user_and_headers
        app.dependency_overrides[get_current_active_admin_user] = lambda: admin_user
    
        response = client.get("/admin/admin_stats", headers=headers)
    
>       assert response.status_code == 200
E       assert 404 == 200
E        +  where 404 = <Response [404 Not Found]>.status_code

tests/integration/test_api_admin_integration.py:76: AssertionError
---------------------------- Captured stdout setup -----------------------------
2025-08-31 18:02:49,253 - asyncio - DEBUG - Using selector: EpollSelector
2025-08-31 18:02:49,321 - src.api.main - INFO - 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
2025-08-31 18:02:49,586 - src.api.main - INFO - 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 18:02:49,615 - src.api.main - INFO - 테스트 StockMaster 데이터 시딩 완료.
2025-08-31 18:02:49,615 - src.api.main - INFO - 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 18:02:49,741 - src.api.main - INFO - 테스트 DailyPrice 데이터 시딩 완료.
2025-08-31 18:02:49,743 - passlib.handlers.bcrypt - WARNING - (trapped) error reading bcrypt version
Traceback (most recent call last):
  File "/usr/local/lib/python3.10/site-packages/passlib/handlers/bcrypt.py", line 620, in _load_backend_mixin
    version = _bcrypt.__about__.__version__
AttributeError: module 'bcrypt' has no attribute '__about__'
2025-08-31 18:02:49,746 - passlib.handlers.bcrypt - DEBUG - detected 'bcrypt' backend, version '<unknown>'
2025-08-31 18:02:49,747 - passlib.handlers.bcrypt - DEBUG - 'bcrypt' backend lacks $2$ support, enabling workaround
------------------------------ Captured log setup ------------------------------
DEBUG    asyncio:selector_events.py:54 Using selector: EpollSelector
INFO     src.api.main:main.py:58 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
INFO     src.api.main:main.py:62 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:77 테스트 StockMaster 데이터 시딩 완료.
INFO     src.api.main:main.py:80 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:106 테스트 DailyPrice 데이터 시딩 완료.
WARNING  passlib.handlers.bcrypt:bcrypt.py:622 (trapped) error reading bcrypt version
Traceback (most recent call last):
  File "/usr/local/lib/python3.10/site-packages/passlib/handlers/bcrypt.py", line 620, in _load_backend_mixin
    version = _bcrypt.__about__.__version__
AttributeError: module 'bcrypt' has no attribute '__about__'
DEBUG    passlib.handlers.bcrypt:bcrypt.py:625 detected 'bcrypt' backend, version '<unknown>'
DEBUG    passlib.handlers.bcrypt:bcrypt.py:406 'bcrypt' backend lacks $2$ support, enabling workaround
----------------------------- Captured stdout call -----------------------------
2025-08-31 18:02:50,065 - httpx - INFO - HTTP Request: GET http://testserver/admin/admin_stats "HTTP/1.1 404 Not Found"
------------------------------ Captured log call -------------------------------
INFO     httpx:_client.py:1025 HTTP Request: GET http://testserver/admin/admin_stats "HTTP/1.1 404 Not Found"
_______________ TestAdminRouter.test_admin_stats_as_normal_user ________________

self = <test_api_admin_integration.TestAdminRouter object at 0x7ffb1000c3d0>
client = <starlette.testclient.TestClient object at 0x7ffb1005b880>
normal_user_and_headers = (<src.common.models.user.User object at 0x7ffb1009ca00>, {'Authorization': 'Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ...MTEzNDk2ZGIwIiwicm9sZSI6InVzZXIiLCJ1c2VyX2lkIjoxLCJleHAiOjE3NTY2NjUxNzB9.y3I_hDo5i4JRgBkiJFV9Eb5C05AVfUHGv9JRRk1y-iQ'})

    def test_admin_stats_as_normal_user(self, client: TestClient, normal_user_and_headers):
        """
        - **테스트 대상**: `GET /admin/admin_stats`
        - **목적**: 일반 사용자가 관리자 API에 접근할 수 없는지 확인합니다 (권한 거부).
        - **시나리오**:
            - 일반 사용자로 인증합니다.
            - 통계 API를 호출합니다.
        - **Mock 대상**: 없음 (실제 권한 처리 로직 검증)
        """
        _, headers = normal_user_and_headers
        response = client.get("/admin/admin_stats", headers=headers)
>       assert response.status_code == 403
E       assert 404 == 403
E        +  where 404 = <Response [404 Not Found]>.status_code

tests/integration/test_api_admin_integration.py:95: AssertionError
---------------------------- Captured stdout setup -----------------------------
2025-08-31 18:02:50,335 - asyncio - DEBUG - Using selector: EpollSelector
2025-08-31 18:02:50,342 - src.api.main - INFO - 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
2025-08-31 18:02:50,512 - src.api.main - INFO - 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 18:02:50,519 - src.api.main - INFO - 테스트 StockMaster 데이터 시딩 완료.
2025-08-31 18:02:50,520 - src.api.main - INFO - 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 18:02:50,530 - src.api.main - INFO - 테스트 DailyPrice 데이터 시딩 완료.
------------------------------ Captured log setup ------------------------------
DEBUG    asyncio:selector_events.py:54 Using selector: EpollSelector
INFO     src.api.main:main.py:58 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
INFO     src.api.main:main.py:62 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:77 테스트 StockMaster 데이터 시딩 완료.
INFO     src.api.main:main.py:80 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:106 테스트 DailyPrice 데이터 시딩 완료.
----------------------------- Captured stdout call -----------------------------
2025-08-31 18:02:50,783 - httpx - INFO - HTTP Request: GET http://testserver/admin/admin_stats "HTTP/1.1 404 Not Found"
------------------------------ Captured log call -------------------------------
INFO     httpx:_client.py:1025 HTTP Request: GET http://testserver/admin/admin_stats "HTTP/1.1 404 Not Found"
_______________ TestAdminRouter.test_admin_stats_unauthenticated _______________

self = <test_api_admin_integration.TestAdminRouter object at 0x7ffb1000c5e0>
client = <starlette.testclient.TestClient object at 0x7ffb100e0e20>

    def test_admin_stats_unauthenticated(self, client: TestClient):
        """
        - **테스트 대상**: `GET /admin/admin_stats`
        - **목적**: 인증되지 않은 사용자가 관리자 API 접근 시 401 에러를 받는지 확인합니다.
        - **시나리오**:
            - 인증 헤더 없이 통계 API를 호출합니다.
        - **Mock 대상**: 없음 (실제 인증 처리 로직 검증)
        """
        response = client.get("/admin/admin_stats")
>       assert response.status_code == 401
E       assert 404 == 401
E        +  where 404 = <Response [404 Not Found]>.status_code

tests/integration/test_api_admin_integration.py:106: AssertionError
---------------------------- Captured stdout setup -----------------------------
2025-08-31 18:02:50,962 - asyncio - DEBUG - Using selector: EpollSelector
2025-08-31 18:02:50,971 - src.api.main - INFO - 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
2025-08-31 18:02:51,132 - src.api.main - INFO - 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 18:02:51,138 - src.api.main - INFO - 테스트 StockMaster 데이터 시딩 완료.
2025-08-31 18:02:51,138 - src.api.main - INFO - 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 18:02:51,148 - src.api.main - INFO - 테스트 DailyPrice 데이터 시딩 완료.
------------------------------ Captured log setup ------------------------------
DEBUG    asyncio:selector_events.py:54 Using selector: EpollSelector
INFO     src.api.main:main.py:58 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
INFO     src.api.main:main.py:62 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:77 테스트 StockMaster 데이터 시딩 완료.
INFO     src.api.main:main.py:80 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:106 테스트 DailyPrice 데이터 시딩 완료.
----------------------------- Captured stdout call -----------------------------
2025-08-31 18:02:51,151 - httpx - INFO - HTTP Request: GET http://testserver/admin/admin_stats "HTTP/1.1 404 Not Found"
------------------------------ Captured log call -------------------------------
INFO     httpx:_client.py:1025 HTTP Request: GET http://testserver/admin/admin_stats "HTTP/1.1 404 Not Found"
_____________ TestAdminRouter.test_update_master_success_as_admin ______________

self = <test_api_admin_integration.TestAdminRouter object at 0x7ffb1000c820>
mock_update_stock_master = <AsyncMock name='update_stock_master' id='140716272300768'>
client = <starlette.testclient.TestClient object at 0x7ffb0f6cb1f0>
admin_user_and_headers = (<src.common.models.user.User object at 0x7ffb0f6c9f30>, {'Authorization': 'Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ...I5M2EyOWEzIiwicm9sZSI6ImFkbWluIiwidXNlcl9pZCI6MSwiZXhwIjoxNzU2NjY1MTcxfQ.V4LJZoB5Z90sAHDaeQaPnRvl_lsoPisTm9KyXZ-Q6aA'})

    @patch('src.api.routers.admin.StockService.update_stock_master')
    def test_update_master_success_as_admin(self, mock_update_stock_master, client: TestClient, admin_user_and_headers):
        """
        - **테스트 대상**: `POST /admin/update_master`
        - **목적**: 관리자가 종목 마스터 정보 갱신을 성공적으로 요청하는지 확인합니다.
        - **시나리오**:
            - 관리자로 인증합니다.
            - 종목 마스터 갱신 API를 호출합니다.
        - **Mock 대상**:
            - `src.api.routers.admin.StockService.update_stock_master` (외부 서비스 호출)
            - `get_current_active_admin_user` (의존성 주입 오버라이드)
        """
        admin_user, headers = admin_user_and_headers
        app.dependency_overrides[get_current_active_admin_user] = lambda: admin_user
    
        mock_update_stock_master.return_value = {"success": True, "updated_count": 100}
        response = client.post("/admin/update_master", headers=headers)
    
>       assert response.status_code == 200
E       assert 404 == 200
E        +  where 404 = <Response [404 Not Found]>.status_code

tests/integration/test_api_admin_integration.py:126: AssertionError
---------------------------- Captured stdout setup -----------------------------
2025-08-31 18:02:51,326 - asyncio - DEBUG - Using selector: EpollSelector
2025-08-31 18:02:51,335 - src.api.main - INFO - 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
2025-08-31 18:02:51,532 - src.api.main - INFO - 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 18:02:51,539 - src.api.main - INFO - 테스트 StockMaster 데이터 시딩 완료.
2025-08-31 18:02:51,540 - src.api.main - INFO - 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 18:02:51,552 - src.api.main - INFO - 테스트 DailyPrice 데이터 시딩 완료.
------------------------------ Captured log setup ------------------------------
DEBUG    asyncio:selector_events.py:54 Using selector: EpollSelector
INFO     src.api.main:main.py:58 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
INFO     src.api.main:main.py:62 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:77 테스트 StockMaster 데이터 시딩 완료.
INFO     src.api.main:main.py:80 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:106 테스트 DailyPrice 데이터 시딩 완료.
----------------------------- Captured stdout call -----------------------------
2025-08-31 18:02:51,880 - httpx - INFO - HTTP Request: POST http://testserver/admin/update_master "HTTP/1.1 404 Not Found"
------------------------------ Captured log call -------------------------------
INFO     httpx:_client.py:1025 HTTP Request: POST http://testserver/admin/update_master "HTTP/1.1 404 Not Found"
_____________ TestAdminRouter.test_update_master_failure_as_admin ______________

self = <test_api_admin_integration.TestAdminRouter object at 0x7ffb1000ca60>
mock_update_stock_master = <AsyncMock name='update_stock_master' id='140716272187328'>
client = <starlette.testclient.TestClient object at 0x7ffb0f6c8d60>
admin_user_and_headers = (<src.common.models.user.User object at 0x7ffb0f6c8e50>, {'Authorization': 'Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ...M4MzMwMzNjIiwicm9sZSI6ImFkbWluIiwidXNlcl9pZCI6MSwiZXhwIjoxNzU2NjY1MTcyfQ.-17fRjIPfkJ__gpQW8KFQHFUrPeGvGj0neDqF_12WAo'})

    @patch('src.api.routers.admin.StockService.update_stock_master')
    def test_update_master_failure_as_admin(self, mock_update_stock_master, client: TestClient, admin_user_and_headers):
        """
        - **테스트 대상**: `POST /admin/update_master`
        - **목적**: 종목 마스터 갱신 중 서버 내부 오류 발생 시 500 에러를 반환하는지 확인합니다.
        - **시나리오**:
            - 관리자로 인증합니다.
            - `update_stock_master` 서비스가 예외를 발생시키도록 설정합니다.
            - API를 호출합니다.
        - **Mock 대상**:
            - `src.api.routers.admin.StockService.update_stock_master` (예외 발생)
            - `get_current_active_admin_user` (의존성 주입 오버라이드)
        """
        admin_user, headers = admin_user_and_headers
        app.dependency_overrides[get_current_active_admin_user] = lambda: admin_user
    
        mock_update_stock_master.side_effect = Exception("DB connection error")
        response = client.post("/admin/update_master", headers=headers)
    
>       assert response.status_code == 500
E       assert 404 == 500
E        +  where 404 = <Response [404 Not Found]>.status_code

tests/integration/test_api_admin_integration.py:153: AssertionError
---------------------------- Captured stdout setup -----------------------------
2025-08-31 18:02:52,049 - asyncio - DEBUG - Using selector: EpollSelector
2025-08-31 18:02:52,059 - src.api.main - INFO - 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
2025-08-31 18:02:52,239 - src.api.main - INFO - 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 18:02:52,248 - src.api.main - INFO - 테스트 StockMaster 데이터 시딩 완료.
2025-08-31 18:02:52,249 - src.api.main - INFO - 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 18:02:52,260 - src.api.main - INFO - 테스트 DailyPrice 데이터 시딩 완료.
------------------------------ Captured log setup ------------------------------
DEBUG    asyncio:selector_events.py:54 Using selector: EpollSelector
INFO     src.api.main:main.py:58 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
INFO     src.api.main:main.py:62 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:77 테스트 StockMaster 데이터 시딩 완료.
INFO     src.api.main:main.py:80 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:106 테스트 DailyPrice 데이터 시딩 완료.
----------------------------- Captured stdout call -----------------------------
2025-08-31 18:02:52,537 - httpx - INFO - HTTP Request: POST http://testserver/admin/update_master "HTTP/1.1 404 Not Found"
------------------------------ Captured log call -------------------------------
INFO     httpx:_client.py:1025 HTTP Request: POST http://testserver/admin/update_master "HTTP/1.1 404 Not Found"
______________ TestAdminRouter.test_update_master_as_normal_user _______________

self = <test_api_admin_integration.TestAdminRouter object at 0x7ffb1000c700>
client = <starlette.testclient.TestClient object at 0x7ffb0f6ca080>
normal_user_and_headers = (<src.common.models.user.User object at 0x7ffb0f6ca8c0>, {'Authorization': 'Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ...YjViZTJiNGE4Iiwicm9sZSI6InVzZXIiLCJ1c2VyX2lkIjoxLCJleHAiOjE3NTY2NjUxNzN9.aq7vOv1S46Zd09vM_XHGdyM3MU9LCoi42NnawvT5qvs'})

    def test_update_master_as_normal_user(self, client: TestClient, normal_user_and_headers):
        """
        - **테스트 대상**: `POST /admin/update_master`
        - **목적**: 일반 사용자가 종목 마스터 갱신 시도 시 403 에러를 받는지 확인합니다.
        - **시나리오**:
            - 일반 사용자로 인증합니다.
            - API를 호출합니다.
        - **Mock 대상**: 없음
        """
        _, headers = normal_user_and_headers
        response = client.post("/admin/update_master", headers=headers)
>       assert response.status_code == 403
E       assert 404 == 403
E        +  where 404 = <Response [404 Not Found]>.status_code

tests/integration/test_api_admin_integration.py:170: AssertionError
---------------------------- Captured stdout setup -----------------------------
2025-08-31 18:02:52,721 - asyncio - DEBUG - Using selector: EpollSelector
2025-08-31 18:02:52,729 - src.api.main - INFO - 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
2025-08-31 18:02:52,879 - src.api.main - INFO - 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 18:02:52,887 - src.api.main - INFO - 테스트 StockMaster 데이터 시딩 완료.
2025-08-31 18:02:52,887 - src.api.main - INFO - 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 18:02:52,896 - src.api.main - INFO - 테스트 DailyPrice 데이터 시딩 완료.
------------------------------ Captured log setup ------------------------------
DEBUG    asyncio:selector_events.py:54 Using selector: EpollSelector
INFO     src.api.main:main.py:58 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
INFO     src.api.main:main.py:62 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:77 테스트 StockMaster 데이터 시딩 완료.
INFO     src.api.main:main.py:80 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:106 테스트 DailyPrice 데이터 시딩 완료.
----------------------------- Captured stdout call -----------------------------
2025-08-31 18:02:53,150 - httpx - INFO - HTTP Request: POST http://testserver/admin/update_master "HTTP/1.1 404 Not Found"
------------------------------ Captured log call -------------------------------
INFO     httpx:_client.py:1025 HTTP Request: POST http://testserver/admin/update_master "HTTP/1.1 404 Not Found"
______________ TestAdminRouter.test_update_master_unauthenticated ______________

self = <test_api_admin_integration.TestAdminRouter object at 0x7ffb1000cbe0>
client = <starlette.testclient.TestClient object at 0x7ffb0f6af760>

    def test_update_master_unauthenticated(self, client: TestClient):
        """
        - **테스트 대상**: `POST /admin/update_master`
        - **목적**: 미인증 사용자가 종목 마스터 갱신 시도 시 401 에러를 받는지 확인합니다.
        - **시나리오**:
            - 인증 헤더 없이 API를 호출합니다.
        - **Mock 대상**: 없음
        """
        response = client.post("/admin/update_master")
>       assert response.status_code == 401
E       assert 404 == 401
E        +  where 404 = <Response [404 Not Found]>.status_code

tests/integration/test_api_admin_integration.py:181: AssertionError
---------------------------- Captured stdout setup -----------------------------
2025-08-31 18:02:53,314 - asyncio - DEBUG - Using selector: EpollSelector
2025-08-31 18:02:53,326 - src.api.main - INFO - 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
2025-08-31 18:02:53,480 - src.api.main - INFO - 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 18:02:53,487 - src.api.main - INFO - 테스트 StockMaster 데이터 시딩 완료.
2025-08-31 18:02:53,488 - src.api.main - INFO - 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 18:02:53,499 - src.api.main - INFO - 테스트 DailyPrice 데이터 시딩 완료.
------------------------------ Captured log setup ------------------------------
DEBUG    asyncio:selector_events.py:54 Using selector: EpollSelector
INFO     src.api.main:main.py:58 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
INFO     src.api.main:main.py:62 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:77 테스트 StockMaster 데이터 시딩 완료.
INFO     src.api.main:main.py:80 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:106 테스트 DailyPrice 데이터 시딩 완료.
----------------------------- Captured stdout call -----------------------------
2025-08-31 18:02:53,502 - httpx - INFO - HTTP Request: POST http://testserver/admin/update_master "HTTP/1.1 404 Not Found"
------------------------------ Captured log call -------------------------------
INFO     httpx:_client.py:1025 HTTP Request: POST http://testserver/admin/update_master "HTTP/1.1 404 Not Found"
______________ TestAdminRouter.test_update_price_success_as_admin ______________

self = <test_api_admin_integration.TestAdminRouter object at 0x7ffb1000ce20>
mock_update_daily_prices = <AsyncMock name='update_daily_prices' id='140716271613360'>
client = <starlette.testclient.TestClient object at 0x7ffb0f68cbb0>
admin_user_and_headers = (<src.common.models.user.User object at 0x7ffb0f623760>, {'Authorization': 'Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ...FjYWNiYjgzIiwicm9sZSI6ImFkbWluIiwidXNlcl9pZCI6MSwiZXhwIjoxNzU2NjY1MTc0fQ.aByxdIgt8FRCgY5U6-i71gI4nYBXpvxzUB4vWx4S2lA'})

    @patch('src.api.routers.admin.StockService.update_daily_prices')
    def test_update_price_success_as_admin(self, mock_update_daily_prices, client: TestClient, admin_user_and_headers):
        """
        - **테스트 대상**: `POST /admin/update_price`
        - **목적**: 관리자가 일별 시세 갱신을 성공적으로 요청하는지 확인합니다.
        - **시나리오**:
            - 관리자로 인증합니다.
            - 일별 시세 갱신 API를 호출합니다.
        - **Mock 대상**:
            - `src.api.routers.admin.StockService.update_daily_prices`
            - `get_current_active_admin_user`
        """
        admin_user, headers = admin_user_and_headers
        app.dependency_overrides[get_current_active_admin_user] = lambda: admin_user
    
        mock_update_daily_prices.return_value = {"success": True, "updated_count": 500, "errors": []}
        response = client.post("/admin/update_price", headers=headers)
    
>       assert response.status_code == 200
E       assert 404 == 200
E        +  where 404 = <Response [404 Not Found]>.status_code

tests/integration/test_api_admin_integration.py:201: AssertionError
---------------------------- Captured stdout setup -----------------------------
2025-08-31 18:02:53,678 - asyncio - DEBUG - Using selector: EpollSelector
2025-08-31 18:02:53,694 - src.api.main - INFO - 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
2025-08-31 18:02:53,883 - src.api.main - INFO - 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 18:02:53,889 - src.api.main - INFO - 테스트 StockMaster 데이터 시딩 완료.
2025-08-31 18:02:53,889 - src.api.main - INFO - 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 18:02:53,899 - src.api.main - INFO - 테스트 DailyPrice 데이터 시딩 완료.
------------------------------ Captured log setup ------------------------------
DEBUG    asyncio:selector_events.py:54 Using selector: EpollSelector
INFO     src.api.main:main.py:58 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
INFO     src.api.main:main.py:62 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:77 테스트 StockMaster 데이터 시딩 완료.
INFO     src.api.main:main.py:80 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:106 테스트 DailyPrice 데이터 시딩 완료.
----------------------------- Captured stdout call -----------------------------
2025-08-31 18:02:54,171 - httpx - INFO - HTTP Request: POST http://testserver/admin/update_price "HTTP/1.1 404 Not Found"
------------------------------ Captured log call -------------------------------
INFO     httpx:_client.py:1025 HTTP Request: POST http://testserver/admin/update_price "HTTP/1.1 404 Not Found"
______________ TestAdminRouter.test_update_price_failure_as_admin ______________

self = <test_api_admin_integration.TestAdminRouter object at 0x7ffb1000d060>
mock_update_daily_prices = <AsyncMock name='update_daily_prices' id='140716270499104'>
client = <starlette.testclient.TestClient object at 0x7ffb0f6233a0>
admin_user_and_headers = (<src.common.models.user.User object at 0x7ffb0f623a30>, {'Authorization': 'Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ...IxMTNjY2YxIiwicm9sZSI6ImFkbWluIiwidXNlcl9pZCI6MSwiZXhwIjoxNzU2NjY1MTc0fQ.l6aQTfmhEJH5hs_7NZJUcvv4TDARRHqhXKBymKWWBb8'})

    @patch('src.api.routers.admin.StockService.update_daily_prices')
    def test_update_price_failure_as_admin(self, mock_update_daily_prices, client: TestClient, admin_user_and_headers):
        """
        - **테스트 대상**: `POST /admin/update_price`
        - **목적**: 일별 시세 갱신 중 오류 발생 시 500 에러를 반환하는지 확인합니다.
        - **시나리오**:
            - 관리자로 인증합니다.
            - `update_daily_prices` 서비스가 예외를 발생시키도록 설정합니다.
            - API를 호출합니다.
        - **Mock 대상**:
            - `src.api.routers.admin.StockService.update_daily_prices` (예외 발생)
            - `get_current_active_admin_user`
        """
        admin_user, headers = admin_user_and_headers
        app.dependency_overrides[get_current_active_admin_user] = lambda: admin_user
    
        mock_update_daily_prices.side_effect = Exception("API call failed")
        response = client.post("/admin/update_price", headers=headers)
    
>       assert response.status_code == 500
E       assert 404 == 500
E        +  where 404 = <Response [404 Not Found]>.status_code

tests/integration/test_api_admin_integration.py:227: AssertionError
---------------------------- Captured stdout setup -----------------------------
2025-08-31 18:02:54,370 - asyncio - DEBUG - Using selector: EpollSelector
2025-08-31 18:02:54,387 - src.api.main - INFO - 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
2025-08-31 18:02:54,566 - src.api.main - INFO - 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 18:02:54,573 - src.api.main - INFO - 테스트 StockMaster 데이터 시딩 완료.
2025-08-31 18:02:54,573 - src.api.main - INFO - 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 18:02:54,588 - src.api.main - INFO - 테스트 DailyPrice 데이터 시딩 완료.
------------------------------ Captured log setup ------------------------------
DEBUG    asyncio:selector_events.py:54 Using selector: EpollSelector
INFO     src.api.main:main.py:58 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
INFO     src.api.main:main.py:62 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:77 테스트 StockMaster 데이터 시딩 완료.
INFO     src.api.main:main.py:80 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:106 테스트 DailyPrice 데이터 시딩 완료.
----------------------------- Captured stdout call -----------------------------
2025-08-31 18:02:54,874 - httpx - INFO - HTTP Request: POST http://testserver/admin/update_price "HTTP/1.1 404 Not Found"
------------------------------ Captured log call -------------------------------
INFO     httpx:_client.py:1025 HTTP Request: POST http://testserver/admin/update_price "HTTP/1.1 404 Not Found"
_______________ TestAdminRouter.test_update_price_as_normal_user _______________

self = <test_api_admin_integration.TestAdminRouter object at 0x7ffb1000d2a0>
client = <starlette.testclient.TestClient object at 0x7ffb0f5139a0>
normal_user_and_headers = (<src.common.models.user.User object at 0x7ffb0f513a30>, {'Authorization': 'Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ...ZjcxMjY0OTViIiwicm9sZSI6InVzZXIiLCJ1c2VyX2lkIjoxLCJleHAiOjE3NTY2NjUxNzV9.9V7Na6ZlA5cyYQpaO7oD8J8nPTA9BfGcbUW-Vbf7apo'})

    def test_update_price_as_normal_user(self, client: TestClient, normal_user_and_headers):
        """
        - **테스트 대상**: `POST /admin/update_price`
        - **목적**: 일반 사용자가 일별 시세 갱신 시도 시 403 에러를 받는지 확인합니다.
        - **시나리오**:
            - 일반 사용자로 인증 후 API를 호출합니다.
        - **Mock 대상**: 없음
        """
        _, headers = normal_user_and_headers
        response = client.post("/admin/update_price", headers=headers)
>       assert response.status_code == 403
E       assert 404 == 403
E        +  where 404 = <Response [404 Not Found]>.status_code

tests/integration/test_api_admin_integration.py:243: AssertionError
---------------------------- Captured stdout setup -----------------------------
2025-08-31 18:02:55,040 - asyncio - DEBUG - Using selector: EpollSelector
2025-08-31 18:02:55,050 - src.api.main - INFO - 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
2025-08-31 18:02:55,206 - src.api.main - INFO - 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 18:02:55,212 - src.api.main - INFO - 테스트 StockMaster 데이터 시딩 완료.
2025-08-31 18:02:55,213 - src.api.main - INFO - 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 18:02:55,222 - src.api.main - INFO - 테스트 DailyPrice 데이터 시딩 완료.
------------------------------ Captured log setup ------------------------------
DEBUG    asyncio:selector_events.py:54 Using selector: EpollSelector
INFO     src.api.main:main.py:58 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
INFO     src.api.main:main.py:62 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:77 테스트 StockMaster 데이터 시딩 완료.
INFO     src.api.main:main.py:80 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:106 테스트 DailyPrice 데이터 시딩 완료.
----------------------------- Captured stdout call -----------------------------
2025-08-31 18:02:55,483 - httpx - INFO - HTTP Request: POST http://testserver/admin/update_price "HTTP/1.1 404 Not Found"
------------------------------ Captured log call -------------------------------
INFO     httpx:_client.py:1025 HTTP Request: POST http://testserver/admin/update_price "HTTP/1.1 404 Not Found"
______________ TestAdminRouter.test_update_price_unauthenticated _______________

self = <test_api_admin_integration.TestAdminRouter object at 0x7ffb1000d4b0>
client = <starlette.testclient.TestClient object at 0x7ffb0f5130d0>

    def test_update_price_unauthenticated(self, client: TestClient):
        """
        - **테스트 대상**: `POST /admin/update_price`
        - **목적**: 미인증 사용자가 일별 시세 갱신 시도 시 401 에러를 받는지 확인합니다.
        - **시나리오**:
            - 인증 헤더 없이 API를 호출합니다.
        - **Mock 대상**: 없음
        """
        response = client.post("/admin/update_price")
>       assert response.status_code == 401
E       assert 404 == 401
E        +  where 404 = <Response [404 Not Found]>.status_code

tests/integration/test_api_admin_integration.py:254: AssertionError
---------------------------- Captured stdout setup -----------------------------
2025-08-31 18:02:55,650 - asyncio - DEBUG - Using selector: EpollSelector
2025-08-31 18:02:55,662 - src.api.main - INFO - 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
2025-08-31 18:02:55,829 - src.api.main - INFO - 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 18:02:55,835 - src.api.main - INFO - 테스트 StockMaster 데이터 시딩 완료.
2025-08-31 18:02:55,835 - src.api.main - INFO - 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 18:02:55,843 - src.api.main - INFO - 테스트 DailyPrice 데이터 시딩 완료.
------------------------------ Captured log setup ------------------------------
DEBUG    asyncio:selector_events.py:54 Using selector: EpollSelector
INFO     src.api.main:main.py:58 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
INFO     src.api.main:main.py:62 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:77 테스트 StockMaster 데이터 시딩 완료.
INFO     src.api.main:main.py:80 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:106 테스트 DailyPrice 데이터 시딩 완료.
----------------------------- Captured stdout call -----------------------------
2025-08-31 18:02:55,847 - httpx - INFO - HTTP Request: POST http://testserver/admin/update_price "HTTP/1.1 404 Not Found"
------------------------------ Captured log call -------------------------------
INFO     httpx:_client.py:1025 HTTP Request: POST http://testserver/admin/update_price "HTTP/1.1 404 Not Found"
_________ TestAdminRouter.test_update_disclosure_all_success_as_admin __________

thing = <module 'src.api.services' from '/app/src/api/services/__init__.py'>
comp = 'stock_service', import_path = 'src.api.services.stock_service'

    def _dot_lookup(thing, comp, import_path):
        try:
>           return getattr(thing, comp)
E           AttributeError: module 'src.api.services' has no attribute 'stock_service'

/usr/local/lib/python3.10/unittest/mock.py:1248: AttributeError

During handling of the above exception, another exception occurred:

args = (<test_api_admin_integration.TestAdminRouter object at 0x7ffb1000d6f0>,)
keywargs = {'admin_user_and_headers': (<src.common.models.user.User object at 0x7ffb0f6c9c90>, {'Authorization': 'Bearer eyJhbGci...Q.vPmSv0I07fZcnE1BfLdrYDXHzfNiWcQCse9S5c6ZVkM'}), 'client': <starlette.testclient.TestClient object at 0x7ffb0f6ca920>}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/usr/local/lib/python3.10/unittest/mock.py:1376: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/contextlib.py:135: in __enter__
    return next(self.gen)
/usr/local/lib/python3.10/unittest/mock.py:1358: in decoration_helper
    arg = exit_stack.enter_context(patching)
/usr/local/lib/python3.10/contextlib.py:492: in enter_context
    result = _cm_type.__enter__(cm)
/usr/local/lib/python3.10/unittest/mock.py:1431: in __enter__
    self.target = self.getter()
/usr/local/lib/python3.10/unittest/mock.py:1618: in <lambda>
    getter = lambda: _importer(target)
/usr/local/lib/python3.10/unittest/mock.py:1261: in _importer
    thing = _dot_lookup(thing, comp, import_path)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

thing = <module 'src.api.services' from '/app/src/api/services/__init__.py'>
comp = 'stock_service', import_path = 'src.api.services.stock_service'

    def _dot_lookup(thing, comp, import_path):
        try:
            return getattr(thing, comp)
        except AttributeError:
>           __import__(import_path)
E           ModuleNotFoundError: No module named 'src.api.services.stock_service'

/usr/local/lib/python3.10/unittest/mock.py:1250: ModuleNotFoundError
---------------------------- Captured stdout setup -----------------------------
2025-08-31 18:02:56,047 - asyncio - DEBUG - Using selector: EpollSelector
2025-08-31 18:02:56,057 - src.api.main - INFO - 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
2025-08-31 18:02:56,222 - src.api.main - INFO - 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 18:02:56,229 - src.api.main - INFO - 테스트 StockMaster 데이터 시딩 완료.
2025-08-31 18:02:56,229 - src.api.main - INFO - 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 18:02:56,241 - src.api.main - INFO - 테스트 DailyPrice 데이터 시딩 완료.
------------------------------ Captured log setup ------------------------------
DEBUG    asyncio:selector_events.py:54 Using selector: EpollSelector
INFO     src.api.main:main.py:58 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
INFO     src.api.main:main.py:62 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:77 테스트 StockMaster 데이터 시딩 완료.
INFO     src.api.main:main.py:80 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:106 테스트 DailyPrice 데이터 시딩 완료.
___ TestAdminRouter.test_update_disclosure_single_by_symbol_success_as_admin ___

self = <test_api_admin_integration.TestAdminRouter object at 0x7ffb1000d930>
mock_update_disclosures = <AsyncMock name='update_disclosures' id='140716269466192'>
client = <starlette.testclient.TestClient object at 0x7ffb0f621b10>
admin_user_and_headers = (<src.common.models.user.User object at 0x7ffb0f6225c0>, {'Authorization': 'Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ...kwNzA5YzBkIiwicm9sZSI6ImFkbWluIiwidXNlcl9pZCI6MSwiZXhwIjoxNzU2NjY1MTc3fQ.gVCBB-Ngk4mCUa9KHNVVEVB6KlaydQGpKsVI1AEK6FQ'})

    @patch('src.api.routers.admin.StockService.update_disclosures')
    def test_update_disclosure_single_by_symbol_success_as_admin(self, mock_update_disclosures, client: TestClient, admin_user_and_headers):
        """
        - **테스트 대상**: `POST /admin/update_disclosure` (단일 종목)
        - **목적**: 관리자가 종목 코드를 이용해 단일 종목의 공시 정보 갱신을 성공적으로 요청하는지 확인합니다.
        - **시나리오**:
            - 관리자로 인증합니다.
            - `code_or_name` 파라미터에 종목 코드를 담아 API를 호출합니다.
        - **Mock 대상**:
            - `src.api.routers.admin.StockService.update_disclosures`
            - `get_db` (DB에서 종목 정보를 조회하는 부분을 모의 처리)
            - `get_current_active_admin_user`
        """
        admin_user, headers = admin_user_and_headers
        app.dependency_overrides[get_current_active_admin_user] = lambda: admin_user
    
        mock_stock = MagicMock(spec=StockMaster, symbol="005930", name="삼성전자", corp_code="0012345")
        def mock_get_db():
            mock_db_session = MagicMock(spec=Session)
            mock_db_session.query.return_value.filter.return_value.first.return_value = mock_stock
            yield mock_db_session
        app.dependency_overrides[get_db] = mock_get_db
    
        mock_update_disclosures.return_value = {"success": True, "inserted": 10, "skipped": 3, "errors": []}
        response = client.post("/admin/update_disclosure", params={"code_or_name": "005930"}, headers=headers)
    
>       assert response.status_code == 200
E       assert 404 == 200
E        +  where 404 = <Response [404 Not Found]>.status_code

tests/integration/test_api_admin_integration.py:307: AssertionError
---------------------------- Captured stdout setup -----------------------------
2025-08-31 18:02:57,329 - asyncio - DEBUG - Using selector: EpollSelector
2025-08-31 18:02:57,342 - src.api.main - INFO - 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
2025-08-31 18:02:57,518 - src.api.main - INFO - 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 18:02:57,527 - src.api.main - INFO - 테스트 StockMaster 데이터 시딩 완료.
2025-08-31 18:02:57,528 - src.api.main - INFO - 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 18:02:57,541 - src.api.main - INFO - 테스트 DailyPrice 데이터 시딩 완료.
------------------------------ Captured log setup ------------------------------
DEBUG    asyncio:selector_events.py:54 Using selector: EpollSelector
INFO     src.api.main:main.py:58 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
INFO     src.api.main:main.py:62 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:77 테스트 StockMaster 데이터 시딩 완료.
INFO     src.api.main:main.py:80 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:106 테스트 DailyPrice 데이터 시딩 완료.
----------------------------- Captured stdout call -----------------------------
2025-08-31 18:02:57,820 - httpx - INFO - HTTP Request: POST http://testserver/admin/update_disclosure?code_or_name=005930 "HTTP/1.1 404 Not Found"
------------------------------ Captured log call -------------------------------
INFO     httpx:_client.py:1025 HTTP Request: POST http://testserver/admin/update_disclosure?code_or_name=005930 "HTTP/1.1 404 Not Found"
__________ TestAdminRouter.test_update_disclosure_not_found_as_admin ___________

self = <test_api_admin_integration.TestAdminRouter object at 0x7ffb1000db70>
client = <starlette.testclient.TestClient object at 0x7ffb0f513c10>
admin_user_and_headers = (<src.common.models.user.User object at 0x7ffb0f513190>, {'Authorization': 'Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ...QyN2U2NWZmIiwicm9sZSI6ImFkbWluIiwidXNlcl9pZCI6MSwiZXhwIjoxNzU2NjY1MTc4fQ.ZowzvYopdNKFIVdVXZ8BSoycratJ8_t8L2ieTZPbVOc'})

    def test_update_disclosure_not_found_as_admin(self, client: TestClient, admin_user_and_headers):
        """
        - **테스트 대상**: `POST /admin/update_disclosure` (단일 종목)
        - **목적**: 존재하지 않는 종목에 대해 공시 갱신 요청 시 404 에러를 반환하는지 확인합니다.
        - **시나리오**:
            - 관리자로 인증합니다.
            - 존재하지 않는 종목 코드로 API를 호출합니다.
        - **Mock 대상**:
            - `get_db` (DB 조회 결과가 `None`이 되도록 설정)
            - `get_current_active_admin_user`
        """
        admin_user, headers = admin_user_and_headers
        app.dependency_overrides[get_current_active_admin_user] = lambda: admin_user
    
        def mock_get_db_not_found():
            mock_db_session = MagicMock(spec=Session)
            mock_db_session.query.return_value.filter.return_value.first.return_value = None
            yield mock_db_session
        app.dependency_overrides[get_db] = mock_get_db_not_found
    
        response = client.post("/admin/update_disclosure", params={"code_or_name": "NONEXIST"}, headers=headers)
        assert response.status_code == 404
>       assert "'NONEXIST'에 해당하는 종목을 찾을 수 없거나 DART 고유번호(corp_code)가 없습니다." in response.json()["detail"]
E       assert "'NONEXIST'에 해당하는 종목을 찾을 수 없거나 DART 고유번호(corp_code)가 없습니다." in 'Not Found'

tests/integration/test_api_admin_integration.py:337: AssertionError
---------------------------- Captured stdout setup -----------------------------
2025-08-31 18:02:57,991 - asyncio - DEBUG - Using selector: EpollSelector
2025-08-31 18:02:58,004 - src.api.main - INFO - 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
2025-08-31 18:02:58,168 - src.api.main - INFO - 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 18:02:58,175 - src.api.main - INFO - 테스트 StockMaster 데이터 시딩 완료.
2025-08-31 18:02:58,176 - src.api.main - INFO - 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 18:02:58,190 - src.api.main - INFO - 테스트 DailyPrice 데이터 시딩 완료.
------------------------------ Captured log setup ------------------------------
DEBUG    asyncio:selector_events.py:54 Using selector: EpollSelector
INFO     src.api.main:main.py:58 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
INFO     src.api.main:main.py:62 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:77 테스트 StockMaster 데이터 시딩 완료.
INFO     src.api.main:main.py:80 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:106 테스트 DailyPrice 데이터 시딩 완료.
----------------------------- Captured stdout call -----------------------------
2025-08-31 18:02:58,460 - httpx - INFO - HTTP Request: POST http://testserver/admin/update_disclosure?code_or_name=NONEXIST "HTTP/1.1 404 Not Found"
------------------------------ Captured log call -------------------------------
INFO     httpx:_client.py:1025 HTTP Request: POST http://testserver/admin/update_disclosure?code_or_name=NONEXIST "HTTP/1.1 404 Not Found"
____________ TestAdminRouter.test_update_disclosure_as_normal_user _____________

self = <test_api_admin_integration.TestAdminRouter object at 0x7ffb1000ddb0>
client = <starlette.testclient.TestClient object at 0x7ffb0f417580>
normal_user_and_headers = (<src.common.models.user.User object at 0x7ffb0f417070>, {'Authorization': 'Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ...MWI5MDg2YjlkIiwicm9sZSI6InVzZXIiLCJ1c2VyX2lkIjoxLCJleHAiOjE3NTY2NjUxNzl9.ouNbIfQ3qTEC44fG-QOdgojIH9boC38mBNNt2TzagGU'})

    def test_update_disclosure_as_normal_user(self, client: TestClient, normal_user_and_headers):
        """
        - **테스트 대상**: `POST /admin/update_disclosure`
        - **목적**: 일반 사용자가 공시 갱신 시도 시 403 에러를 받는지 확인합니다.
        - **시나리오**:
            - 일반 사용자로 인증 후 API를 호출합니다.
        - **Mock 대상**: 없음
        """
        _, headers = normal_user_and_headers
        response = client.post("/admin/update_disclosure", headers=headers)
>       assert response.status_code == 403
E       assert 404 == 403
E        +  where 404 = <Response [404 Not Found]>.status_code

tests/integration/test_api_admin_integration.py:352: AssertionError
---------------------------- Captured stdout setup -----------------------------
2025-08-31 18:02:58,638 - asyncio - DEBUG - Using selector: EpollSelector
2025-08-31 18:02:58,649 - src.api.main - INFO - 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
2025-08-31 18:02:58,836 - src.api.main - INFO - 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 18:02:58,841 - src.api.main - INFO - 테스트 StockMaster 데이터 시딩 완료.
2025-08-31 18:02:58,842 - src.api.main - INFO - 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 18:02:58,856 - src.api.main - INFO - 테스트 DailyPrice 데이터 시딩 완료.
------------------------------ Captured log setup ------------------------------
DEBUG    asyncio:selector_events.py:54 Using selector: EpollSelector
INFO     src.api.main:main.py:58 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
INFO     src.api.main:main.py:62 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:77 테스트 StockMaster 데이터 시딩 완료.
INFO     src.api.main:main.py:80 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:106 테스트 DailyPrice 데이터 시딩 완료.
----------------------------- Captured stdout call -----------------------------
2025-08-31 18:02:59,176 - httpx - INFO - HTTP Request: POST http://testserver/admin/update_disclosure "HTTP/1.1 404 Not Found"
------------------------------ Captured log call -------------------------------
INFO     httpx:_client.py:1025 HTTP Request: POST http://testserver/admin/update_disclosure "HTTP/1.1 404 Not Found"
____________ TestAdminRouter.test_update_disclosure_unauthenticated ____________

self = <test_api_admin_integration.TestAdminRouter object at 0x7ffb1000dfc0>
client = <starlette.testclient.TestClient object at 0x7ffb0f6af910>

    def test_update_disclosure_unauthenticated(self, client: TestClient):
        """
        - **테스트 대상**: `POST /admin/update_disclosure`
        - **목적**: 미인증 사용자가 공시 갱신 시도 시 401 에러를 받는지 확인합니다.
        - **시나리오**:
            - 인증 헤더 없이 API를 호출합니다.
        - **Mock 대상**: 없음
        """
        response = client.post("/admin/update_disclosure")
>       assert response.status_code == 401
E       assert 404 == 401
E        +  where 404 = <Response [404 Not Found]>.status_code

tests/integration/test_api_admin_integration.py:363: AssertionError
---------------------------- Captured stdout setup -----------------------------
2025-08-31 18:02:59,364 - asyncio - DEBUG - Using selector: EpollSelector
2025-08-31 18:02:59,373 - src.api.main - INFO - 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
2025-08-31 18:02:59,666 - src.api.main - INFO - 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 18:02:59,676 - src.api.main - INFO - 테스트 StockMaster 데이터 시딩 완료.
2025-08-31 18:02:59,676 - src.api.main - INFO - 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 18:02:59,705 - src.api.main - INFO - 테스트 DailyPrice 데이터 시딩 완료.
------------------------------ Captured log setup ------------------------------
DEBUG    asyncio:selector_events.py:54 Using selector: EpollSelector
INFO     src.api.main:main.py:58 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
INFO     src.api.main:main.py:62 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:77 테스트 StockMaster 데이터 시딩 완료.
INFO     src.api.main:main.py:80 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:106 테스트 DailyPrice 데이터 시딩 완료.
----------------------------- Captured stdout call -----------------------------
2025-08-31 18:02:59,714 - httpx - INFO - HTTP Request: POST http://testserver/admin/update_disclosure "HTTP/1.1 404 Not Found"
------------------------------ Captured log call -------------------------------
INFO     httpx:_client.py:1025 HTTP Request: POST http://testserver/admin/update_disclosure "HTTP/1.1 404 Not Found"
___________ TestAdminRouter.test_get_schedule_status_as_normal_user ____________

self = <test_api_admin_integration.TestAdminRouter object at 0x7ffb1000e200>
client = <starlette.testclient.TestClient object at 0x7ffb0f544970>
normal_user_and_headers = (<src.common.models.user.User object at 0x7ffb0f547430>, {'Authorization': 'Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ...N2JlN2M3YTY2Iiwicm9sZSI6InVzZXIiLCJ1c2VyX2lkIjoxLCJleHAiOjE3NTY2NjUxODB9.A-uEe2E7LNNBT2D6lA-cybl9lq-A5qZYX3Bj-xi-cUE'})

    def test_get_schedule_status_as_normal_user(self, client: TestClient, normal_user_and_headers):
        """
        - **테스트 대상**: `GET /admin/schedule/status`
        - **목적**: 일반 사용자가 스케줄러 상태 조회 시 403 에러를 받는지 확인합니다.
        - **시나리오**:
            - 일반 사용자로 인증 후 API를 호출합니다.
        - **Mock 대상**: 없음
        """
        _, headers = normal_user_and_headers
        response = client.get("/admin/schedule/status", headers=headers)
>       assert response.status_code == 403
E       assert 404 == 403
E        +  where 404 = <Response [404 Not Found]>.status_code

tests/integration/test_api_admin_integration.py:379: AssertionError
---------------------------- Captured stdout setup -----------------------------
2025-08-31 18:03:00,120 - asyncio - DEBUG - Using selector: EpollSelector
2025-08-31 18:03:00,139 - src.api.main - INFO - 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
2025-08-31 18:03:00,337 - src.api.main - INFO - 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 18:03:00,345 - src.api.main - INFO - 테스트 StockMaster 데이터 시딩 완료.
2025-08-31 18:03:00,346 - src.api.main - INFO - 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 18:03:00,363 - src.api.main - INFO - 테스트 DailyPrice 데이터 시딩 완료.
------------------------------ Captured log setup ------------------------------
DEBUG    asyncio:selector_events.py:54 Using selector: EpollSelector
INFO     src.api.main:main.py:58 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
INFO     src.api.main:main.py:62 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:77 테스트 StockMaster 데이터 시딩 완료.
INFO     src.api.main:main.py:80 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:106 테스트 DailyPrice 데이터 시딩 완료.
----------------------------- Captured stdout call -----------------------------
2025-08-31 18:03:00,646 - httpx - INFO - HTTP Request: GET http://testserver/admin/schedule/status "HTTP/1.1 404 Not Found"
------------------------------ Captured log call -------------------------------
INFO     httpx:_client.py:1025 HTTP Request: GET http://testserver/admin/schedule/status "HTTP/1.1 404 Not Found"
___________ TestAdminRouter.test_get_schedule_status_unauthenticated ___________

self = <test_api_admin_integration.TestAdminRouter object at 0x7ffb1000e410>
client = <starlette.testclient.TestClient object at 0x7ffb0f544a90>

    def test_get_schedule_status_unauthenticated(self, client: TestClient):
        """
        - **테스트 대상**: `GET /admin/schedule/status`
        - **목적**: 미인증 사용자가 스케줄러 상태 조회 시 401 에러를 받는지 확인합니다.
        - **시나리오**:
            - 인증 헤더 없이 API를 호출합니다.
        - **Mock 대상**: 없음
        """
        response = client.get("/admin/schedule/status")
>       assert response.status_code == 401
E       assert 404 == 401
E        +  where 404 = <Response [404 Not Found]>.status_code

tests/integration/test_api_admin_integration.py:390: AssertionError
---------------------------- Captured stdout setup -----------------------------
2025-08-31 18:03:00,865 - asyncio - DEBUG - Using selector: EpollSelector
2025-08-31 18:03:00,878 - src.api.main - INFO - 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
2025-08-31 18:03:01,051 - src.api.main - INFO - 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 18:03:01,058 - src.api.main - INFO - 테스트 StockMaster 데이터 시딩 완료.
2025-08-31 18:03:01,058 - src.api.main - INFO - 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 18:03:01,068 - src.api.main - INFO - 테스트 DailyPrice 데이터 시딩 완료.
------------------------------ Captured log setup ------------------------------
DEBUG    asyncio:selector_events.py:54 Using selector: EpollSelector
INFO     src.api.main:main.py:58 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
INFO     src.api.main:main.py:62 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:77 테스트 StockMaster 데이터 시딩 완료.
INFO     src.api.main:main.py:80 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:106 테스트 DailyPrice 데이터 시딩 완료.
----------------------------- Captured stdout call -----------------------------
2025-08-31 18:03:01,073 - httpx - INFO - HTTP Request: GET http://testserver/admin/schedule/status "HTTP/1.1 404 Not Found"
------------------------------ Captured log call -------------------------------
INFO     httpx:_client.py:1025 HTTP Request: GET http://testserver/admin/schedule/status "HTTP/1.1 404 Not Found"
_______________ TestAdminRouter.test_trigger_job_as_normal_user ________________

self = <test_api_admin_integration.TestAdminRouter object at 0x7ffb1000e650>
client = <starlette.testclient.TestClient object at 0x7ffb0f5471c0>
normal_user_and_headers = (<src.common.models.user.User object at 0x7ffb0f546d10>, {'Authorization': 'Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ...NjdjNTQ2ZmM4Iiwicm9sZSI6InVzZXIiLCJ1c2VyX2lkIjoxLCJleHAiOjE3NTY2NjUxNzl9.ILhbz1N7wMXaGQ8joGOw5jIB-0bsSyErNQXfxxNGYAQ'})

    def test_trigger_job_as_normal_user(self, client: TestClient, normal_user_and_headers):
        """
        - **테스트 대상**: `POST /admin/schedule/trigger/{job_id}`
        - **목적**: 일반 사용자가 스케줄러 잡 실행 시 403 에러를 받는지 확인합니다.
        - **시나리오**:
            - 일반 사용자로 인증 후 API를 호출합니다.
        - **Mock 대상**: 없음
        """
        _, headers = normal_user_and_headers
        response = client.post("/admin/schedule/trigger/test_job", headers=headers)
>       assert response.status_code == 403
E       assert 404 == 403
E        +  where 404 = <Response [404 Not Found]>.status_code

tests/integration/test_api_admin_integration.py:402: AssertionError
---------------------------- Captured stdout setup -----------------------------
2025-08-31 18:03:01,285 - asyncio - DEBUG - Using selector: EpollSelector
2025-08-31 18:03:01,298 - src.api.main - INFO - 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
2025-08-31 18:03:00,721 - src.api.main - INFO - 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 18:02:59,290 - src.api.main - INFO - 테스트 StockMaster 데이터 시딩 완료.
2025-08-31 18:02:59,291 - src.api.main - INFO - 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 18:02:59,310 - src.api.main - INFO - 테스트 DailyPrice 데이터 시딩 완료.
------------------------------ Captured log setup ------------------------------
DEBUG    asyncio:selector_events.py:54 Using selector: EpollSelector
INFO     src.api.main:main.py:58 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
INFO     src.api.main:main.py:62 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:77 테스트 StockMaster 데이터 시딩 완료.
INFO     src.api.main:main.py:80 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:106 테스트 DailyPrice 데이터 시딩 완료.
----------------------------- Captured stdout call -----------------------------
2025-08-31 18:02:59,582 - httpx - INFO - HTTP Request: POST http://testserver/admin/schedule/trigger/test_job "HTTP/1.1 404 Not Found"
------------------------------ Captured log call -------------------------------
INFO     httpx:_client.py:1025 HTTP Request: POST http://testserver/admin/schedule/trigger/test_job "HTTP/1.1 404 Not Found"
_______________ TestAdminRouter.test_trigger_job_unauthenticated _______________

self = <test_api_admin_integration.TestAdminRouter object at 0x7ffb1000e860>
client = <starlette.testclient.TestClient object at 0x7ffb0f6c49a0>

    def test_trigger_job_unauthenticated(self, client: TestClient):
        """
        - **테스트 대상**: `POST /admin/schedule/trigger/{job_id}`
        - **목적**: 미인증 사용자가 스케줄러 잡 실행 시 401 에러를 받는지 확인합니다.
        - **시나리오**:
            - 인증 헤더 없이 API를 호출합니다.
        - **Mock 대상**: 없음
        """
        response = client.post("/admin/schedule/trigger/test_job")
>       assert response.status_code == 401
E       assert 404 == 401
E        +  where 404 = <Response [404 Not Found]>.status_code

tests/integration/test_api_admin_integration.py:413: AssertionError
---------------------------- Captured stdout setup -----------------------------
2025-08-31 18:02:59,768 - asyncio - DEBUG - Using selector: EpollSelector
2025-08-31 18:02:59,780 - src.api.main - INFO - 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
2025-08-31 18:02:59,967 - src.api.main - INFO - 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 18:02:59,975 - src.api.main - INFO - 테스트 StockMaster 데이터 시딩 완료.
2025-08-31 18:02:59,976 - src.api.main - INFO - 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 18:02:59,988 - src.api.main - INFO - 테스트 DailyPrice 데이터 시딩 완료.
------------------------------ Captured log setup ------------------------------
DEBUG    asyncio:selector_events.py:54 Using selector: EpollSelector
INFO     src.api.main:main.py:58 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
INFO     src.api.main:main.py:62 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:77 테스트 StockMaster 데이터 시딩 완료.
INFO     src.api.main:main.py:80 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:106 테스트 DailyPrice 데이터 시딩 완료.
----------------------------- Captured stdout call -----------------------------
2025-08-31 18:02:59,994 - httpx - INFO - HTTP Request: POST http://testserver/admin/schedule/trigger/test_job "HTTP/1.1 404 Not Found"
------------------------------ Captured log call -------------------------------
INFO     httpx:_client.py:1025 HTTP Request: POST http://testserver/admin/schedule/trigger/test_job "HTTP/1.1 404 Not Found"
_______ TestAdminRouter.test_trigger_check_disclosures_success_as_admin ________

self = <test_api_admin_integration.TestAdminRouter object at 0x7ffb1000eaa0>
mock_check_and_notify = <AsyncMock name='check_and_notify_new_disclosures' id='140716269542640'>
client = <starlette.testclient.TestClient object at 0x7ffb0f6c7340>
admin_user_and_headers = (<src.common.models.user.User object at 0x7ffb0f6c5420>, {'Authorization': 'Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ...RjZDNkZjlhIiwicm9sZSI6ImFkbWluIiwidXNlcl9pZCI6MSwiZXhwIjoxNzU2NjY1MTgwfQ.Hepf5q-QQ0kibnKXJO8LyU7FYym-9KFWJmIaJGm-whw'})

    @patch('src.api.routers.admin.StockService.check_and_notify_new_disclosures')
    def test_trigger_check_disclosures_success_as_admin(self, mock_check_and_notify, client: TestClient, admin_user_and_headers):
        """
        - **테스트 대상**: `POST /admin/trigger/check_disclosures`
        - **목적**: 관리자가 공시 확인 잡을 수동으로 성공적으로 실행하는지 확인합니다.
        - **시나리오**:
            - 관리자로 인증합니다.
            - 공시 확인 잡 실행 API를 호출합니다.
        - **Mock 대상**:
            - `src.api.routers.admin.StockService.check_and_notify_new_disclosures`
            - `get_current_active_admin_user`
        """
        admin_user, headers = admin_user_and_headers
        app.dependency_overrides[get_current_active_admin_user] = lambda: admin_user
    
        mock_check_and_notify.return_value = None
        response = client.post("/admin/trigger/check_disclosures", headers=headers)
    
>       assert response.status_code == 200
E       assert 404 == 200
E        +  where 404 = <Response [404 Not Found]>.status_code

tests/integration/test_api_admin_integration.py:433: AssertionError
---------------------------- Captured stdout setup -----------------------------
2025-08-31 18:03:00,203 - asyncio - DEBUG - Using selector: EpollSelector
2025-08-31 18:03:00,212 - src.api.main - INFO - 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
2025-08-31 18:03:00,362 - src.api.main - INFO - 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 18:03:00,368 - src.api.main - INFO - 테스트 StockMaster 데이터 시딩 완료.
2025-08-31 18:03:00,369 - src.api.main - INFO - 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 18:03:00,383 - src.api.main - INFO - 테스트 DailyPrice 데이터 시딩 완료.
------------------------------ Captured log setup ------------------------------
DEBUG    asyncio:selector_events.py:54 Using selector: EpollSelector
INFO     src.api.main:main.py:58 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
INFO     src.api.main:main.py:62 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:77 테스트 StockMaster 데이터 시딩 완료.
INFO     src.api.main:main.py:80 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:106 테스트 DailyPrice 데이터 시딩 완료.
----------------------------- Captured stdout call -----------------------------
2025-08-31 18:03:00,662 - httpx - INFO - HTTP Request: POST http://testserver/admin/trigger/check_disclosures "HTTP/1.1 404 Not Found"
------------------------------ Captured log call -------------------------------
INFO     httpx:_client.py:1025 HTTP Request: POST http://testserver/admin/trigger/check_disclosures "HTTP/1.1 404 Not Found"
_______ TestAdminRouter.test_trigger_check_disclosures_failure_as_admin ________

self = <test_api_admin_integration.TestAdminRouter object at 0x7ffb1000ece0>
mock_check_and_notify = <AsyncMock name='check_and_notify_new_disclosures' id='140716270708208'>
client = <starlette.testclient.TestClient object at 0x7ffb0f42afe0>
admin_user_and_headers = (<src.common.models.user.User object at 0x7ffb0f429f90>, {'Authorization': 'Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ...JhYmRjNGVjIiwicm9sZSI6ImFkbWluIiwidXNlcl9pZCI6MSwiZXhwIjoxNzU2NjY1MTgxfQ.pt1OsI5V4vjp5aTblGJeErvnlc2selP8c1G5nEiEMmQ'})

    @patch('src.api.routers.admin.StockService.check_and_notify_new_disclosures')
    def test_trigger_check_disclosures_failure_as_admin(self, mock_check_and_notify, client: TestClient, admin_user_and_headers):
        """
        - **테스트 대상**: `POST /admin/trigger/check_disclosures`
        - **목적**: 공시 확인 잡 실행 중 오류 발생 시 500 에러를 반환하는지 확인합니다.
        - **시나리오**:
            - 관리자로 인증합니다.
            - `check_and_notify_new_disclosures` 서비스가 예외를 발생시키도록 설정합니다.
            - API를 호출합니다.
        - **Mock 대상**:
            - `src.api.routers.admin.StockService.check_and_notify_new_disclosures` (예외 발생)
            - `get_current_active_admin_user`
        """
        admin_user, headers = admin_user_and_headers
        app.dependency_overrides[get_current_active_admin_user] = lambda: admin_user
    
        mock_check_and_notify.side_effect = Exception("Disclosure check failed")
        response = client.post("/admin/trigger/check_disclosures", headers=headers)
    
>       assert response.status_code == 500
E       assert 404 == 500
E        +  where 404 = <Response [404 Not Found]>.status_code

tests/integration/test_api_admin_integration.py:458: AssertionError
---------------------------- Captured stdout setup -----------------------------
2025-08-31 18:03:00,826 - asyncio - DEBUG - Using selector: EpollSelector
2025-08-31 18:03:00,838 - src.api.main - INFO - 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
2025-08-31 18:03:00,997 - src.api.main - INFO - 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 18:03:01,003 - src.api.main - INFO - 테스트 StockMaster 데이터 시딩 완료.
2025-08-31 18:03:01,003 - src.api.main - INFO - 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 18:03:01,014 - src.api.main - INFO - 테스트 DailyPrice 데이터 시딩 완료.
------------------------------ Captured log setup ------------------------------
DEBUG    asyncio:selector_events.py:54 Using selector: EpollSelector
INFO     src.api.main:main.py:58 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
INFO     src.api.main:main.py:62 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:77 테스트 StockMaster 데이터 시딩 완료.
INFO     src.api.main:main.py:80 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:106 테스트 DailyPrice 데이터 시딩 완료.
----------------------------- Captured stdout call -----------------------------
2025-08-31 18:03:01,289 - httpx - INFO - HTTP Request: POST http://testserver/admin/trigger/check_disclosures "HTTP/1.1 404 Not Found"
------------------------------ Captured log call -------------------------------
INFO     httpx:_client.py:1025 HTTP Request: POST http://testserver/admin/trigger/check_disclosures "HTTP/1.1 404 Not Found"
________ TestAdminRouter.test_trigger_check_disclosures_as_normal_user _________

self = <test_api_admin_integration.TestAdminRouter object at 0x7ffb1000ef20>
client = <starlette.testclient.TestClient object at 0x7ffb0f546320>
normal_user_and_headers = (<src.common.models.user.User object at 0x7ffb0f545f90>, {'Authorization': 'Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ...Mzc5NzQ1ZTA3Iiwicm9sZSI6InVzZXIiLCJ1c2VyX2lkIjoxLCJleHAiOjE3NTY2NjUxODF9.T2mMIwPOiRYxswN_OYUguzV5y2U9UsPlWBYqJTakxiw'})

    def test_trigger_check_disclosures_as_normal_user(self, client: TestClient, normal_user_and_headers):
        """
        - **테스트 대상**: `POST /admin/trigger/check_disclosures`
        - **목적**: 일반 사용자가 공시 확인 잡 실행 시 403 에러를 받는지 확인합니다.
        - **시나리오**:
            - 일반 사용자로 인증 후 API를 호출합니다.
        - **Mock 대상**: 없음
        """
        _, headers = normal_user_and_headers
        response = client.post("/admin/trigger/check_disclosures", headers=headers)
>       assert response.status_code == 403
E       assert 404 == 403
E        +  where 404 = <Response [404 Not Found]>.status_code

tests/integration/test_api_admin_integration.py:474: AssertionError
---------------------------- Captured stdout setup -----------------------------
2025-08-31 18:03:01,465 - asyncio - DEBUG - Using selector: EpollSelector
2025-08-31 18:03:01,476 - src.api.main - INFO - 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
2025-08-31 18:03:01,638 - src.api.main - INFO - 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 18:03:01,644 - src.api.main - INFO - 테스트 StockMaster 데이터 시딩 완료.
2025-08-31 18:03:01,645 - src.api.main - INFO - 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 18:03:01,656 - src.api.main - INFO - 테스트 DailyPrice 데이터 시딩 완료.
------------------------------ Captured log setup ------------------------------
DEBUG    asyncio:selector_events.py:54 Using selector: EpollSelector
INFO     src.api.main:main.py:58 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
INFO     src.api.main:main.py:62 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:77 테스트 StockMaster 데이터 시딩 완료.
INFO     src.api.main:main.py:80 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:106 테스트 DailyPrice 데이터 시딩 완료.
----------------------------- Captured stdout call -----------------------------
2025-08-31 18:03:01,925 - httpx - INFO - HTTP Request: POST http://testserver/admin/trigger/check_disclosures "HTTP/1.1 404 Not Found"
------------------------------ Captured log call -------------------------------
INFO     httpx:_client.py:1025 HTTP Request: POST http://testserver/admin/trigger/check_disclosures "HTTP/1.1 404 Not Found"
________ TestAdminRouter.test_trigger_check_disclosures_unauthenticated ________

self = <test_api_admin_integration.TestAdminRouter object at 0x7ffb1000e740>
client = <starlette.testclient.TestClient object at 0x7ffb0f42a3b0>

    def test_trigger_check_disclosures_unauthenticated(self, client: TestClient):
        """
        - **테스트 대상**: `POST /admin/trigger/check_disclosures`
        - **목적**: 미인증 사용자가 공시 확인 잡 실행 시 401 에러를 받는지 확인합니다.
        - **시나리오**:
            - 인증 헤더 없이 API를 호출합니다.
        - **Mock 대상**: 없음
        """
        response = client.post("/admin/trigger/check_disclosures")
>       assert response.status_code == 401
E       assert 404 == 401
E        +  where 404 = <Response [404 Not Found]>.status_code

tests/integration/test_api_admin_integration.py:485: AssertionError
---------------------------- Captured stdout setup -----------------------------
2025-08-31 18:03:02,100 - asyncio - DEBUG - Using selector: EpollSelector
2025-08-31 18:03:02,111 - src.api.main - INFO - 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
2025-08-31 18:03:02,300 - src.api.main - INFO - 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 18:03:02,308 - src.api.main - INFO - 테스트 StockMaster 데이터 시딩 완료.
2025-08-31 18:03:02,309 - src.api.main - INFO - 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 18:03:02,325 - src.api.main - INFO - 테스트 DailyPrice 데이터 시딩 완료.
------------------------------ Captured log setup ------------------------------
DEBUG    asyncio:selector_events.py:54 Using selector: EpollSelector
INFO     src.api.main:main.py:58 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
INFO     src.api.main:main.py:62 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:77 테스트 StockMaster 데이터 시딩 완료.
INFO     src.api.main:main.py:80 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:106 테스트 DailyPrice 데이터 시딩 완료.
----------------------------- Captured stdout call -----------------------------
2025-08-31 18:03:02,330 - httpx - INFO - HTTP Request: POST http://testserver/admin/trigger/check_disclosures "HTTP/1.1 404 Not Found"
------------------------------ Captured log call -------------------------------
INFO     httpx:_client.py:1025 HTTP Request: POST http://testserver/admin/trigger/check_disclosures "HTTP/1.1 404 Not Found"
=============================== warnings summary ===============================
../../../usr/local/lib/python3.10/site-packages/pydantic/_internal/_config.py:323
../../../usr/local/lib/python3.10/site-packages/pydantic/_internal/_config.py:323
../../../usr/local/lib/python3.10/site-packages/pydantic/_internal/_config.py:323
  /usr/local/lib/python3.10/site-packages/pydantic/_internal/_config.py:323: PydanticDeprecatedSince20: Support for class-based `config` is deprecated, use ConfigDict instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.11/migration/
    warnings.warn(DEPRECATION_MESSAGE, DeprecationWarning)

../../../usr/local/lib/python3.10/site-packages/pydantic/_internal/_config.py:373
  /usr/local/lib/python3.10/site-packages/pydantic/_internal/_config.py:373: UserWarning: Valid config keys have changed in V2:
  * 'orm_mode' has been renamed to 'from_attributes'
    warnings.warn(message, UserWarning)

main.py:112
  /app/src/api/main.py:112: DeprecationWarning: 
          on_event is deprecated, use lifespan event handlers instead.
  
          Read more about it in the
          [FastAPI docs for Lifespan Events](https://fastapi.tiangolo.com/advanced/events/).
          
    @app.on_event("startup")

../../../usr/local/lib/python3.10/site-packages/fastapi/applications.py:4495
  /usr/local/lib/python3.10/site-packages/fastapi/applications.py:4495: DeprecationWarning: 
          on_event is deprecated, use lifespan event handlers instead.
  
          Read more about it in the
          [FastAPI docs for Lifespan Events](https://fastapi.tiangolo.com/advanced/events/).
          
    return self.router.on_event(event_type)

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
=========================== short test summary info ============================
FAILED tests/integration/test_api_admin_integration.py::TestAdminRouter::test_admin_stats_as_admin
FAILED tests/integration/test_api_admin_integration.py::TestAdminRouter::test_admin_stats_as_normal_user
FAILED tests/integration/test_api_admin_integration.py::TestAdminRouter::test_admin_stats_unauthenticated
FAILED tests/integration/test_api_admin_integration.py::TestAdminRouter::test_update_master_success_as_admin
FAILED tests/integration/test_api_admin_integration.py::TestAdminRouter::test_update_master_failure_as_admin
FAILED tests/integration/test_api_admin_integration.py::TestAdminRouter::test_update_master_as_normal_user
FAILED tests/integration/test_api_admin_integration.py::TestAdminRouter::test_update_master_unauthenticated
FAILED tests/integration/test_api_admin_integration.py::TestAdminRouter::test_update_price_success_as_admin
FAILED tests/integration/test_api_admin_integration.py::TestAdminRouter::test_update_price_failure_as_admin
FAILED tests/integration/test_api_admin_integration.py::TestAdminRouter::test_update_price_as_normal_user
FAILED tests/integration/test_api_admin_integration.py::TestAdminRouter::test_update_price_unauthenticated
FAILED tests/integration/test_api_admin_integration.py::TestAdminRouter::test_update_disclosure_all_success_as_admin
FAILED tests/integration/test_api_admin_integration.py::TestAdminRouter::test_update_disclosure_single_by_symbol_success_as_admin
FAILED tests/integration/test_api_admin_integration.py::TestAdminRouter::test_update_disclosure_not_found_as_admin
FAILED tests/integration/test_api_admin_integration.py::TestAdminRouter::test_update_disclosure_as_normal_user
FAILED tests/integration/test_api_admin_integration.py::TestAdminRouter::test_update_disclosure_unauthenticated
FAILED tests/integration/test_api_admin_integration.py::TestAdminRouter::test_get_schedule_status_as_normal_user
FAILED tests/integration/test_api_admin_integration.py::TestAdminRouter::test_get_schedule_status_unauthenticated
FAILED tests/integration/test_api_admin_integration.py::TestAdminRouter::test_trigger_job_as_normal_user
FAILED tests/integration/test_api_admin_integration.py::TestAdminRouter::test_trigger_job_unauthenticated
FAILED tests/integration/test_api_admin_integration.py::TestAdminRouter::test_trigger_check_disclosures_success_as_admin
FAILED tests/integration/test_api_admin_integration.py::TestAdminRouter::test_trigger_check_disclosures_failure_as_admin
FAILED tests/integration/test_api_admin_integration.py::TestAdminRouter::test_trigger_check_disclosures_as_normal_user
FAILED tests/integration/test_api_admin_integration.py::TestAdminRouter::test_trigger_check_disclosures_unauthenticated
======================= 24 failed, 6 warnings in 17.79s ========================
\n--- Running test_api_admin_integration.py ---
============================= test session starts ==============================
platform linux -- Python 3.10.18, pytest-8.4.1, pluggy-1.6.0
rootdir: /app/src/api
plugins: cov-6.2.1, timeout-2.4.0, anyio-4.10.0, asyncio-1.1.0
asyncio: mode=strict, asyncio_default_fixture_loop_scope=None, asyncio_default_test_loop_scope=function
collected 24 items

tests/integration/test_api_admin_integration.py ..F...F...FFFF.F.F.FFFFF [100%]

=================================== FAILURES ===================================
_______________ TestAdminRouter.test_admin_stats_unauthenticated _______________

self = <test_api_admin_integration.TestAdminRouter object at 0x7f4296651b40>
client = <starlette.testclient.TestClient object at 0x7f42967d6290>

    def test_admin_stats_unauthenticated(self, client: TestClient):
        """
        - **테스트 대상**: `GET /admin/admin_stats`
        - **목적**: 인증되지 않은 사용자가 관리자 API 접근 시 401 에러를 받는지 확인합니다.
        - **시나리오**:
            - 인증 헤더 없이 통계 API를 호출합니다.
        - **Mock 대상**: 없음 (실제 인증 처리 로직 검증)
        """
        response = client.get("/api/v1/admin/admin_stats")
>       assert response.status_code == 401
E       assert 403 == 401
E        +  where 403 = <Response [403 Forbidden]>.status_code

tests/integration/test_api_admin_integration.py:106: AssertionError
---------------------------- Captured stdout setup -----------------------------
2025-08-31 18:07:41,532 - asyncio - DEBUG - Using selector: EpollSelector
2025-08-31 18:07:41,544 - src.api.main - INFO - 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
2025-08-31 18:07:41,740 - src.api.main - INFO - 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 18:07:41,746 - src.api.main - INFO - 테스트 StockMaster 데이터 시딩 완료.
2025-08-31 18:07:41,746 - src.api.main - INFO - 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 18:07:41,760 - src.api.main - INFO - 테스트 DailyPrice 데이터 시딩 완료.
------------------------------ Captured log setup ------------------------------
DEBUG    asyncio:selector_events.py:54 Using selector: EpollSelector
INFO     src.api.main:main.py:58 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
INFO     src.api.main:main.py:62 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:77 테스트 StockMaster 데이터 시딩 완료.
INFO     src.api.main:main.py:80 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:106 테스트 DailyPrice 데이터 시딩 완료.
----------------------------- Captured stdout call -----------------------------
2025-08-31 18:07:41,768 - httpx - INFO - HTTP Request: GET http://testserver/api/v1/admin/admin_stats "HTTP/1.1 403 Forbidden"
------------------------------ Captured log call -------------------------------
INFO     httpx:_client.py:1025 HTTP Request: GET http://testserver/api/v1/admin/admin_stats "HTTP/1.1 403 Forbidden"
______________ TestAdminRouter.test_update_master_unauthenticated ______________

self = <test_api_admin_integration.TestAdminRouter object at 0x7f4296650670>
client = <starlette.testclient.TestClient object at 0x7f4295e11cc0>

    def test_update_master_unauthenticated(self, client: TestClient):
        """
        - **테스트 대상**: `POST /admin/update_master`
        - **목적**: 미인증 사용자가 종목 마스터 갱신 시도 시 401 에러를 받는지 확인합니다.
        - **시나리오**:
            - 인증 헤더 없이 API를 호출합니다.
        - **Mock 대상**: 없음
        """
        response = client.post("/api/v1/admin/update_master")
>       assert response.status_code == 401
E       assert 403 == 401
E        +  where 403 = <Response [403 Forbidden]>.status_code

tests/integration/test_api_admin_integration.py:181: AssertionError
---------------------------- Captured stdout setup -----------------------------
2025-08-31 18:07:44,633 - asyncio - DEBUG - Using selector: EpollSelector
2025-08-31 18:07:44,645 - src.api.main - INFO - 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
2025-08-31 18:07:44,817 - src.api.main - INFO - 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 18:07:44,824 - src.api.main - INFO - 테스트 StockMaster 데이터 시딩 완료.
2025-08-31 18:07:44,824 - src.api.main - INFO - 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 18:07:44,838 - src.api.main - INFO - 테스트 DailyPrice 데이터 시딩 완료.
------------------------------ Captured log setup ------------------------------
DEBUG    asyncio:selector_events.py:54 Using selector: EpollSelector
INFO     src.api.main:main.py:58 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
INFO     src.api.main:main.py:62 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:77 테스트 StockMaster 데이터 시딩 완료.
INFO     src.api.main:main.py:80 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:106 테스트 DailyPrice 데이터 시딩 완료.
----------------------------- Captured stdout call -----------------------------
2025-08-31 18:07:44,847 - httpx - INFO - HTTP Request: POST http://testserver/api/v1/admin/update_master "HTTP/1.1 403 Forbidden"
------------------------------ Captured log call -------------------------------
INFO     httpx:_client.py:1025 HTTP Request: POST http://testserver/api/v1/admin/update_master "HTTP/1.1 403 Forbidden"
______________ TestAdminRouter.test_update_price_unauthenticated _______________

self = <test_api_admin_integration.TestAdminRouter object at 0x7f4296651c30>
client = <starlette.testclient.TestClient object at 0x7f42967ec850>

    def test_update_price_unauthenticated(self, client: TestClient):
        """
        - **테스트 대상**: `POST /admin/update_price`
        - **목적**: 미인증 사용자가 일별 시세 갱신 시도 시 401 에러를 받는지 확인합니다.
        - **시나리오**:
            - 인증 헤더 없이 API를 호출합니다.
        - **Mock 대상**: 없음
        """
        response = client.post("/api/v1/admin/update_price")
>       assert response.status_code == 401
E       assert 403 == 401
E        +  where 403 = <Response [403 Forbidden]>.status_code

tests/integration/test_api_admin_integration.py:254: AssertionError
---------------------------- Captured stdout setup -----------------------------
2025-08-31 18:07:47,488 - asyncio - DEBUG - Using selector: EpollSelector
2025-08-31 18:07:47,499 - src.api.main - INFO - 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
2025-08-31 18:07:47,684 - src.api.main - INFO - 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 18:07:47,691 - src.api.main - INFO - 테스트 StockMaster 데이터 시딩 완료.
2025-08-31 18:07:47,692 - src.api.main - INFO - 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 18:07:47,702 - src.api.main - INFO - 테스트 DailyPrice 데이터 시딩 완료.
------------------------------ Captured log setup ------------------------------
DEBUG    asyncio:selector_events.py:54 Using selector: EpollSelector
INFO     src.api.main:main.py:58 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
INFO     src.api.main:main.py:62 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:77 테스트 StockMaster 데이터 시딩 완료.
INFO     src.api.main:main.py:80 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:106 테스트 DailyPrice 데이터 시딩 완료.
----------------------------- Captured stdout call -----------------------------
2025-08-31 18:07:47,711 - httpx - INFO - HTTP Request: POST http://testserver/api/v1/admin/update_price "HTTP/1.1 403 Forbidden"
------------------------------ Captured log call -------------------------------
INFO     httpx:_client.py:1025 HTTP Request: POST http://testserver/api/v1/admin/update_price "HTTP/1.1 403 Forbidden"
_________ TestAdminRouter.test_update_disclosure_all_success_as_admin __________

thing = <module 'src.api.services' from '/app/src/api/services/__init__.py'>
comp = 'stock_service', import_path = 'src.api.services.stock_service'

    def _dot_lookup(thing, comp, import_path):
        try:
>           return getattr(thing, comp)
E           AttributeError: module 'src.api.services' has no attribute 'stock_service'

/usr/local/lib/python3.10/unittest/mock.py:1248: AttributeError

During handling of the above exception, another exception occurred:

args = (<test_api_admin_integration.TestAdminRouter object at 0x7f4296650b50>,)
keywargs = {'admin_user_and_headers': (<src.common.models.user.User object at 0x7f42953d9e10>, {'Authorization': 'Bearer eyJhbGci...Q.oX34a4jg8jKG_S-VI49OCCp2XJ5LgRKLllHS8kLe4jM'}), 'client': <starlette.testclient.TestClient object at 0x7f42953db550>}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/usr/local/lib/python3.10/unittest/mock.py:1376: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/contextlib.py:135: in __enter__
    return next(self.gen)
/usr/local/lib/python3.10/unittest/mock.py:1358: in decoration_helper
    arg = exit_stack.enter_context(patching)
/usr/local/lib/python3.10/contextlib.py:492: in enter_context
    result = _cm_type.__enter__(cm)
/usr/local/lib/python3.10/unittest/mock.py:1431: in __enter__
    self.target = self.getter()
/usr/local/lib/python3.10/unittest/mock.py:1618: in <lambda>
    getter = lambda: _importer(target)
/usr/local/lib/python3.10/unittest/mock.py:1261: in _importer
    thing = _dot_lookup(thing, comp, import_path)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

thing = <module 'src.api.services' from '/app/src/api/services/__init__.py'>
comp = 'stock_service', import_path = 'src.api.services.stock_service'

    def _dot_lookup(thing, comp, import_path):
        try:
            return getattr(thing, comp)
        except AttributeError:
>           __import__(import_path)
E           ModuleNotFoundError: No module named 'src.api.services.stock_service'

/usr/local/lib/python3.10/unittest/mock.py:1250: ModuleNotFoundError
---------------------------- Captured stdout setup -----------------------------
2025-08-31 18:07:47,905 - asyncio - DEBUG - Using selector: EpollSelector
2025-08-31 18:07:47,917 - src.api.main - INFO - 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
2025-08-31 18:07:48,085 - src.api.main - INFO - 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 18:07:48,093 - src.api.main - INFO - 테스트 StockMaster 데이터 시딩 완료.
2025-08-31 18:07:48,093 - src.api.main - INFO - 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 18:07:48,105 - src.api.main - INFO - 테스트 DailyPrice 데이터 시딩 완료.
------------------------------ Captured log setup ------------------------------
DEBUG    asyncio:selector_events.py:54 Using selector: EpollSelector
INFO     src.api.main:main.py:58 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
INFO     src.api.main:main.py:62 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:77 테스트 StockMaster 데이터 시딩 완료.
INFO     src.api.main:main.py:80 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:106 테스트 DailyPrice 데이터 시딩 완료.
___ TestAdminRouter.test_update_disclosure_single_by_symbol_success_as_admin ___

self = <test_api_admin_integration.TestAdminRouter object at 0x7f4296650bb0>
mock_update_disclosures = <AsyncMock name='update_disclosures' id='139923948176096'>
client = <starlette.testclient.TestClient object at 0x7f42967d5ba0>
admin_user_and_headers = (<src.common.models.user.User object at 0x7f42967d62c0>, {'Authorization': 'Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ...c1ODNjYmQ1Iiwicm9sZSI6ImFkbWluIiwidXNlcl9pZCI6MSwiZXhwIjoxNzU2NjY1NDY5fQ.a3IYBufFsXP_v_loTq88Xeswd5knWoEFKd3v79-a8jk'})

    @patch('src.api.routers.admin.StockService.update_disclosures')
    def test_update_disclosure_single_by_symbol_success_as_admin(self, mock_update_disclosures, client: TestClient, admin_user_and_headers):
        """
        - **테스트 대상**: `POST /admin/update_disclosure` (단일 종목)
        - **목적**: 관리자가 종목 코드를 이용해 단일 종목의 공시 정보 갱신을 성공적으로 요청하는지 확인합니다.
        - **시나리오**:
            - 관리자로 인증합니다.
            - `code_or_name` 파라미터에 종목 코드를 담아 API를 호출합니다.
        - **Mock 대상**:
            - `src.api.routers.admin.StockService.update_disclosures`
            - `get_db` (DB에서 종목 정보를 조회하는 부분을 모의 처리)
            - `get_current_active_admin_user`
        """
        admin_user, headers = admin_user_and_headers
        app.dependency_overrides[get_current_active_admin_user] = lambda: admin_user
    
        mock_stock = MagicMock(spec=StockMaster, symbol="005930", name="삼성전자", corp_code="0012345")
        def mock_get_db():
            mock_db_session = MagicMock(spec=Session)
            mock_db_session.query.return_value.filter.return_value.first.return_value = mock_stock
            yield mock_db_session
        app.dependency_overrides[get_db] = mock_get_db
    
        mock_update_disclosures.return_value = {"success": True, "inserted": 10, "skipped": 3, "errors": []}
        response = client.post("/api/v1/admin/update_disclosure", params={"code_or_name": "005930"}, headers=headers)
    
        assert response.status_code == 200
>       assert response.json()["message"] == "'삼성전자' 공시 이력 갱신 완료: 10건 추가, 3건 중복"
E       assert "'<MagicMock ...10건 추가, 3건 중복" == "'삼성전자' 공시 이력...10건 추가, 3건 중복"
E         
E         - '삼성전자' 공시 이력 갱신 완료: 10건 추가, 3건 중복
E         + '<MagicMock name='mock.query().filter().limit().all().__getitem__().name' id='139923948454000'>' 공시 이력 갱신 완료: 10건 추가, 3건 중복

tests/integration/test_api_admin_integration.py:308: AssertionError
---------------------------- Captured stdout setup -----------------------------
2025-08-31 18:07:49,019 - asyncio - DEBUG - Using selector: EpollSelector
2025-08-31 18:07:49,031 - src.api.main - INFO - 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
2025-08-31 18:07:49,193 - src.api.main - INFO - 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 18:07:49,200 - src.api.main - INFO - 테스트 StockMaster 데이터 시딩 완료.
2025-08-31 18:07:49,200 - src.api.main - INFO - 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 18:07:49,209 - src.api.main - INFO - 테스트 DailyPrice 데이터 시딩 완료.
------------------------------ Captured log setup ------------------------------
DEBUG    asyncio:selector_events.py:54 Using selector: EpollSelector
INFO     src.api.main:main.py:58 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
INFO     src.api.main:main.py:62 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:77 테스트 StockMaster 데이터 시딩 완료.
INFO     src.api.main:main.py:80 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:106 테스트 DailyPrice 데이터 시딩 완료.
----------------------------- Captured stdout call -----------------------------
2025-08-31 18:07:49,484 - src.common.services.stock_service - DEBUG - search_stocks 호출: keyword=005930, limit=1
2025-08-31 18:07:49,487 - src.common.services.stock_service - DEBUG - 검색 결과: 0개 종목 발견.
2025-08-31 18:07:49,490 - httpx - INFO - HTTP Request: POST http://testserver/api/v1/admin/update_disclosure?code_or_name=005930 "HTTP/1.1 200 OK"
------------------------------ Captured log call -------------------------------
DEBUG    src.common.services.stock_service:stock_service.py:224 search_stocks 호출: keyword=005930, limit=1
DEBUG    src.common.services.stock_service:stock_service.py:229 검색 결과: 0개 종목 발견.
INFO     httpx:_client.py:1025 HTTP Request: POST http://testserver/api/v1/admin/update_disclosure?code_or_name=005930 "HTTP/1.1 200 OK"
__________ TestAdminRouter.test_update_disclosure_not_found_as_admin ___________

self = <test_api_admin_integration.TestAdminRouter object at 0x7f42967e3fa0>
client = <starlette.testclient.TestClient object at 0x7f42967d5c30>
admin_user_and_headers = (<src.common.models.user.User object at 0x7f42967d4460>, {'Authorization': 'Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ...U0ZDc2YzE4Iiwicm9sZSI6ImFkbWluIiwidXNlcl9pZCI6MSwiZXhwIjoxNzU2NjY1NDcwfQ.Snj8gOjrfrwfg0I0qRn8xHUjO912IWRUJ1I-QJQIaJs'})

    def test_update_disclosure_not_found_as_admin(self, client: TestClient, admin_user_and_headers):
        """
        - **테스트 대상**: `POST /admin/update_disclosure` (단일 종목)
        - **목적**: 존재하지 않는 종목에 대해 공시 갱신 요청 시 404 에러를 반환하는지 확인합니다.
        - **시나리오**:
            - 관리자로 인증합니다.
            - 존재하지 않는 종목 코드로 API를 호출합니다.
        - **Mock 대상**:
            - `get_db` (DB 조회 결과가 `None`이 되도록 설정)
            - `get_current_active_admin_user`
        """
        admin_user, headers = admin_user_and_headers
        app.dependency_overrides[get_current_active_admin_user] = lambda: admin_user
    
        def mock_get_db_not_found():
            mock_db_session = MagicMock(spec=Session)
            mock_db_session.query.return_value.filter.return_value.first.return_value = None
            yield mock_db_session
        app.dependency_overrides[get_db] = mock_get_db_not_found
    
        response = client.post("/api/v1/admin/update_disclosure", params={"code_or_name": "NONEXIST"}, headers=headers)
>       assert response.status_code == 404
E       assert 500 == 404
E        +  where 500 = <Response [500 Internal Server Error]>.status_code

tests/integration/test_api_admin_integration.py:336: AssertionError
---------------------------- Captured stdout setup -----------------------------
2025-08-31 18:07:49,680 - asyncio - DEBUG - Using selector: EpollSelector
2025-08-31 18:07:49,690 - src.api.main - INFO - 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
2025-08-31 18:07:49,850 - src.api.main - INFO - 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 18:07:49,856 - src.api.main - INFO - 테스트 StockMaster 데이터 시딩 완료.
2025-08-31 18:07:49,857 - src.api.main - INFO - 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 18:07:49,867 - src.api.main - INFO - 테스트 DailyPrice 데이터 시딩 완료.
------------------------------ Captured log setup ------------------------------
DEBUG    asyncio:selector_events.py:54 Using selector: EpollSelector
INFO     src.api.main:main.py:58 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
INFO     src.api.main:main.py:62 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:77 테스트 StockMaster 데이터 시딩 완료.
INFO     src.api.main:main.py:80 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:106 테스트 DailyPrice 데이터 시딩 완료.
----------------------------- Captured stdout call -----------------------------
2025-08-31 18:07:50,148 - src.common.services.stock_service - DEBUG - search_stocks 호출: keyword=NONEXIST, limit=1
2025-08-31 18:07:50,153 - src.common.services.stock_service - DEBUG - 검색 결과: 0개 종목 발견.
2025-08-31 18:07:50,156 - src.common.services.stock_service - DEBUG - update_disclosures 호출: corp_code=<MagicMock name='mock.query().filter().limit().all().__getitem__().corp_code' id='139923958047136'>, stock_code=<MagicMock name='mock.query().filter().limit().all().__getitem__().symbol' id='139923946991056'>, max_count=10
2025-08-31 18:07:50,157 - src.common.services.stock_service - ERROR - 공시 갱신 실패 (corp_code=<MagicMock name='mock.query().filter().limit().all().__getitem__().corp_code' id='139923958047136'>): dart_get_disclosures() got an unexpected keyword argument 'max_count'
Traceback (most recent call last):
  File "/app/src/common/services/stock_service.py", line 520, in update_disclosures
    disclosures = await dart_get_disclosures(corp_code, max_count=max_count)
TypeError: dart_get_disclosures() got an unexpected keyword argument 'max_count'
2025-08-31 18:07:50,161 - httpx - INFO - HTTP Request: POST http://testserver/api/v1/admin/update_disclosure?code_or_name=NONEXIST "HTTP/1.1 500 Internal Server Error"
------------------------------ Captured log call -------------------------------
DEBUG    src.common.services.stock_service:stock_service.py:224 search_stocks 호출: keyword=NONEXIST, limit=1
DEBUG    src.common.services.stock_service:stock_service.py:229 검색 결과: 0개 종목 발견.
DEBUG    src.common.services.stock_service:stock_service.py:517 update_disclosures 호출: corp_code=<MagicMock name='mock.query().filter().limit().all().__getitem__().corp_code' id='139923958047136'>, stock_code=<MagicMock name='mock.query().filter().limit().all().__getitem__().symbol' id='139923946991056'>, max_count=10
ERROR    src.common.services.stock_service:stock_service.py:560 공시 갱신 실패 (corp_code=<MagicMock name='mock.query().filter().limit().all().__getitem__().corp_code' id='139923958047136'>): dart_get_disclosures() got an unexpected keyword argument 'max_count'
Traceback (most recent call last):
  File "/app/src/common/services/stock_service.py", line 520, in update_disclosures
    disclosures = await dart_get_disclosures(corp_code, max_count=max_count)
TypeError: dart_get_disclosures() got an unexpected keyword argument 'max_count'
INFO     httpx:_client.py:1025 HTTP Request: POST http://testserver/api/v1/admin/update_disclosure?code_or_name=NONEXIST "HTTP/1.1 500 Internal Server Error"
____________ TestAdminRouter.test_update_disclosure_unauthenticated ____________

self = <test_api_admin_integration.TestAdminRouter object at 0x7f42967e3970>
client = <starlette.testclient.TestClient object at 0x7f42953fa050>

    def test_update_disclosure_unauthenticated(self, client: TestClient):
        """
        - **테스트 대상**: `POST /admin/update_disclosure`
        - **목적**: 미인증 사용자가 공시 갱신 시도 시 401 에러를 받는지 확인합니다.
        - **시나리오**:
            - 인증 헤더 없이 API를 호출합니다.
        - **Mock 대상**: 없음
        """
        response = client.post("/api/v1/admin/update_disclosure")
>       assert response.status_code == 401
E       assert 403 == 401
E        +  where 403 = <Response [403 Forbidden]>.status_code

tests/integration/test_api_admin_integration.py:363: AssertionError
---------------------------- Captured stdout setup -----------------------------
2025-08-31 18:07:51,257 - asyncio - DEBUG - Using selector: EpollSelector
2025-08-31 18:07:51,271 - src.api.main - INFO - 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
2025-08-31 18:07:51,452 - src.api.main - INFO - 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 18:07:51,459 - src.api.main - INFO - 테스트 StockMaster 데이터 시딩 완료.
2025-08-31 18:07:51,460 - src.api.main - INFO - 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 18:07:51,470 - src.api.main - INFO - 테스트 DailyPrice 데이터 시딩 완료.
------------------------------ Captured log setup ------------------------------
DEBUG    asyncio:selector_events.py:54 Using selector: EpollSelector
INFO     src.api.main:main.py:58 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
INFO     src.api.main:main.py:62 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:77 테스트 StockMaster 데이터 시딩 완료.
INFO     src.api.main:main.py:80 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:106 테스트 DailyPrice 데이터 시딩 완료.
----------------------------- Captured stdout call -----------------------------
2025-08-31 18:07:51,478 - httpx - INFO - HTTP Request: POST http://testserver/api/v1/admin/update_disclosure "HTTP/1.1 403 Forbidden"
------------------------------ Captured log call -------------------------------
INFO     httpx:_client.py:1025 HTTP Request: POST http://testserver/api/v1/admin/update_disclosure "HTTP/1.1 403 Forbidden"
___________ TestAdminRouter.test_get_schedule_status_unauthenticated ___________

self = <test_api_admin_integration.TestAdminRouter object at 0x7f42967e3430>
client = <starlette.testclient.TestClient object at 0x7f4295420640>

    def test_get_schedule_status_unauthenticated(self, client: TestClient):
        """
        - **테스트 대상**: `GET /admin/schedule/status`
        - **목적**: 미인증 사용자가 스케줄러 상태 조회 시 401 에러를 받는지 확인합니다.
        - **시나리오**:
            - 인증 헤더 없이 API를 호출합니다.
        - **Mock 대상**: 없음
        """
        response = client.get("/api/v1/admin/schedule/status")
>       assert response.status_code == 401
E       assert 403 == 401
E        +  where 403 = <Response [403 Forbidden]>.status_code

tests/integration/test_api_admin_integration.py:390: AssertionError
---------------------------- Captured stdout setup -----------------------------
2025-08-31 18:07:52,460 - asyncio - DEBUG - Using selector: EpollSelector
2025-08-31 18:07:52,470 - src.api.main - INFO - 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
2025-08-31 18:07:52,629 - src.api.main - INFO - 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 18:07:52,638 - src.api.main - INFO - 테스트 StockMaster 데이터 시딩 완료.
2025-08-31 18:07:52,638 - src.api.main - INFO - 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 18:07:52,651 - src.api.main - INFO - 테스트 DailyPrice 데이터 시딩 완료.
------------------------------ Captured log setup ------------------------------
DEBUG    asyncio:selector_events.py:54 Using selector: EpollSelector
INFO     src.api.main:main.py:58 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
INFO     src.api.main:main.py:62 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:77 테스트 StockMaster 데이터 시딩 완료.
INFO     src.api.main:main.py:80 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:106 테스트 DailyPrice 데이터 시딩 완료.
----------------------------- Captured stdout call -----------------------------
2025-08-31 18:07:52,658 - httpx - INFO - HTTP Request: GET http://testserver/api/v1/admin/schedule/status "HTTP/1.1 403 Forbidden"
------------------------------ Captured log call -------------------------------
INFO     httpx:_client.py:1025 HTTP Request: GET http://testserver/api/v1/admin/schedule/status "HTTP/1.1 403 Forbidden"
_______________ TestAdminRouter.test_trigger_job_unauthenticated _______________

self = <test_api_admin_integration.TestAdminRouter object at 0x7f42967e2f20>
client = <starlette.testclient.TestClient object at 0x7f429504b5e0>

    def test_trigger_job_unauthenticated(self, client: TestClient):
        """
        - **테스트 대상**: `POST /admin/schedule/trigger/{job_id}`
        - **목적**: 미인증 사용자가 스케줄러 잡 실행 시 401 에러를 받는지 확인합니다.
        - **시나리오**:
            - 인증 헤더 없이 API를 호출합니다.
        - **Mock 대상**: 없음
        """
        response = client.post("/api/v1/admin/schedule/trigger/test_job")
>       assert response.status_code == 401
E       assert 403 == 401
E        +  where 403 = <Response [403 Forbidden]>.status_code

tests/integration/test_api_admin_integration.py:413: AssertionError
---------------------------- Captured stdout setup -----------------------------
2025-08-31 18:07:53,712 - asyncio - DEBUG - Using selector: EpollSelector
2025-08-31 18:07:53,732 - src.api.main - INFO - 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
2025-08-31 18:07:53,986 - src.api.main - INFO - 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 18:07:53,993 - src.api.main - INFO - 테스트 StockMaster 데이터 시딩 완료.
2025-08-31 18:07:53,994 - src.api.main - INFO - 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 18:07:54,008 - src.api.main - INFO - 테스트 DailyPrice 데이터 시딩 완료.
------------------------------ Captured log setup ------------------------------
DEBUG    asyncio:selector_events.py:54 Using selector: EpollSelector
INFO     src.api.main:main.py:58 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
INFO     src.api.main:main.py:62 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:77 테스트 StockMaster 데이터 시딩 완료.
INFO     src.api.main:main.py:80 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:106 테스트 DailyPrice 데이터 시딩 완료.
----------------------------- Captured stdout call -----------------------------
2025-08-31 18:07:54,015 - httpx - INFO - HTTP Request: POST http://testserver/api/v1/admin/schedule/trigger/test_job "HTTP/1.1 403 Forbidden"
------------------------------ Captured log call -------------------------------
INFO     httpx:_client.py:1025 HTTP Request: POST http://testserver/api/v1/admin/schedule/trigger/test_job "HTTP/1.1 403 Forbidden"
_______ TestAdminRouter.test_trigger_check_disclosures_success_as_admin ________

self = <test_api_admin_integration.TestAdminRouter object at 0x7f42967e3280>
mock_check_and_notify = <AsyncMock name='check_and_notify_new_disclosures' id='139923944834672'>
client = <starlette.testclient.TestClient object at 0x7f4295422dd0>
admin_user_and_headers = (<src.common.models.user.User object at 0x7f42954233d0>, {'Authorization': 'Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ...YwM2Q0MGExIiwicm9sZSI6ImFkbWluIiwidXNlcl9pZCI6MSwiZXhwIjoxNzU2NjY1NDc0fQ.RaRQt3jmkTMjGlCdzs_d33HNMckfIRlCFuNUafJU1Gc'})

    @patch('src.api.routers.admin.StockService.check_and_notify_new_disclosures')
    def test_trigger_check_disclosures_success_as_admin(self, mock_check_and_notify, client: TestClient, admin_user_and_headers):
        """
        - **테스트 대상**: `POST /admin/trigger/check_disclosures`
        - **목적**: 관리자가 공시 확인 잡을 수동으로 성공적으로 실행하는지 확인합니다.
        - **시나리오**:
            - 관리자로 인증합니다.
            - 공시 확인 잡 실행 API를 호출합니다.
        - **Mock 대상**:
            - `src.api.routers.admin.StockService.check_and_notify_new_disclosures`
            - `get_current_active_admin_user`
        """
        admin_user, headers = admin_user_and_headers
        app.dependency_overrides[get_current_active_admin_user] = lambda: admin_user
    
        mock_check_and_notify.return_value = None
        response = client.post("/api/v1/admin/trigger/check_disclosures", headers=headers)
    
>       assert response.status_code == 200
E       assert 404 == 200
E        +  where 404 = <Response [404 Not Found]>.status_code

tests/integration/test_api_admin_integration.py:433: AssertionError
---------------------------- Captured stdout setup -----------------------------
2025-08-31 18:07:54,242 - asyncio - DEBUG - Using selector: EpollSelector
2025-08-31 18:07:54,260 - src.api.main - INFO - 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
2025-08-31 18:07:54,452 - src.api.main - INFO - 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 18:07:54,459 - src.api.main - INFO - 테스트 StockMaster 데이터 시딩 완료.
2025-08-31 18:07:54,459 - src.api.main - INFO - 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 18:07:54,472 - src.api.main - INFO - 테스트 DailyPrice 데이터 시딩 완료.
------------------------------ Captured log setup ------------------------------
DEBUG    asyncio:selector_events.py:54 Using selector: EpollSelector
INFO     src.api.main:main.py:58 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
INFO     src.api.main:main.py:62 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:77 테스트 StockMaster 데이터 시딩 완료.
INFO     src.api.main:main.py:80 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:106 테스트 DailyPrice 데이터 시딩 완료.
----------------------------- Captured stdout call -----------------------------
2025-08-31 18:07:54,795 - httpx - INFO - HTTP Request: POST http://testserver/api/v1/admin/trigger/check_disclosures "HTTP/1.1 404 Not Found"
------------------------------ Captured log call -------------------------------
INFO     httpx:_client.py:1025 HTTP Request: POST http://testserver/api/v1/admin/trigger/check_disclosures "HTTP/1.1 404 Not Found"
_______ TestAdminRouter.test_trigger_check_disclosures_failure_as_admin ________

self = <test_api_admin_integration.TestAdminRouter object at 0x7f42967e2c50>
mock_check_and_notify = <AsyncMock name='check_and_notify_new_disclosures' id='139923944680336'>
client = <starlette.testclient.TestClient object at 0x7f42954206a0>
admin_user_and_headers = (<src.common.models.user.User object at 0x7f4295072050>, {'Authorization': 'Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ...g4Mjc1ZDljIiwicm9sZSI6ImFkbWluIiwidXNlcl9pZCI6MSwiZXhwIjoxNzU2NjY1NDc1fQ.izk8EXRNo3HoX1zY3eFc6NB8QNJgxd30XOrRHvnwF2g'})

    @patch('src.api.routers.admin.StockService.check_and_notify_new_disclosures')
    def test_trigger_check_disclosures_failure_as_admin(self, mock_check_and_notify, client: TestClient, admin_user_and_headers):
        """
        - **테스트 대상**: `POST /admin/trigger/check_disclosures`
        - **목적**: 공시 확인 잡 실행 중 오류 발생 시 500 에러를 반환하는지 확인합니다.
        - **시나리오**:
            - 관리자로 인증합니다.
            - `check_and_notify_new_disclosures` 서비스가 예외를 발생시키도록 설정합니다.
            - API를 호출합니다.
        - **Mock 대상**:
            - `src.api.routers.admin.StockService.check_and_notify_new_disclosures` (예외 발생)
            - `get_current_active_admin_user`
        """
        admin_user, headers = admin_user_and_headers
        app.dependency_overrides[get_current_active_admin_user] = lambda: admin_user
    
        mock_check_and_notify.side_effect = Exception("Disclosure check failed")
        response = client.post("/api/v1/admin/trigger/check_disclosures", headers=headers)
    
>       assert response.status_code == 500
E       assert 404 == 500
E        +  where 404 = <Response [404 Not Found]>.status_code

tests/integration/test_api_admin_integration.py:458: AssertionError
---------------------------- Captured stdout setup -----------------------------
2025-08-31 18:07:54,985 - asyncio - DEBUG - Using selector: EpollSelector
2025-08-31 18:07:54,995 - src.api.main - INFO - 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
2025-08-31 18:07:55,165 - src.api.main - INFO - 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 18:07:55,172 - src.api.main - INFO - 테스트 StockMaster 데이터 시딩 완료.
2025-08-31 18:07:55,173 - src.api.main - INFO - 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 18:07:55,186 - src.api.main - INFO - 테스트 DailyPrice 데이터 시딩 완료.
------------------------------ Captured log setup ------------------------------
DEBUG    asyncio:selector_events.py:54 Using selector: EpollSelector
INFO     src.api.main:main.py:58 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
INFO     src.api.main:main.py:62 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:77 테스트 StockMaster 데이터 시딩 완료.
INFO     src.api.main:main.py:80 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:106 테스트 DailyPrice 데이터 시딩 완료.
----------------------------- Captured stdout call -----------------------------
2025-08-31 18:07:55,512 - httpx - INFO - HTTP Request: POST http://testserver/api/v1/admin/trigger/check_disclosures "HTTP/1.1 404 Not Found"
------------------------------ Captured log call -------------------------------
INFO     httpx:_client.py:1025 HTTP Request: POST http://testserver/api/v1/admin/trigger/check_disclosures "HTTP/1.1 404 Not Found"
________ TestAdminRouter.test_trigger_check_disclosures_as_normal_user _________

self = <test_api_admin_integration.TestAdminRouter object at 0x7f42967e2d70>
client = <starlette.testclient.TestClient object at 0x7f42950707f0>
normal_user_and_headers = (<src.common.models.user.User object at 0x7f4295070670>, {'Authorization': 'Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ...YmFlMGRiYWY3Iiwicm9sZSI6InVzZXIiLCJ1c2VyX2lkIjoxLCJleHAiOjE3NTY2NjU0NzZ9.FZGzOahnP6iii99uAARzgOiBdISODSgMgBZK-wS7_Ek'})

    def test_trigger_check_disclosures_as_normal_user(self, client: TestClient, normal_user_and_headers):
        """
        - **테스트 대상**: `POST /admin/trigger/check_disclosures`
        - **목적**: 일반 사용자가 공시 확인 잡 실행 시 403 에러를 받는지 확인합니다.
        - **시나리오**:
            - 일반 사용자로 인증 후 API를 호출합니다.
        - **Mock 대상**: 없음
        """
        _, headers = normal_user_and_headers
        response = client.post("/api/v1/admin/trigger/check_disclosures", headers=headers)
>       assert response.status_code == 403
E       assert 404 == 403
E        +  where 404 = <Response [404 Not Found]>.status_code

tests/integration/test_api_admin_integration.py:474: AssertionError
---------------------------- Captured stdout setup -----------------------------
2025-08-31 18:07:55,715 - asyncio - DEBUG - Using selector: EpollSelector
2025-08-31 18:07:55,727 - src.api.main - INFO - 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
2025-08-31 18:07:55,914 - src.api.main - INFO - 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 18:07:55,923 - src.api.main - INFO - 테스트 StockMaster 데이터 시딩 완료.
2025-08-31 18:07:55,924 - src.api.main - INFO - 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 18:07:55,940 - src.api.main - INFO - 테스트 DailyPrice 데이터 시딩 완료.
------------------------------ Captured log setup ------------------------------
DEBUG    asyncio:selector_events.py:54 Using selector: EpollSelector
INFO     src.api.main:main.py:58 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
INFO     src.api.main:main.py:62 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:77 테스트 StockMaster 데이터 시딩 완료.
INFO     src.api.main:main.py:80 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:106 테스트 DailyPrice 데이터 시딩 완료.
----------------------------- Captured stdout call -----------------------------
2025-08-31 18:07:56,316 - httpx - INFO - HTTP Request: POST http://testserver/api/v1/admin/trigger/check_disclosures "HTTP/1.1 404 Not Found"
------------------------------ Captured log call -------------------------------
INFO     httpx:_client.py:1025 HTTP Request: POST http://testserver/api/v1/admin/trigger/check_disclosures "HTTP/1.1 404 Not Found"
________ TestAdminRouter.test_trigger_check_disclosures_unauthenticated ________

self = <test_api_admin_integration.TestAdminRouter object at 0x7f42967e2860>
client = <starlette.testclient.TestClient object at 0x7f4295050cd0>

    def test_trigger_check_disclosures_unauthenticated(self, client: TestClient):
        """
        - **테스트 대상**: `POST /admin/trigger/check_disclosures`
        - **목적**: 미인증 사용자가 공시 확인 잡 실행 시 401 에러를 받는지 확인합니다.
        - **시나리오**:
            - 인증 헤더 없이 API를 호출합니다.
        - **Mock 대상**: 없음
        """
        response = client.post("/api/v1/admin/trigger/check_disclosures")
>       assert response.status_code == 401
E       assert 404 == 401
E        +  where 404 = <Response [404 Not Found]>.status_code

tests/integration/test_api_admin_integration.py:485: AssertionError
---------------------------- Captured stdout setup -----------------------------
2025-08-31 18:07:56,630 - asyncio - DEBUG - Using selector: EpollSelector
2025-08-31 18:07:56,656 - src.api.main - INFO - 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
2025-08-31 18:07:56,865 - src.api.main - INFO - 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 18:07:56,874 - src.api.main - INFO - 테스트 StockMaster 데이터 시딩 완료.
2025-08-31 18:07:56,875 - src.api.main - INFO - 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 18:07:56,889 - src.api.main - INFO - 테스트 DailyPrice 데이터 시딩 완료.
------------------------------ Captured log setup ------------------------------
DEBUG    asyncio:selector_events.py:54 Using selector: EpollSelector
INFO     src.api.main:main.py:58 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
INFO     src.api.main:main.py:62 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:77 테스트 StockMaster 데이터 시딩 완료.
INFO     src.api.main:main.py:80 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:106 테스트 DailyPrice 데이터 시딩 완료.
----------------------------- Captured stdout call -----------------------------
2025-08-31 18:07:56,894 - httpx - INFO - HTTP Request: POST http://testserver/api/v1/admin/trigger/check_disclosures "HTTP/1.1 404 Not Found"
------------------------------ Captured log call -------------------------------
INFO     httpx:_client.py:1025 HTTP Request: POST http://testserver/api/v1/admin/trigger/check_disclosures "HTTP/1.1 404 Not Found"
=============================== warnings summary ===============================
../../../usr/local/lib/python3.10/site-packages/pydantic/_internal/_config.py:323
../../../usr/local/lib/python3.10/site-packages/pydantic/_internal/_config.py:323
../../../usr/local/lib/python3.10/site-packages/pydantic/_internal/_config.py:323
  /usr/local/lib/python3.10/site-packages/pydantic/_internal/_config.py:323: PydanticDeprecatedSince20: Support for class-based `config` is deprecated, use ConfigDict instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.11/migration/
    warnings.warn(DEPRECATION_MESSAGE, DeprecationWarning)

../../../usr/local/lib/python3.10/site-packages/pydantic/_internal/_config.py:373
  /usr/local/lib/python3.10/site-packages/pydantic/_internal/_config.py:373: UserWarning: Valid config keys have changed in V2:
  * 'orm_mode' has been renamed to 'from_attributes'
    warnings.warn(message, UserWarning)

main.py:112
  /app/src/api/main.py:112: DeprecationWarning: 
          on_event is deprecated, use lifespan event handlers instead.
  
          Read more about it in the
          [FastAPI docs for Lifespan Events](https://fastapi.tiangolo.com/advanced/events/).
          
    @app.on_event("startup")

../../../usr/local/lib/python3.10/site-packages/fastapi/applications.py:4495
  /usr/local/lib/python3.10/site-packages/fastapi/applications.py:4495: DeprecationWarning: 
          on_event is deprecated, use lifespan event handlers instead.
  
          Read more about it in the
          [FastAPI docs for Lifespan Events](https://fastapi.tiangolo.com/advanced/events/).
          
    return self.router.on_event(event_type)

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
=========================== short test summary info ============================
FAILED tests/integration/test_api_admin_integration.py::TestAdminRouter::test_admin_stats_unauthenticated
FAILED tests/integration/test_api_admin_integration.py::TestAdminRouter::test_update_master_unauthenticated
FAILED tests/integration/test_api_admin_integration.py::TestAdminRouter::test_update_price_unauthenticated
FAILED tests/integration/test_api_admin_integration.py::TestAdminRouter::test_update_disclosure_all_success_as_admin
FAILED tests/integration/test_api_admin_integration.py::TestAdminRouter::test_update_disclosure_single_by_symbol_success_as_admin
FAILED tests/integration/test_api_admin_integration.py::TestAdminRouter::test_update_disclosure_not_found_as_admin
FAILED tests/integration/test_api_admin_integration.py::TestAdminRouter::test_update_disclosure_unauthenticated
FAILED tests/integration/test_api_admin_integration.py::TestAdminRouter::test_get_schedule_status_unauthenticated
FAILED tests/integration/test_api_admin_integration.py::TestAdminRouter::test_trigger_job_unauthenticated
FAILED tests/integration/test_api_admin_integration.py::TestAdminRouter::test_trigger_check_disclosures_success_as_admin
FAILED tests/integration/test_api_admin_integration.py::TestAdminRouter::test_trigger_check_disclosures_failure_as_admin
FAILED tests/integration/test_api_admin_integration.py::TestAdminRouter::test_trigger_check_disclosures_as_normal_user
FAILED tests/integration/test_api_admin_integration.py::TestAdminRouter::test_trigger_check_disclosures_unauthenticated
================== 13 failed, 11 passed, 6 warnings in 20.19s ==================
\n--- Running test_api_admin_integration.py ---
\n--- Running test_api_admin_integration.py ---
============================= test session starts ==============================
platform linux -- Python 3.10.18, pytest-8.4.1, pluggy-1.6.0
rootdir: /app/src/api
plugins: cov-6.2.1, timeout-2.4.0, anyio-4.10.0, asyncio-1.1.0
asyncio: mode=strict, asyncio_default_fixture_loop_scope=None, asyncio_default_test_loop_scope=function
collected 24 items

tests/integration/test_api_admin_integration.py ............FF......FFFF [100%]

=================================== FAILURES ===================================
___ TestAdminRouter.test_update_disclosure_single_by_symbol_success_as_admin ___

self = <test_api_admin_integration.TestAdminRouter object at 0x7fe47d1b89a0>
mock_update_disclosures = <AsyncMock name='update_disclosures' id='140619316579440'>
client = <starlette.testclient.TestClient object at 0x7fe47c69de40>
admin_user_and_headers = (<src.common.models.user.User object at 0x7fe47c69f970>, {'Authorization': 'Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ...g0NWU0MjAyIiwicm9sZSI6ImFkbWluIiwidXNlcl9pZCI6MSwiZXhwIjoxNzU2NjY1NzM2fQ._sDCYG09leLaqEQ_zOCiIDUqGYt149hlH7HpnuGeoB4'})

    @patch('src.api.routers.admin.StockService.update_disclosures')
    def test_update_disclosure_single_by_symbol_success_as_admin(self, mock_update_disclosures, client: TestClient, admin_user_and_headers):
        """
        - **테스트 대상**: `POST /admin/update_disclosure` (단일 종목)
        - **목적**: 관리자가 종목 코드를 이용해 단일 종목의 공시 정보 갱신을 성공적으로 요청하는지 확인합니다.
        - **시나리오**:
            - 관리자로 인증합니다.
            - `code_or_name` 파라미터에 종목 코드를 담아 API를 호출합니다.
        - **Mock 대상**:
            - `src.api.routers.admin.StockService.update_disclosures`
            - `get_db` (DB에서 종목 정보를 조회하는 부분을 모의 처리)
            - `get_current_active_admin_user`
        """
        admin_user, headers = admin_user_and_headers
        app.dependency_overrides[get_current_active_admin_user] = lambda: admin_user
    
        mock_stock = MagicMock(spec=StockMaster, symbol="005930", name="삼성전자", corp_code="0012345")
        def mock_get_db():
            mock_db_session = MagicMock(spec=Session)
            mock_db_session.query.return_value.filter.return_value.first.return_value = mock_stock
            yield mock_db_session
        app.dependency_overrides[get_db] = mock_get_db
    
        mock_update_disclosures.return_value = {"success": True, "inserted": 10, "skipped": 3, "errors": []}
        response = client.post("/api/v1/admin/update_disclosure", params={"code_or_name": "005930"}, headers=headers)
    
        assert response.status_code == 200
>       assert response.json()["message"] == "'삼성전자' 공시 이력 갱신 완료: 10건 추가, 3건 중복"
E       assert "'<MagicMock ...10건 추가, 3건 중복" == "'삼성전자' 공시 이력...10건 추가, 3건 중복"
E         
E         - '삼성전자' 공시 이력 갱신 완료: 10건 추가, 3건 중복
E         + '<MagicMock name='mock.query().filter().limit().all().__getitem__().name' id='140619316887808'>' 공시 이력 갱신 완료: 10건 추가, 3건 중복

tests/integration/test_api_admin_integration.py:308: AssertionError
---------------------------- Captured stdout setup -----------------------------
2025-08-31 18:12:16,242 - asyncio - DEBUG - Using selector: EpollSelector
2025-08-31 18:12:16,256 - src.api.main - INFO - 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
2025-08-31 18:12:16,463 - src.api.main - INFO - 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 18:12:16,470 - src.api.main - INFO - 테스트 StockMaster 데이터 시딩 완료.
2025-08-31 18:12:16,471 - src.api.main - INFO - 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 18:12:16,502 - src.api.main - INFO - 테스트 DailyPrice 데이터 시딩 완료.
------------------------------ Captured log setup ------------------------------
DEBUG    asyncio:selector_events.py:54 Using selector: EpollSelector
INFO     src.api.main:main.py:58 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
INFO     src.api.main:main.py:62 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:77 테스트 StockMaster 데이터 시딩 완료.
INFO     src.api.main:main.py:80 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:106 테스트 DailyPrice 데이터 시딩 완료.
----------------------------- Captured stdout call -----------------------------
2025-08-31 18:12:16,866 - src.common.services.stock_service - DEBUG - search_stocks 호출: keyword=005930, limit=1
2025-08-31 18:12:16,870 - src.common.services.stock_service - DEBUG - 검색 결과: 0개 종목 발견.
2025-08-31 18:12:16,877 - httpx - INFO - HTTP Request: POST http://testserver/api/v1/admin/update_disclosure?code_or_name=005930 "HTTP/1.1 200 OK"
------------------------------ Captured log call -------------------------------
DEBUG    src.common.services.stock_service:stock_service.py:224 search_stocks 호출: keyword=005930, limit=1
DEBUG    src.common.services.stock_service:stock_service.py:229 검색 결과: 0개 종목 발견.
INFO     httpx:_client.py:1025 HTTP Request: POST http://testserver/api/v1/admin/update_disclosure?code_or_name=005930 "HTTP/1.1 200 OK"
__________ TestAdminRouter.test_update_disclosure_not_found_as_admin ___________

self = <test_api_admin_integration.TestAdminRouter object at 0x7fe47d353fa0>
client = <starlette.testclient.TestClient object at 0x7fe47c6d81c0>
admin_user_and_headers = (<src.common.models.user.User object at 0x7fe47c6d9900>, {'Authorization': 'Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ...MyMDRmOWE1Iiwicm9sZSI6ImFkbWluIiwidXNlcl9pZCI6MSwiZXhwIjoxNzU2NjY1NzM3fQ.iZ26KDtv7xWfTGLmq-Vkzdy786RrIrh1x3KmJMGiToM'})

    def test_update_disclosure_not_found_as_admin(self, client: TestClient, admin_user_and_headers):
        """
        - **테스트 대상**: `POST /admin/update_disclosure` (단일 종목)
        - **목적**: 존재하지 않는 종목에 대해 공시 갱신 요청 시 404 에러를 반환하는지 확인합니다.
        - **시나리오**:
            - 관리자로 인증합니다.
            - 존재하지 않는 종목 코드로 API를 호출합니다.
        - **Mock 대상**:
            - `get_db` (DB 조회 결과가 `None`이 되도록 설정)
            - `get_current_active_admin_user`
        """
        admin_user, headers = admin_user_and_headers
        app.dependency_overrides[get_current_active_admin_user] = lambda: admin_user
    
        def mock_get_db_not_found():
            mock_db_session = MagicMock(spec=Session)
            mock_db_session.query.return_value.filter.return_value.first.return_value = None
            yield mock_db_session
        app.dependency_overrides[get_db] = mock_get_db_not_found
    
        response = client.post("/api/v1/admin/update_disclosure", params={"code_or_name": "NONEXIST"}, headers=headers)
>       assert response.status_code == 404
E       assert 500 == 404
E        +  where 500 = <Response [500 Internal Server Error]>.status_code

tests/integration/test_api_admin_integration.py:336: AssertionError
---------------------------- Captured stdout setup -----------------------------
2025-08-31 18:12:17,317 - asyncio - DEBUG - Using selector: EpollSelector
2025-08-31 18:12:17,331 - src.api.main - INFO - 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
2025-08-31 18:12:17,536 - src.api.main - INFO - 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 18:12:17,545 - src.api.main - INFO - 테스트 StockMaster 데이터 시딩 완료.
2025-08-31 18:12:17,546 - src.api.main - INFO - 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 18:12:17,558 - src.api.main - INFO - 테스트 DailyPrice 데이터 시딩 완료.
------------------------------ Captured log setup ------------------------------
DEBUG    asyncio:selector_events.py:54 Using selector: EpollSelector
INFO     src.api.main:main.py:58 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
INFO     src.api.main:main.py:62 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:77 테스트 StockMaster 데이터 시딩 완료.
INFO     src.api.main:main.py:80 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:106 테스트 DailyPrice 데이터 시딩 완료.
----------------------------- Captured stdout call -----------------------------
2025-08-31 18:12:17,885 - src.common.services.stock_service - DEBUG - search_stocks 호출: keyword=NONEXIST, limit=1
2025-08-31 18:12:17,897 - src.common.services.stock_service - DEBUG - 검색 결과: 0개 종목 발견.
2025-08-31 18:12:17,902 - src.common.services.stock_service - DEBUG - update_disclosures 호출: corp_code=<MagicMock name='mock.query().filter().limit().all().__getitem__().corp_code' id='140619318332336'>, stock_code=<MagicMock name='mock.query().filter().limit().all().__getitem__().symbol' id='140619316582512'>, max_count=10
2025-08-31 18:12:17,903 - src.common.utils.dart_utils - DEBUG - DART 공시 조회 시작: bgn_de=20250824, end_de=20250831, page_size=10
2025-08-31 18:12:17,924 - httpcore.connection - DEBUG - connect_tcp.started host='opendart.fss.or.kr' port=443 local_address=None timeout=10 socket_options=None
2025-08-31 18:12:17,949 - httpcore.connection - DEBUG - connect_tcp.complete return_value=<httpcore._backends.anyio.AnyIOStream object at 0x7fe47c6e1cf0>
2025-08-31 18:12:17,950 - httpcore.connection - DEBUG - start_tls.started ssl_context=<ssl.SSLContext object at 0x7fe47c830640> server_hostname='opendart.fss.or.kr' timeout=10
2025-08-31 18:12:18,012 - httpcore.connection - DEBUG - start_tls.complete return_value=<httpcore._backends.anyio.AnyIOStream object at 0x7fe47c7541c0>
2025-08-31 18:12:18,014 - httpcore.http11 - DEBUG - send_request_headers.started request=<Request [b'GET']>
2025-08-31 18:12:18,016 - httpcore.http11 - DEBUG - send_request_headers.complete
2025-08-31 18:12:18,017 - httpcore.http11 - DEBUG - send_request_body.started request=<Request [b'GET']>
2025-08-31 18:12:18,019 - httpcore.http11 - DEBUG - send_request_body.complete
2025-08-31 18:12:18,020 - httpcore.http11 - DEBUG - receive_response_headers.started request=<Request [b'GET']>
2025-08-31 18:12:18,049 - httpcore.http11 - DEBUG - receive_response_headers.complete return_value=(b'HTTP/1.1', 200, b'OK', [(b'Cache-Control', b'no-cache'), (b'Cache-Control', b'no-store'), (b'Connection', b'keep-alive'), (b'Set-Cookie', b'WMONID=gu_jwUE6Zru; Expires=Tue, 01-Sep-2026 3:12:16 GMT; Path=/'), (b'Pragma', b'no-cache'), (b'Expires', b'Thu, 01 Jan 1970 00:00:00 GMT'), (b'Date', b'Sun, 31 Aug 2025 18:12:16 GMT'), (b'Content-Type', b'application/json;charset=UTF-8'), (b'Transfer-Encoding', b'chunked')])
2025-08-31 18:12:18,051 - httpx - INFO - HTTP Request: GET https://opendart.fss.or.kr/api/list.json?crtfc_key=f65587803bfc7b8c2a82eb0d5a2b0722b0c2d63f&bgn_de=20250824&end_de=20250831&page_size=10&page_no=1&corp_code=%3CMagicMock+name%3D%27mock.query%28%29.filter%28%29.limit%28%29.all%28%29.__getitem__%28%29.corp_code%27+id%3D%27140619318332336%27%3E "HTTP/1.1 200 OK"
2025-08-31 18:12:18,051 - httpcore.http11 - DEBUG - receive_response_body.started request=<Request [b'GET']>
2025-08-31 18:12:18,052 - httpcore.http11 - DEBUG - receive_response_body.complete
2025-08-31 18:12:18,053 - httpcore.http11 - DEBUG - response_closed.started
2025-08-31 18:12:18,053 - httpcore.http11 - DEBUG - response_closed.complete
2025-08-31 18:12:18,054 - src.common.utils.dart_utils - DEBUG - DART API 응답 (page_no=1): {'status': '100', 'message': 'corp_code가 필드의 부적절한 값입니다.'}
2025-08-31 18:12:18,055 - src.common.utils.dart_utils - ERROR - DART 공시 API가 오류를 반환했습니다. status: 100, message: corp_code가 필드의 부적절한 값입니다., corp_code: <MagicMock name='mock.query().filter().limit().all().__getitem__().corp_code' id='140619318332336'>, page_no: 1
2025-08-31 18:12:18,055 - httpcore.connection - DEBUG - close.started
2025-08-31 18:12:18,056 - httpcore.connection - DEBUG - close.complete
2025-08-31 18:12:18,059 - src.common.services.stock_service - ERROR - 공시 갱신 실패 (corp_code=<MagicMock name='mock.query().filter().limit().all().__getitem__().corp_code' id='140619318332336'>): [100] corp_code가 필드의 부적절한 값입니다.
Traceback (most recent call last):
  File "/app/src/common/services/stock_service.py", line 520, in update_disclosures
    disclosures = await dart_get_disclosures(corp_code, page_size=max_count)
  File "/app/src/common/utils/dart_utils.py", line 108, in dart_get_disclosures
    raise DartApiError(message, status_code=status)
src.common.utils.exceptions.DartApiError: [100] corp_code가 필드의 부적절한 값입니다.
2025-08-31 18:12:18,063 - httpx - INFO - HTTP Request: POST http://testserver/api/v1/admin/update_disclosure?code_or_name=NONEXIST "HTTP/1.1 500 Internal Server Error"
------------------------------ Captured log call -------------------------------
DEBUG    src.common.services.stock_service:stock_service.py:224 search_stocks 호출: keyword=NONEXIST, limit=1
DEBUG    src.common.services.stock_service:stock_service.py:229 검색 결과: 0개 종목 발견.
DEBUG    src.common.services.stock_service:stock_service.py:517 update_disclosures 호출: corp_code=<MagicMock name='mock.query().filter().limit().all().__getitem__().corp_code' id='140619318332336'>, stock_code=<MagicMock name='mock.query().filter().limit().all().__getitem__().symbol' id='140619316582512'>, max_count=10
DEBUG    src.common.utils.dart_utils:dart_utils.py:78 DART 공시 조회 시작: bgn_de=20250824, end_de=20250831, page_size=10
DEBUG    httpcore.connection:_trace.py:87 connect_tcp.started host='opendart.fss.or.kr' port=443 local_address=None timeout=10 socket_options=None
DEBUG    httpcore.connection:_trace.py:87 connect_tcp.complete return_value=<httpcore._backends.anyio.AnyIOStream object at 0x7fe47c6e1cf0>
DEBUG    httpcore.connection:_trace.py:87 start_tls.started ssl_context=<ssl.SSLContext object at 0x7fe47c830640> server_hostname='opendart.fss.or.kr' timeout=10
DEBUG    httpcore.connection:_trace.py:87 start_tls.complete return_value=<httpcore._backends.anyio.AnyIOStream object at 0x7fe47c7541c0>
DEBUG    httpcore.http11:_trace.py:87 send_request_headers.started request=<Request [b'GET']>
DEBUG    httpcore.http11:_trace.py:87 send_request_headers.complete
DEBUG    httpcore.http11:_trace.py:87 send_request_body.started request=<Request [b'GET']>
DEBUG    httpcore.http11:_trace.py:87 send_request_body.complete
DEBUG    httpcore.http11:_trace.py:87 receive_response_headers.started request=<Request [b'GET']>
DEBUG    httpcore.http11:_trace.py:87 receive_response_headers.complete return_value=(b'HTTP/1.1', 200, b'OK', [(b'Cache-Control', b'no-cache'), (b'Cache-Control', b'no-store'), (b'Connection', b'keep-alive'), (b'Set-Cookie', b'WMONID=gu_jwUE6Zru; Expires=Tue, 01-Sep-2026 3:12:16 GMT; Path=/'), (b'Pragma', b'no-cache'), (b'Expires', b'Thu, 01 Jan 1970 00:00:00 GMT'), (b'Date', b'Sun, 31 Aug 2025 18:12:16 GMT'), (b'Content-Type', b'application/json;charset=UTF-8'), (b'Transfer-Encoding', b'chunked')])
INFO     httpx:_client.py:1740 HTTP Request: GET https://opendart.fss.or.kr/api/list.json?crtfc_key=f65587803bfc7b8c2a82eb0d5a2b0722b0c2d63f&bgn_de=20250824&end_de=20250831&page_size=10&page_no=1&corp_code=%3CMagicMock+name%3D%27mock.query%28%29.filter%28%29.limit%28%29.all%28%29.__getitem__%28%29.corp_code%27+id%3D%27140619318332336%27%3E "HTTP/1.1 200 OK"
DEBUG    httpcore.http11:_trace.py:87 receive_response_body.started request=<Request [b'GET']>
DEBUG    httpcore.http11:_trace.py:87 receive_response_body.complete
DEBUG    httpcore.http11:_trace.py:87 response_closed.started
DEBUG    httpcore.http11:_trace.py:87 response_closed.complete
DEBUG    src.common.utils.dart_utils:dart_utils.py:96 DART API 응답 (page_no=1): {'status': '100', 'message': 'corp_code가 필드의 부적절한 값입니다.'}
ERROR    src.common.utils.dart_utils:dart_utils.py:107 DART 공시 API가 오류를 반환했습니다. status: 100, message: corp_code가 필드의 부적절한 값입니다., corp_code: <MagicMock name='mock.query().filter().limit().all().__getitem__().corp_code' id='140619318332336'>, page_no: 1
DEBUG    httpcore.connection:_trace.py:87 close.started
DEBUG    httpcore.connection:_trace.py:87 close.complete
ERROR    src.common.services.stock_service:stock_service.py:560 공시 갱신 실패 (corp_code=<MagicMock name='mock.query().filter().limit().all().__getitem__().corp_code' id='140619318332336'>): [100] corp_code가 필드의 부적절한 값입니다.
Traceback (most recent call last):
  File "/app/src/common/services/stock_service.py", line 520, in update_disclosures
    disclosures = await dart_get_disclosures(corp_code, page_size=max_count)
  File "/app/src/common/utils/dart_utils.py", line 108, in dart_get_disclosures
    raise DartApiError(message, status_code=status)
src.common.utils.exceptions.DartApiError: [100] corp_code가 필드의 부적절한 값입니다.
INFO     httpx:_client.py:1025 HTTP Request: POST http://testserver/api/v1/admin/update_disclosure?code_or_name=NONEXIST "HTTP/1.1 500 Internal Server Error"
_______ TestAdminRouter.test_trigger_check_disclosures_success_as_admin ________

self = <test_api_admin_integration.TestAdminRouter object at 0x7fe47d352d70>
mock_check_and_notify = <AsyncMock name='check_and_notify_new_disclosures' id='140619317278944'>
client = <starlette.testclient.TestClient object at 0x7fe47c77f130>
admin_user_and_headers = (<src.common.models.user.User object at 0x7fe47c77ebc0>, {'Authorization': 'Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ...I0M2RmOGRjIiwicm9sZSI6ImFkbWluIiwidXNlcl9pZCI6MSwiZXhwIjoxNzU2NjY1NzQyfQ.xiP11DuVSOGdacS11oWAuYy4oQVReyPbyc5HjKjxgcw'})

    @patch('src.common.services.stock_service.StockService.check_and_notify_new_disclosures')
    def test_trigger_check_disclosures_success_as_admin(self, mock_check_and_notify, client: TestClient, admin_user_and_headers):
        """
        - **테스트 대상**: `POST /admin/trigger/check_disclosures`
        - **목적**: 관리자가 공시 확인 잡을 수동으로 성공적으로 실행하는지 확인합니다.
        - **시나리오**:
            - 관리자로 인증합니다.
            - 공시 확인 잡 실행 API를 호출합니다.
        - **Mock 대상**:
            - `src.api.routers.admin.StockService.check_and_notify_new_disclosures`
            - `get_current_active_admin_user`
        """
        admin_user, headers = admin_user_and_headers
        app.dependency_overrides[get_current_active_admin_user] = lambda: admin_user
    
        mock_check_and_notify.return_value = None
        response = client.post("/api/v1/admin/trigger/check_disclosures", headers=headers)
    
>       assert response.status_code == 200
E       assert 404 == 200
E        +  where 404 = <Response [404 Not Found]>.status_code

tests/integration/test_api_admin_integration.py:433: AssertionError
---------------------------- Captured stdout setup -----------------------------
2025-08-31 18:12:21,829 - asyncio - DEBUG - Using selector: EpollSelector
2025-08-31 18:12:21,841 - src.api.main - INFO - 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
2025-08-31 18:12:22,078 - src.api.main - INFO - 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 18:12:22,086 - src.api.main - INFO - 테스트 StockMaster 데이터 시딩 완료.
2025-08-31 18:12:22,086 - src.api.main - INFO - 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 18:12:22,099 - src.api.main - INFO - 테스트 DailyPrice 데이터 시딩 완료.
------------------------------ Captured log setup ------------------------------
DEBUG    asyncio:selector_events.py:54 Using selector: EpollSelector
INFO     src.api.main:main.py:58 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
INFO     src.api.main:main.py:62 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:77 테스트 StockMaster 데이터 시딩 완료.
INFO     src.api.main:main.py:80 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:106 테스트 DailyPrice 데이터 시딩 완료.
----------------------------- Captured stdout call -----------------------------
2025-08-31 18:12:22,430 - httpx - INFO - HTTP Request: POST http://testserver/api/v1/admin/trigger/check_disclosures "HTTP/1.1 404 Not Found"
------------------------------ Captured log call -------------------------------
INFO     httpx:_client.py:1025 HTTP Request: POST http://testserver/api/v1/admin/trigger/check_disclosures "HTTP/1.1 404 Not Found"
_______ TestAdminRouter.test_trigger_check_disclosures_failure_as_admin ________

self = <test_api_admin_integration.TestAdminRouter object at 0x7fe47d353040>
mock_check_and_notify = <AsyncMock name='check_and_notify_new_disclosures' id='140619315803472'>
client = <starlette.testclient.TestClient object at 0x7fe47c6e0d30>
admin_user_and_headers = (<src.common.models.user.User object at 0x7fe47c6e0b50>, {'Authorization': 'Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ...JiYmRjNmY0Iiwicm9sZSI6ImFkbWluIiwidXNlcl9pZCI6MSwiZXhwIjoxNzU2NjY1NzQzfQ.yCgtW8UUZFhP0NAc_Iq9Kck850GfGIoaJP68ARo_OEY'})

    @patch('src.common.services.stock_service.StockService.check_and_notify_new_disclosures')
    def test_trigger_check_disclosures_failure_as_admin(self, mock_check_and_notify, client: TestClient, admin_user_and_headers):
        """
        - **테스트 대상**: `POST /admin/trigger/check_disclosures`
        - **목적**: 공시 확인 잡 실행 중 오류 발생 시 500 에러를 반환하는지 확인합니다.
        - **시나리오**:
            - 관리자로 인증합니다.
            - `check_and_notify_new_disclosures` 서비스가 예외를 발생시키도록 설정합니다.
            - API를 호출합니다.
        - **Mock 대상**:
            - `src.api.routers.admin.StockService.check_and_notify_new_disclosures` (예외 발생)
            - `get_current_active_admin_user`
        """
        admin_user, headers = admin_user_and_headers
        app.dependency_overrides[get_current_active_admin_user] = lambda: admin_user
    
        mock_check_and_notify.side_effect = Exception("Disclosure check failed")
        response = client.post("/api/v1/admin/trigger/check_disclosures", headers=headers)
    
>       assert response.status_code == 500
E       assert 404 == 500
E        +  where 404 = <Response [404 Not Found]>.status_code

tests/integration/test_api_admin_integration.py:458: AssertionError
---------------------------- Captured stdout setup -----------------------------
2025-08-31 18:12:22,641 - asyncio - DEBUG - Using selector: EpollSelector
2025-08-31 18:12:22,653 - src.api.main - INFO - 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
2025-08-31 18:12:22,825 - src.api.main - INFO - 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 18:12:22,833 - src.api.main - INFO - 테스트 StockMaster 데이터 시딩 완료.
2025-08-31 18:12:22,833 - src.api.main - INFO - 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 18:12:22,844 - src.api.main - INFO - 테스트 DailyPrice 데이터 시딩 완료.
------------------------------ Captured log setup ------------------------------
DEBUG    asyncio:selector_events.py:54 Using selector: EpollSelector
INFO     src.api.main:main.py:58 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
INFO     src.api.main:main.py:62 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:77 테스트 StockMaster 데이터 시딩 완료.
INFO     src.api.main:main.py:80 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:106 테스트 DailyPrice 데이터 시딩 완료.
----------------------------- Captured stdout call -----------------------------
2025-08-31 18:12:23,132 - httpx - INFO - HTTP Request: POST http://testserver/api/v1/admin/trigger/check_disclosures "HTTP/1.1 404 Not Found"
------------------------------ Captured log call -------------------------------
INFO     httpx:_client.py:1025 HTTP Request: POST http://testserver/api/v1/admin/trigger/check_disclosures "HTTP/1.1 404 Not Found"
________ TestAdminRouter.test_trigger_check_disclosures_as_normal_user _________

self = <test_api_admin_integration.TestAdminRouter object at 0x7fe47d3528c0>
client = <starlette.testclient.TestClient object at 0x7fe47c5dfbe0>
normal_user_and_headers = (<src.common.models.user.User object at 0x7fe47c5ded70>, {'Authorization': 'Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ...MzdlZTczMWUxIiwicm9sZSI6InVzZXIiLCJ1c2VyX2lkIjoxLCJleHAiOjE3NTY2NjU3NDR9.bGfqK7Amf1LR08hlDXA3H_6v_0W9-8bw_05ziuhOcbM'})

    def test_trigger_check_disclosures_as_normal_user(self, client: TestClient, normal_user_and_headers):
        """
        - **테스트 대상**: `POST /admin/trigger/check_disclosures`
        - **목적**: 일반 사용자가 공시 확인 잡 실행 시 403 에러를 받는지 확인합니다.
        - **시나리오**:
            - 일반 사용자로 인증 후 API를 호출합니다.
        - **Mock 대상**: 없음
        """
        _, headers = normal_user_and_headers
        response = client.post("/api/v1/admin/trigger/check_disclosures", headers=headers)
>       assert response.status_code == 403
E       assert 404 == 403
E        +  where 404 = <Response [404 Not Found]>.status_code

tests/integration/test_api_admin_integration.py:474: AssertionError
---------------------------- Captured stdout setup -----------------------------
2025-08-31 18:12:23,333 - asyncio - DEBUG - Using selector: EpollSelector
2025-08-31 18:12:23,359 - src.api.main - INFO - 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
2025-08-31 18:12:23,616 - src.api.main - INFO - 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 18:12:23,627 - src.api.main - INFO - 테스트 StockMaster 데이터 시딩 완료.
2025-08-31 18:12:23,627 - src.api.main - INFO - 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 18:12:23,651 - src.api.main - INFO - 테스트 DailyPrice 데이터 시딩 완료.
------------------------------ Captured log setup ------------------------------
DEBUG    asyncio:selector_events.py:54 Using selector: EpollSelector
INFO     src.api.main:main.py:58 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
INFO     src.api.main:main.py:62 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:77 테스트 StockMaster 데이터 시딩 완료.
INFO     src.api.main:main.py:80 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:106 테스트 DailyPrice 데이터 시딩 완료.
----------------------------- Captured stdout call -----------------------------
2025-08-31 18:12:24,082 - httpx - INFO - HTTP Request: POST http://testserver/api/v1/admin/trigger/check_disclosures "HTTP/1.1 404 Not Found"
------------------------------ Captured log call -------------------------------
INFO     httpx:_client.py:1025 HTTP Request: POST http://testserver/api/v1/admin/trigger/check_disclosures "HTTP/1.1 404 Not Found"
________ TestAdminRouter.test_trigger_check_disclosures_unauthenticated ________

self = <test_api_admin_integration.TestAdminRouter object at 0x7fe47d352b60>
client = <starlette.testclient.TestClient object at 0x7fe47c7476a0>

    def test_trigger_check_disclosures_unauthenticated(self, client: TestClient):
        """
        - **테스트 대상**: `POST /admin/trigger/check_disclosures`
        - **목적**: 미인증 사용자가 공시 확인 잡 실행 시 401 에러를 받는지 확인합니다.
        - **시나리오**:
            - 인증 헤더 없이 API를 호출합니다.
        - **Mock 대상**: 없음
        """
        response = client.post("/api/v1/admin/trigger/check_disclosures")
>       assert response.status_code == 403
E       assert 404 == 403
E        +  where 404 = <Response [404 Not Found]>.status_code

tests/integration/test_api_admin_integration.py:485: AssertionError
---------------------------- Captured stdout setup -----------------------------
2025-08-31 18:12:24,305 - asyncio - DEBUG - Using selector: EpollSelector
2025-08-31 18:12:24,324 - src.api.main - INFO - 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
2025-08-31 18:12:24,516 - src.api.main - INFO - 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 18:12:24,524 - src.api.main - INFO - 테스트 StockMaster 데이터 시딩 완료.
2025-08-31 18:12:24,524 - src.api.main - INFO - 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
2025-08-31 18:12:24,537 - src.api.main - INFO - 테스트 DailyPrice 데이터 시딩 완료.
------------------------------ Captured log setup ------------------------------
DEBUG    asyncio:selector_events.py:54 Using selector: EpollSelector
INFO     src.api.main:main.py:58 개발 환경: 모든 테이블을 드롭하고 다시 생성합니다.
INFO     src.api.main:main.py:62 개발 환경: StockMaster 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:77 테스트 StockMaster 데이터 시딩 완료.
INFO     src.api.main:main.py:80 개발 환경: DailyPrice 테이블에 테스트 데이터를 시딩합니다.
INFO     src.api.main:main.py:106 테스트 DailyPrice 데이터 시딩 완료.
----------------------------- Captured stdout call -----------------------------
2025-08-31 18:12:24,542 - httpx - INFO - HTTP Request: POST http://testserver/api/v1/admin/trigger/check_disclosures "HTTP/1.1 404 Not Found"
------------------------------ Captured log call -------------------------------
INFO     httpx:_client.py:1025 HTTP Request: POST http://testserver/api/v1/admin/trigger/check_disclosures "HTTP/1.1 404 Not Found"
=============================== warnings summary ===============================
../../../usr/local/lib/python3.10/site-packages/pydantic/_internal/_config.py:323
../../../usr/local/lib/python3.10/site-packages/pydantic/_internal/_config.py:323
../../../usr/local/lib/python3.10/site-packages/pydantic/_internal/_config.py:323
  /usr/local/lib/python3.10/site-packages/pydantic/_internal/_config.py:323: PydanticDeprecatedSince20: Support for class-based `config` is deprecated, use ConfigDict instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.11/migration/
    warnings.warn(DEPRECATION_MESSAGE, DeprecationWarning)

../../../usr/local/lib/python3.10/site-packages/pydantic/_internal/_config.py:373
  /usr/local/lib/python3.10/site-packages/pydantic/_internal/_config.py:373: UserWarning: Valid config keys have changed in V2:
  * 'orm_mode' has been renamed to 'from_attributes'
    warnings.warn(message, UserWarning)

main.py:112
  /app/src/api/main.py:112: DeprecationWarning: 
          on_event is deprecated, use lifespan event handlers instead.
  
          Read more about it in the
          [FastAPI docs for Lifespan Events](https://fastapi.tiangolo.com/advanced/events/).
          
    @app.on_event("startup")

../../../usr/local/lib/python3.10/site-packages/fastapi/applications.py:4495
  /usr/local/lib/python3.10/site-packages/fastapi/applications.py:4495: DeprecationWarning: 
          on_event is deprecated, use lifespan event handlers instead.
  
          Read more about it in the
          [FastAPI docs for Lifespan Events](https://fastapi.tiangolo.com/advanced/events/).
          
    return self.router.on_event(event_type)

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
=========================== short test summary info ============================
FAILED tests/integration/test_api_admin_integration.py::TestAdminRouter::test_update_disclosure_single_by_symbol_success_as_admin
FAILED tests/integration/test_api_admin_integration.py::TestAdminRouter::test_update_disclosure_not_found_as_admin
FAILED tests/integration/test_api_admin_integration.py::TestAdminRouter::test_trigger_check_disclosures_success_as_admin
FAILED tests/integration/test_api_admin_integration.py::TestAdminRouter::test_trigger_check_disclosures_failure_as_admin
FAILED tests/integration/test_api_admin_integration.py::TestAdminRouter::test_trigger_check_disclosures_as_normal_user
FAILED tests/integration/test_api_admin_integration.py::TestAdminRouter::test_trigger_check_disclosures_unauthenticated
================== 6 failed, 18 passed, 6 warnings in 19.41s ===================
\n--- Running test_api_admin_integration.py ---
============================= test session starts ==============================
platform linux -- Python 3.10.18, pytest-8.4.1, pluggy-1.6.0
rootdir: /app/src/api
plugins: cov-6.2.1, timeout-2.4.0, anyio-4.10.0, asyncio-1.1.0
asyncio: mode=strict, asyncio_default_fixture_loop_scope=None, asyncio_default_test_loop_scope=function
collected 0 items / 1 error

==================================== ERRORS ====================================
_______ ERROR collecting tests/integration/test_api_admin_integration.py _______
/usr/local/lib/python3.10/site-packages/_pytest/python.py:498: in importtestmodule
    mod = import_path(
/usr/local/lib/python3.10/site-packages/_pytest/pathlib.py:587: in import_path
    importlib.import_module(module_name)
/usr/local/lib/python3.10/importlib/__init__.py:126: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
<frozen importlib._bootstrap>:1050: in _gcd_import
    ???
<frozen importlib._bootstrap>:1027: in _find_and_load
    ???
<frozen importlib._bootstrap>:1006: in _find_and_load_unlocked
    ???
<frozen importlib._bootstrap>:688: in _load_unlocked
    ???
/usr/local/lib/python3.10/site-packages/_pytest/assertion/rewrite.py:177: in exec_module
    source_stat, co = _rewrite_test(fn, self.config)
/usr/local/lib/python3.10/site-packages/_pytest/assertion/rewrite.py:357: in _rewrite_test
    tree = ast.parse(source, filename=strfn)
/usr/local/lib/python3.10/ast.py:50: in parse
    return compile(source, filename, mode, flags,
E     File "/app/src/api/tests/integration/test_api_admin_integration.py", line 490
E       #     assert response.status_code == 403
E                                               ^
E   IndentationError: unexpected unindent
=============================== warnings summary ===============================
../../../usr/local/lib/python3.10/site-packages/pydantic/_internal/_config.py:323
../../../usr/local/lib/python3.10/site-packages/pydantic/_internal/_config.py:323
../../../usr/local/lib/python3.10/site-packages/pydantic/_internal/_config.py:323
  /usr/local/lib/python3.10/site-packages/pydantic/_internal/_config.py:323: PydanticDeprecatedSince20: Support for class-based `config` is deprecated, use ConfigDict instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.11/migration/
    warnings.warn(DEPRECATION_MESSAGE, DeprecationWarning)

../../../usr/local/lib/python3.10/site-packages/pydantic/_internal/_config.py:373
  /usr/local/lib/python3.10/site-packages/pydantic/_internal/_config.py:373: UserWarning: Valid config keys have changed in V2:
  * 'orm_mode' has been renamed to 'from_attributes'
    warnings.warn(message, UserWarning)

main.py:112
  /app/src/api/main.py:112: DeprecationWarning: 
          on_event is deprecated, use lifespan event handlers instead.
  
          Read more about it in the
          [FastAPI docs for Lifespan Events](https://fastapi.tiangolo.com/advanced/events/).
          
    @app.on_event("startup")

../../../usr/local/lib/python3.10/site-packages/fastapi/applications.py:4495
  /usr/local/lib/python3.10/site-packages/fastapi/applications.py:4495: DeprecationWarning: 
          on_event is deprecated, use lifespan event handlers instead.
  
          Read more about it in the
          [FastAPI docs for Lifespan Events](https://fastapi.tiangolo.com/advanced/events/).
          
    return self.router.on_event(event_type)

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
=========================== short test summary info ============================
ERROR tests/integration/test_api_admin_integration.py
!!!!!!!!!!!!!!!!!!!! Interrupted: 1 error during collection !!!!!!!!!!!!!!!!!!!!
========================= 6 warnings, 1 error in 0.58s =========================
\n--- Running test_api_admin_integration.py ---
============================= test session starts ==============================
platform linux -- Python 3.10.18, pytest-8.4.1, pluggy-1.6.0
rootdir: /app/src/api
plugins: cov-6.2.1, timeout-2.4.0, anyio-4.10.0, asyncio-1.1.0
asyncio: mode=strict, asyncio_default_fixture_loop_scope=None, asyncio_default_test_loop_scope=function
collected 0 items / 1 error

==================================== ERRORS ====================================
_______ ERROR collecting tests/integration/test_api_admin_integration.py _______
/usr/local/lib/python3.10/site-packages/_pytest/python.py:498: in importtestmodule
    mod = import_path(
/usr/local/lib/python3.10/site-packages/_pytest/pathlib.py:587: in import_path
    importlib.import_module(module_name)
/usr/local/lib/python3.10/importlib/__init__.py:126: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
<frozen importlib._bootstrap>:1050: in _gcd_import
    ???
<frozen importlib._bootstrap>:1027: in _find_and_load
    ???
<frozen importlib._bootstrap>:1006: in _find_and_load_unlocked
    ???
<frozen importlib._bootstrap>:688: in _load_unlocked
    ???
/usr/local/lib/python3.10/site-packages/_pytest/assertion/rewrite.py:177: in exec_module
    source_stat, co = _rewrite_test(fn, self.config)
/usr/local/lib/python3.10/site-packages/_pytest/assertion/rewrite.py:357: in _rewrite_test
    tree = ast.parse(source, filename=strfn)
/usr/local/lib/python3.10/ast.py:50: in parse
    return compile(source, filename, mode, flags,
E     File "/app/src/api/tests/integration/test_api_admin_integration.py", line 490
E       #     assert response.status_code == 403
E                                               ^
E   IndentationError: unexpected unindent
=============================== warnings summary ===============================
../../../usr/local/lib/python3.10/site-packages/pydantic/_internal/_config.py:323
../../../usr/local/lib/python3.10/site-packages/pydantic/_internal/_config.py:323
../../../usr/local/lib/python3.10/site-packages/pydantic/_internal/_config.py:323
  /usr/local/lib/python3.10/site-packages/pydantic/_internal/_config.py:323: PydanticDeprecatedSince20: Support for class-based `config` is deprecated, use ConfigDict instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.11/migration/
    warnings.warn(DEPRECATION_MESSAGE, DeprecationWarning)

../../../usr/local/lib/python3.10/site-packages/pydantic/_internal/_config.py:373
  /usr/local/lib/python3.10/site-packages/pydantic/_internal/_config.py:373: UserWarning: Valid config keys have changed in V2:
  * 'orm_mode' has been renamed to 'from_attributes'
    warnings.warn(message, UserWarning)

main.py:112
  /app/src/api/main.py:112: DeprecationWarning: 
          on_event is deprecated, use lifespan event handlers instead.
  
          Read more about it in the
          [FastAPI docs for Lifespan Events](https://fastapi.tiangolo.com/advanced/events/).
          
    @app.on_event("startup")

../../../usr/local/lib/python3.10/site-packages/fastapi/applications.py:4495
  /usr/local/lib/python3.10/site-packages/fastapi/applications.py:4495: DeprecationWarning: 
          on_event is deprecated, use lifespan event handlers instead.
  
          Read more about it in the
          [FastAPI docs for Lifespan Events](https://fastapi.tiangolo.com/advanced/events/).
          
    return self.router.on_event(event_type)

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
=========================== short test summary info ============================
ERROR tests/integration/test_api_admin_integration.py
!!!!!!!!!!!!!!!!!!!! Interrupted: 1 error during collection !!!!!!!!!!!!!!!!!!!!
========================= 6 warnings, 1 error in 0.63s =========================
